### 冯诺依曼模型
1. 运算器
2. 控制器
3. 存储器
4. 输入设备
5. 输出设备

### 内存
单位换算： 1byte = 8bit
1kb = 1024byte
1mb = 1024 * 1024 byte

### 中央处理器
1. 位宽：指的是cpu一次可以计算多少数据
32位 -> 一次计算32位数据即4字节
64位 -> 一次计算64位数据即8字节

2. CPU内的组件：
- 寄存器：
    - 通用寄存器：存储待操作的数据
    - 程序计数器：存储下一条指令的**地址**
    - 指令寄存器：存储当前正在执行的指令
- 控制单元：
- 逻辑运算单元：

### 总线
1. 地址总线：指定cpu要操作的数据地址
2. 数据总线：读写内存数据
3. 控制总线：发送接收信号

读写内存的流程：地址总线指定要操作的数据地址--->控制总线控制是读还是写命令--->数据总线传输数据

### 输入输出设备
输入设备向cpu输入数据 输出设备用于cpu向外面输出数据 eg：按下键盘时需要控制总线来与cpu进行交互。

### 线路位宽和cpu位宽
首先 数据传输实际上是控制电压的高低 比如低电压代表0 高电压代表1
如果是一位一位的传输 叫做串行传输
为了避免低效的传输 需要线路的位宽可以一次读到所有的内存地址
比如 如果想控制4gb的内存地址 4gb = 4 * 1024 * 1024 * 1024 byte = 2的32次方
我们寻址是寻找字节开头 所以地址总线的位宽需要时32位宽的
cpu位宽最好不要小于地址总线位宽 要不然影响到下一个寻址操作了

所以很有意思的点是 32位从cpu只能控制4gb的内存地址 多了也用不上

### 程序执行过程
1. 从程序计数器取到指令地址然后通过地址总线寻址，数据准备好后可以通过数据总线将指令传递到了cpu的指令寄存器。
2. 程序计数器自增，自增大小取决于cpu位宽。
3. 最后cpu检测该指令的类型，计算类型的指令会传递给计算逻辑单元，存储类型的指令会传递给控制单元。
上面的过程循环往复

### CPU执行指令的四个阶段
1. 取指令：通过程序计数器读取指令地址  通过控制器来完成的
2. 解码指令：对指令进行解码   
3. 执行指令：cpu正式开始执行指令
4. 数据写回：将计算结果写回到寄存器或者内存
> 上面的过程叫做一个指令周期 流水线架构

### 拓展问题
- 64位CPU相较于32位CPU优势在哪里？64位的计算性能一定比32位的强吗？
    1. 64位cpu可以一次计算64位的数字，而32位的需要分步骤进行计算，但是大部分应用不会计算那么大的数字，所以只有当计算超过32位的数字时64位cpu的优势才会体现出来。
    2. 一般32位cpu的地址总线是32位的 只能寻址4gb的内存空间 而64位的cpu一般是48位的地址总线 可以寻址2^48byte内存空间。
- 软件32位和64位的区别？可以互相转换吗？
    1. 32位指令在64位机器上运行需要一套兼容机制即可，但是64位指令在32位机器上就非常困难了。
    2. 操作系统也是应用程序，所以会分为64位操作系统和32位操作系统，一般需要装兼容的。
    3. 总之 硬件说多少位时指的是位宽，即一次处理数据的大小，也就是cpu内部通用寄存器的的宽度，而软件一般指的是指令的位宽（长度）
