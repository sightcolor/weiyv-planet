# 腐烂的橘子

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/rotting-oranges/)

---

## 题目描述

> 在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：
> *   `0` 代表空单元格；
> *   `1` 代表新鲜橘子；
> *   `2` 代表腐烂的橘子。
>
> 每分钟，腐烂的橘子 **周围4个方向上** 的新鲜橘子都会腐烂。
>
> 返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。
>
> **示例:**
> ```
> 输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
> 输出：4
> ```
>
> ```
> 输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
> 输出：-1
> 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
> ```

---

## 解题思路

### 核心思想
**多源广度优先搜索 (Multi-source BFS)**

这个问题可以看作是腐烂过程的模拟。每一分钟，腐烂都会向外扩散一层。这种逐层扩散的特性，正是 **广度优先搜索 (BFS)** 的用武之地。

由于最初可能存在多个腐烂的橘子，它们会 **同时** 开始腐烂周围的橘子，所以这是一个 **多源 BFS** 问题。

我们的策略是：
1.  将所有初始的腐烂橘子作为 BFS 的第一层（源头）。
2.  模拟时间的流逝，每一轮 BFS 的循环（处理完当前队列中的所有元素）就代表“一分钟”过去了。
3.  我们需要一个计数器来追踪剩余新鲜橘子的数量。当没有新鲜橘子时，模拟结束。

### 算法步骤
1.  **初始化**:
    *   创建一个队列 `queue`，用于存放腐烂橘子的坐标。
    *   创建一个计数器 `fresh_oranges`，记录新鲜橘子的总数。
    *   **遍历一次网格**:
        *   将所有初始腐烂橘子 `(2)` 的坐标加入队列。
        *   统计所有新鲜橘子 `(1)` 的数量。
2.  **处理特殊情况**: 如果 `fresh_oranges` 初始就为 0，说明没有新鲜橘子需要腐烂，直接返回 0。
3.  **开始 BFS 循环**:
    *   初始化 `minutes = 0`。
    *   当队列不为空时，进入循环。这代表新的一分钟开始了。
    *   记录当前队列的大小 `level_size`，这代表在这一分钟开始时，有多少个橘子正在扩散。
    *   循环 `level_size` 次，处理当前层的所有腐烂橘子：
        *   出队一个腐烂橘子 `(r, c)`。
        *   检查其上、下、左、右四个方向的邻居。
        *   如果邻居 `(nr, nc)` 是一个新鲜橘子 `(1)`：
            *   将其标记为腐烂：`grid[nr][nc] = 2`。
            *   `fresh_oranges` 计数器减 1。
            *   将 `(nr, nc)` 的坐标入队，以便在下一分钟扩散。
    *   **更新时间**: 在处理完一整层后（即内层 `for` 循环结束后），如果队列中还有橘子（意味着发生了新的腐烂），则 `minutes` 加 1。
4.  **返回结果**:
    *   BFS 循环结束后，检查 `fresh_oranges` 的数量。
    *   如果为 0，说明所有橘子都成功腐烂，返回 `minutes`。
    *   如果大于 0，说明有橘子无法被腐烂，返回 `-1`。

### 复杂度分析
- **时间复杂度**: O(M * N)
  *(其中 M 和 N 是网格的行数和列数。每个单元格最多被访问一次。)*
- **空间复杂度**: O(M * N)
  *(在最坏情况下，所有橘子都是腐烂的，队列需要存储所有 M*N 个单元格。)*

---

## 代码实现

### C++ (您的实现：使用 temp 数组辅助)
*(这种实现将“感染”和“入队”分为两步，逻辑清晰，但多用了一个辅助数组。)*
```cpp
#include <vector>
#include <queue>

class Solution {
private:
    int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
public:
    int orangesRotting(std::vector<std::vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        std::queue<std::pair<int, int>> mq;
        int fresh = 0;

        // 1. 初始化：找到所有腐烂橘子和新鲜橘子
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == 1) fresh++;
                else if(grid[i][j] == 2) mq.push({i, j});
            }
        }    

        int time = 0;
        // 核心BFS循环
        while(!mq.empty() && fresh > 0) {
            int k = mq.size(); // 当前层的腐烂橘子数量
            bool infected_this_minute = false;

            for(int i = 0; i < k; i++) {
                auto [row, col] = mq.front();
                mq.pop();
                // 感染邻居
                for(int d = 0; d < 4; d++) {
                    int nr = row + dirs[d][0];
                    int nc = col + dirs[d][1];
                    if(nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] == 1) {
                        grid[nr][nc] = 2;
                        fresh--;
                        mq.push({nr, nc});
                        infected_this_minute = true;
                    }
                }
            }
            // 如果在这一分钟内发生了感染，时间才增加
            if (infected_this_minute) {
                time++;
            }
        }
        
        return fresh == 0 ? time : -1;
    }
};
```