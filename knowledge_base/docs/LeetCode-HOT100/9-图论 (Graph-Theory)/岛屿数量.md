# 岛屿数量

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/number-of-islands/)

---

## 题目描述

> 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。
>
> **示例:**
> ```
> 输入: grid = [
>   ["1","1","1","1","0"],
>   ["1","1","0","1","0"],
>   ["1","1","0","0","0"],
>   ["0","0","0","0","0"]
> ]
> 输出: 1
> ```
>
> ```
> 输入: grid = [
>   ["1","1","0","0","0"],
>   ["1","1","0","0","0"],
>   ["0","0","1","0","0"],
>   ["0","0","0","1","1"]
> ]
> 输出: 3
> ```

---

## 解题思路

### 核心思想
**网格上的图遍历**

我们可以将整个二维网格看作一个图，其中每个 `'1'`（陆地）是一个节点，相邻的陆地节点之间有边相连。问题的目标就变成了：**计算这个图中连通分量的数量**。

无论是深度优先搜索（DFS）还是广度优先搜索（BFS），都可以用来解决这个问题。基本思路是：
1.  遍历整个网格。
2.  当我们遇到一个 `'1'`（陆地）时，说明我们发现了一个新岛屿（或一个未被访问过的岛屿的一部分）。此时，我们将岛屿数量加一。
3.  然后，从这个点出发，通过 DFS 或 BFS 遍历所有与它相连的陆地，并将它们全部“淹没”（例如，标记为 `'0'` 或其他已访问状态）。这样做是为了确保这个岛屿的所有部分在后续的遍历中不会被重复计算。
4.  继续遍历网格，直到所有格子都被检查过。

### 思路一：深度优先搜索 (DFS)

#### 算法步骤
1.  **初始化**: `islands_count = 0`。
2.  **主循环**: 遍历网格中的每一个单元格 `(row, col)`。
3.  **发现新岛屿**: 如果 `grid[row][col] == '1'`:
    *   `islands_count++`。
    *   调用 `dfs(row, col)`，将与此单元格相连的所有陆地都淹没。
4.  **`dfs(row, col)` 函数**:
    *   **递归基 (Base Case)**: 如果当前坐标 `(row, col)` 超出边界，或者当前单元格是水 (`'0'`)，则直接返回。
    *   **淹没/标记**: 将 `grid[row][col]` 置为 `'0'`，表示已经访问过。
    *   **向四周探索**: 对当前单元格的上、下、左、右四个相邻方向递归调用 `dfs`。
5.  **返回**: 遍历结束后，返回 `islands_count`。

#### 复杂度分析
- **时间复杂度**: O(M * N)
  *(其中 M 和 N 分别是网格的行数和列数。每个单元格最多被访问两次（一次在主循环中，一次在 DFS 中）。)*
- **空间复杂度**: O(M * N)
  *(在最坏情况下，整个网格是一个巨大的岛屿，递归栈的深度可能达到 M * N。)*

---

### 思路二：广度优先搜索 (BFS)

#### 算法步骤
1.  **初始化**: `islands_count = 0`，创建一个队列 `queue`。
2.  **主循环**: 同 DFS。
3.  **发现新岛屿**: 如果 `grid[row][col] == '1'`:
    *   `islands_count++`。
    *   将当前坐标 `(row, col)` 入队，并立即将其淹没 `grid[row][col] = '0'`。
    *   **启动 BFS**:
        *   当队列不为空时，循环执行。
        *   出队一个坐标 `(r, c)`。
        *   检查其四个方向的邻居 `(nr, nc)`。
        *   如果邻居在边界内且是陆地 (`'1'`)，则将其入队，并立即淹没。
4.  **返回**: 遍历结束后，返回 `islands_count`。

#### 复杂度分析
- **时间复杂度**: O(M * N)
- **空间复杂度**: O(min(M, N))
  *(在最坏情况下，队列的大小取决于岛屿的最大宽度，最大可能是一整行或一整列。)*

---

## 代码实现

### C++ (思路一：深度优先搜索 / DFS)

```cpp
#include <vector>
#include <functional>

class Solution {
private:
    // 方向数组，方便向四周探索
    int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
public:
    int numIslands(std::vector<std::vector<char>>& grid) {
        if (grid.empty()) return 0;
        int m = grid.size(), n = grid[0].size();
        int islands_count = 0;

        std::function<void(int, int)> dfs = 
            [&](int row, int col) {
                // 递归基：越界或遇到水
                if (row < 0 || row >= m || col < 0 || col >= n || grid[row][col] == '0') {
                    return;
                }
                // 淹没当前陆地
                grid[row][col] = '0';
                // 向四周探索
                for (int i = 0; i < 4; ++i) {
                    dfs(row + dirs[i][0], col + dirs[i][1]);
                }
            };

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
                    islands_count++;
                    dfs(i, j);
                }
            }
        }
        return islands_count;
    }
};
```
### C++ (思路二：广度优先搜索 / BFS)
```C++

#include <vector>
#include <queue>

class Solution {
public:
    int numIslands(std::vector<std::vector<char>>& grid) {
        if (grid.empty()) return 0;
        int m = grid.size(), n = grid[0].size();
        int islands_count = 0;
        int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
                    islands_count++;
                    std::queue<std::pair<int, int>> q;
                    q.push({i, j});
                    grid[i][j] = '0'; // 标记为已访问

                    while (!q.empty()) {
                        auto [r, c] = q.front();
                        q.pop();
                        for (int k = 0; k < 4; ++k) {
                            int nr = r + dirs[k][0];
                            int nc = c + dirs[k][1];
                            if (nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] == '1') {
                                q.push({nr, nc});
                                grid[nr][nc] = '0'; // 标记为已访问
                            }
                        }
                    }
                }
            }
        }
        return islands_count;
    }
};
```