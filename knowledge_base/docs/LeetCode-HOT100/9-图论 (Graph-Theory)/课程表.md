# 课程表

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/course-schedule/)

---

## 题目描述

> 你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。
>
> 在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。
>
> 请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。
>
> **示例:**
> ```
> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：true
> 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
> ```
>
> ```
> 输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
> 输出：false
> 解释：学习课程 1 需先完成课程 0，而学习课程 0 又需先完成课程 1。这是不可能的。
> ```

---

## 解题思路

### 核心思想
**有向图环路检测 (Cycle Detection in a Directed Graph)**

这个问题本质上可以抽象为一个图论问题。我们可以将每门课程看作一个**节点**，将课程之间的先修关系看作一条**有向边**。例如，`[1, 0]` 表示要学习课程 `1` 必须先学习课程 `0`，这可以表示为一条从 `0` 指向 `1` 的有向边 `0 -> 1`。

因此，整个课程安排就构成了一个**有向图**。 "是否能完成所有课程" 这个问题，就等价于判断这个有向图中 **是否存在环路**。如果存在环路，例如 `A -> B -> C -> A`，那么就意味着 `A` 依赖 `B`，`B` 依赖 `C`，而 `C` 又反过来依赖 `A`，形成了一个死锁，永远无法完成学习。

检测有向图中的环，最经典和高效的方法是 **深度优先搜索 (DFS) + 三色标记法**。

### 算法步骤
1.  **构建图**:
    *   将输入的 `prerequisites` 数组转换成**邻接表**的表示形式。邻接表 `table` 是一个 `vector<vector<int>>`，其中 `table[i]` 存储了所有以课程 `i` 为先修课的后续课程列表。
2.  **三色标记法状态定义**:
    *   创建一个 `colors` 数组来记录每个节点（课程）的状态。
    *   `colors[i] = 0` (白色): 该节点从未被访问过。
    *   `colors[i] = 1` (灰色): 该节点**正在被访问**。即它在当前的 DFS 递归栈中。
    *   `colors[i] = 2` (黑色): 该节点**已经被完全访问**。即该节点及其所有后续节点都已被安全地探索完毕，没有发现环。
3.  **主循环**:
    *   遍历从 `0` 到 `numCourses - 1` 的所有课程。
    *   如果当前课程 `i` 的状态是 `0` (白色)，说明它属于一个新的、尚未探索的图连通分量，我们从它开始进行深度优先搜索 `dfs(i)`。
    *   如果 `dfs(i)` 返回 `true`，意味着在这次搜索中发现了环，我们立即可以断定无法完成所有课程，直接返回 `false`。
4.  **DFS 核心逻辑 (`dfs` 函数)**:
    *   **标记为灰色**: 当进入 `dfs(curr)` 时，首先将 `colors[curr]` 设为 `1`，表示它已进入递归栈。
    *   **遍历邻居**: 遍历 `curr` 的所有邻居节点 `x`。
        *   如果邻居 `x` 是**白色** (`colors[x] == 0`)，则对其进行递归调用 `dfs(x)`。如果 `dfs(x)` 返回 `true`，说明在下游发现了环，立即将 `true` 向上层传递。
        *   如果邻居 `x` 是**灰色** (`colors[x] == 1`)，**这是找到环的关键**！这意味着我们从当前路径上的一个节点，又访问回了同一个路径上的祖先节点，形成了一个闭环。立即返回 `true`。
        *   如果邻居 `x` 是**黑色** (`colors[x] == 2`)，说明这个邻居节点已经被安全地访问完毕，它引出的所有路径都是无环的。我们可以放心地跳过它。
    *   **标记为黑色**: 如果 `curr` 的所有邻居都遍历完了，且没有发现环（即函数没有中途返回 `true`），说明从 `curr` 出发的所有路径都是安全的。此时，在函数返回前，将 `colors[curr]` 设为 `2`，表示该节点已完成访问。
    *   **返回无环**: 最后，返回 `false`，表示从当前节点出发的路径没有发现环。
5.  **返回结果**:
    *   如果主循环正常结束，说明对所有节点进行 DFS 后都未发现环，返回 `true`。

### 复杂度分析
- **时间复杂度**: O(V + E)
  *(其中 V 是课程数 `numCourses`，E 是先修关系的数量 `prerequisites.size()`。因为每个节点和每条边在 DFS 过程中最多被访问一次。)*
- **空间复杂度**: O(V + E)
  *(邻接表需要 O(E) 的空间，`colors` 数组需要 O(V) 的空间，递归栈的深度在最坏情况下为 O(V)。)*

---

## 代码实现

### C++ 
```cpp
#include <vector>
#include <functional>

class Solution {
public:
    bool canFinish(int numCourses, std::vector<std::vector<int>>& prerequisites) {
        // 三色标记法: 0-未访问(白), 1-正在访问(灰), 2-已完成访问(黑)
        std::vector<int> colors(numCourses, 0);
        std::vector<std::vector<int>> table(numCourses);
        for(auto& it : prerequisites) {
            table[it[1]].push_back(it[0]);
        }
        
        // dfs函数: 如果有环，返回true；否则返回false
        std::function<bool(int curr)> dfs = [&](int curr) {
            // 标记为正在访问 (灰色)
            colors[curr] = 1;
            
            // 遍历所有后续课程
            for(auto& x : table[curr]) {
                // Case 1: 遇到未访问的节点，递归深入
                if(colors[x] == 0) {
                    if (dfs(x)) return true; // 如果下游发现环，立刻返回
                }
                // Case 2: 遇到正在访问的节点 (灰色)，说明找到环
                else if(colors[x] == 1) {
                    return true;
                }
                // Case 3: 遇到已完成的节点 (黑色)，安全，直接跳过
                // else if(colors[x] == 2) continue;
            }
            
            // 标记为已完成访问 (黑色)
            colors[curr] = 2;
            return false;
        };
        
        // 遍历所有课程，作为DFS的起点
        for(int i = 0; i < numCourses; i++) {
            // 只对未访问过的节点启动DFS
            if(colors[i] == 0) {
                if(dfs(i)) { // 如果dfs返回true，说明发现了环
                    return false;
                }
            }
        }
        
        return true;
    }
};
```