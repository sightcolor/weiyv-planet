# 31.下一个排列

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/next-permutation/)

---

## 题目描述

> 整数数组的一个 **排列**  是指将其所有成员以序列或线性顺序排列。
>
> *   例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`, `[1,3,2]`, `[3,1,2]`, `[2,3,1]`, `[2,1,3]`, `[3,2,1]` 。
>
> 整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。 更确切地说，如果将数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。
>
> *   例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
> *   类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
> *   而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。
>
> 给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。
>
> 必须 **[原地](https://baike.baidu.com/item/原地算法)** 修改，只允许使用额外常数空间。
>
> **示例:**
> ```
> 输入: nums = [1,2,3]
> 输出: [1,3,2]
> ```
> ```
> 输入: nums = [3,2,1]
> 输出: [1,2,3]
> ```
> ```
> 输入: nums = [1,1,5]
> 输出: [1,5,1]
> ```

---

## 解题思路

### 核心思想
该算法的核心思想是从后向前查找，找到第一个破坏降序排列的元素，然后将其与右侧大于它的最小元素交换，最后将交换后位置右侧的序列反转，使其变为升序，从而得到下一个字典序更大的排列。

### 算法步骤
1.  **从后向前查找第一个“小数”**: 从倒数第二个元素开始 (`curr = n - 2`) 向前遍历，找到第一个满足 `nums[curr] < nums[curr + 1]` 的元素。这个 `nums[curr]` 就是我们需要调整的“小数”。
2.  **处理完全降序情况**: 如果 `curr` 小于 0，说明整个数组是降序排列的（如 `[3,2,1]`），不存在下一个更大的排列。此时，直接将整个数组反转，得到最小的排列（升序），然后返回。
3.  **从后向前查找第一个“大数”**: 如果找到了这样的 `curr`，再从数组末尾 (`idx = n - 1`) 向前遍历，找到第一个大于 `nums[curr]` 的元素 `nums[idx]`。
4.  **交换**: 交换 `nums[curr]` 和 `nums[idx]`。这样可以保证新的排列比原来的大，并且是增大的幅度最小的。
5.  **反转**: 将 `curr` 位置之后的所有元素进行反转（`reverse(nums.begin() + curr + 1, nums.end())`）。 这样做是为了使这部分序列变为升序，从而确保整个新的排列是紧邻原排列的下一个字典序排列。
6.  **返回**: 完成原地修改。

### 复杂度分析
- **时间复杂度**: O(N)
  我们最多需要对数组进行两次遍历，一次是找到 `curr`，一次是找到 `idx` 并进行反转。因此，总的时间复杂度是 O(N)。
- **空间复杂度**: O(1)
  该算法是在原数组上进行修改，没有使用额外的与输入规模相关的数据结构，所以空间复杂度是 O(1)。

---

## 代码实现


```cpp
#include <vector>
#include <algorithm> // for std::reverse and std::swap

class Solution {
public:
    void nextPermutation(std::vector<int>& nums) {
        // 找到第一个前面小于后面的值
        int n = nums.size();
        if(n <= 1)
            return;
            
        int curr = n - 2;
        while(curr >= 0 && nums[curr] >= nums[curr + 1]) {
            curr--;
        }

        // 证明当前序列是非递增的 则下一个排列就是reverse
        if(curr < 0) {
            std::reverse(nums.begin(), nums.end());
            return;
        }

        // 否则 当前curr需要填写右边大于他的最小值交换一下
        int idx = n - 1;
        while(idx > curr && nums[idx] <= nums[curr]) {
            idx--;
        }
            
        std::swap(nums[idx], nums[curr]);
        std::reverse(nums.begin() + curr + 1, nums.end());
    }
};
```