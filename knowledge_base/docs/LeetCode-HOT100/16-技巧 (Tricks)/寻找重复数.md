# 287. 寻找重复数

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/find-the-duplicate-number/)

---

## 题目描述

> 给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。
>
> 假设 `nums` 中只存在一个重复的整数，但这个重复的数字可能会出现不止一次。
>
> 要求：
> *   不能修改原数组 (`nums`)
> *   只能使用额外的 `O(1)` 的空间
>
> **示例:**
> ```
> 输入: nums = [1,3,4,2,2]
> 输出: 2
> ```
> ```
> 输入: nums = [3,1,3,4,2]
> 输出: 3
> ```

---

## 解题思路

### 核心思想
这个问题的巧妙之处在于其限制条件：不能修改数组，且空间复杂度为 O(1)。这使得哈希表、排序等常规方法不再适用。

核心解法是将问题转化为**判断链表是否有环，并找出环的入口节点**。这个算法被称为 **Floyd 判圈算法**，也叫**快慢指针法**或**龟兔赛跑算法**。

**如何将数组问题转化为链表判环？**

我们可以把数组 `nums` 想象成一个链表。数组的**下标** `i` 代表当前节点，而 `nums[i]` 的值则代表下一个节点的“指针”。例如，对于 `nums = [1, 3, 4, 2, 2]`：
*   从下标 `0` 开始，值为 `nums[0] = 1`，所以下一个节点是下标 `1`。
*   在下标 `1`，值为 `nums[1] = 3`，所以下一个节点是下标 `3`。
*   在下标 `3`，值为 `nums[3] = 2`，所以下一个节点是下标 `2`。
*   在下标 `2`，值为 `nums[2] = 4`，所以下一个节点是下标 `4`。
*   在下标 `4`，值为 `nums[4] = 2`，所以下一个节点是下标 `2`。

这样就形成了一个序列：`0 -> 1 -> 3 -> 2 -> 4 -> 2 -> 4 -> ...`。因为数字 `2` 是重复的（`nums[3]=2`, `nums[4]=2`），导致多个“指针”指向了同一个位置（下标2），从而形成了一个环。 **这个环的入口点，就是重复的那个数字**。

### 算法步骤
整个算法分为两部分：

1.  **第一阶段：寻找环中的相遇点**
    *   **初始化**: 创建两个指针，`slow` (慢指针) 和 `fast` (快指针)，都指向数组的第一个元素 `nums[0]`。
    *   **遍历**: 在一个循环中，`slow` 每次移动一步 (`slow = nums[slow]`)，而 `fast` 每次移动两步 (`fast = nums[nums[fast]]`)。
    *   **相遇**: 由于链表中存在环，`fast` 指针最终会在环内追上 `slow` 指针。当 `slow == fast` 时，它们在环中的某个点相遇，我们结束第一阶段的循环。

2.  **第二阶段：寻找环的入口点**
    *   **初始化**: 将其中一个指针（比如 `slow`）重置回头节点，即 `slow = nums[0]`。保持 `fast` 指针在第一阶段的相遇点。
    *   **遍历**: 现在让 `slow` 和 `fast` 都以相同的速度移动，即每次都只移动一步 (`slow = nums[slow]`, `fast = nums[fast]`)。
    *   **相遇**: 它们下一次相遇的节点，就是环的入口点，也就是我们寻找的重复数字。 返回这个值即可。


### 复杂度分析
- **时间复杂度**: O(N)
  *(两个指针的移动都是线性的，第一阶段慢指针走 `k` 步，快指针走 `2k` 步；第二阶段两个指针都走 `m` 步。总步数与数组长度N成正比。)*
- **空间复杂度**: O(1)
  *(我们只使用了 `slow` 和 `fast` 两个指针，是常数级别的额外空间。)*

---

## 代码实现


```cpp
#include <vector>

class Solution {
public:
    int findDuplicate(std::vector<int>& nums) {
        // 快慢指针类似的思路
        int slow = 0;
        int fast = 0;

        // 第一阶段：找到相遇点
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);

        // 第二阶段：找到环的入口
        slow = 0; // 将一个指针重置到起点
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast]; // 两个指针同步前进
        }
        
        return fast; // 返回相遇点，即重复的数
    }
};
```