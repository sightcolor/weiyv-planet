# 旋转图像

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/rotate-image/)

---

## 题目描述

> 给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。
>
> 你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。
>
> **示例:**
> ```
> 输入: matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出: [[7,4,1],[8,5,2],[9,6,3]]
> ```

---

## 解题思路

### 核心思想
本解法通过两次独立的矩阵变换来实现顺时针旋转90度的效果，这是一种基于线性代数观察的巧妙方法。一个矩阵顺时针旋转90度，等价于先**沿水平中线上下翻转**，然后再**沿主对角线（左上到右下）翻转**。

代码实现的是等价的另一种变换组合：先**从上到下整体翻转**（相当于将每一行逆序），然后再**沿主对角线翻转**。

我们来分解这个过程：
假设矩阵为：
`1 2 3`
`4 5 6`
`7 8 9`

1.  **从上到下整体翻转 (reverse)**：将第一行与最后一行交换，第二行与倒数第二行交换...
    `7 8 9`
    `4 5 6`
    `1 2 3`

2.  **沿主对角线翻转**: 将 `matrix[i][j]` 与 `matrix[j][i]` 进行交换。
    `7 4 1`
    `8 5 2`
    `9 6 3`

经过这两步操作，我们便得到了顺时针旋转90度的结果。

### 算法步骤
1.  **上下翻转**: 调用 `reverse` 函数，将 `matrix` 的所有行进行整体翻转。
2.  **沿主对角线翻转**:
    *   使用双重循环遍历矩阵。外层循环 `i` 从 `0` 到 `n-1`，内层循环 `j` 从 `0` 到 `i-1`。
    *   `j < i` 的条件确保了我们只遍历主对角线左下方的元素，避免了重复交换。
    *   在循环中，交换 `matrix[i][j]` 和 `matrix[j][i]`。
3.  **完成**: 两次变换结束后，原矩阵 `matrix` 就被修改为了旋转90度后的结果。

### 复杂度分析
- **时间复杂度**: O(N^2)
  *其中 N 是矩阵的边长。上下翻转需要 O(N^2) 的时间，沿主对角线翻转也需要 O(N^2) 的时间。*
- **空间复杂度**: O(1)
  *所有操作都是在原矩阵上进行的，没有使用额外的存储空间。*

---

## 代码实现

```cpp
#include <vector>
#include <algorithm> // for std::reverse and std::swap

class Solution {
public:
    void rotate(std::vector<std::vector<int>>& matrix) {
        int n = matrix.size();
        
        // 步骤 1: 从上到下整体翻转矩阵的行
        // 例如, [,,] -> [,,]
        std::reverse(matrix.begin(), matrix.end());
        
        // 步骤 2: 沿主对角线 (从左上到右下) 进行翻转
        for(int i = 0; i < n; ++i) {
            // j < i 确保我们只处理对角线一侧的元素，避免重复交换
            for(int j = 0; j < i; ++j) {
                std::swap(matrix[i][j], matrix[j][i]);
            }
        }
    }
};
```