# 螺旋矩阵

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/spiral-matrix/)

---

## 题目描述

> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。
>
> **示例:**
> ```
> 输入: matrix = [,,]
> 输出:
> ```

---

## 解题思路

### 核心思想
本解法采用**深度优先搜索 (DFS)** 来模拟螺旋遍历的过程。我们可以想象有一个“机器人”从 `(0, 0)` 位置开始，沿着固定的方向（初始为向右）行走。每走一步，就记录下当前位置的元素，并标记该位置为已访问。

当机器人准备走向下一个位置时，它会检查目标位置是否**出界**或**已经被访问过**。
-   如果出界或已访问，说明撞墙了，机器人需要**顺时针改变方向**（右 -> 下 -> 左 -> 上）。
-   换了新方向后，如果发现新方向的下一步仍然是“墙”，那就说明所有可走的路都走完了，遍历结束。
-   否则，就朝着新方向递归地走下去。

### 算法步骤
1.  **初始化**:
    *   定义一个 `dirs[4][2]` 的方向数组，依次表示右、下、左、上四个方向的坐标偏移。
    *   创建一个与 `matrix` 等大的 `visited` 布尔矩阵，用于记录已访问过的位置。
    *   创建一个结果向量 `res`。
2.  **启动 DFS**: 从起点 `(0, 0)` 和初始方向 `0`（向右）开始调用 `dfs` 递归函数。
3.  **DFS 递归函数 `dfs(row, col, step)`**:
    *   **尝试按原方向前进**: 首先计算按当前方向 `step` 的下一步 `(next_row, next_col)`。
    *   **判断是否需要转向**: 检查 `(next_row, next_col)` 是否有效（未出界且未被访问）。如果无效（撞墙），则顺时针改变方向，`step = (step + 1) % 4`。
    *   **访问当前节点**: 将当前位置 `(row, col)` 的值加入 `res`，并将其在 `visited` 中标记为 `true`。
    *   **判断是否结束**: 再次根据**更新后**的方向 `step` 计算 `(next_row, next_col)`。如果新位置仍然无效，说明已经无路可走，递归结束，直接 `return`。
    *   **递归调用**: 如果新方向的下一步是有效的，则调用 `dfs(next_row, next_col, step)` 继续遍历。

### 复杂度分析
- **时间复杂度**: O(M * N)
  *每个矩阵中的元素都会被访问且仅被访问一次。*
- **空间复杂度**: O(M * N)
  *需要一个 `visited` 矩阵来记录访问状态。同时，递归的深度在最坏情况下也可能达到 O(M * N)，所以栈空间开销也是 O(M * N)。*

---

## 代码实现

```cpp
#include <vector>
#include <iostream>

using namespace std;

/**
 * @class Solution
 * @brief 使用深度优先搜索 (DFS) 解决螺旋矩阵问题。
 *
 * 核心思想是模拟一个“探路者”在矩阵中行走。
 * 1. 从 (0, 0) 开始，初始方向向右。
 * 2. 访问当前格子，并将其值存入结果，同时标记为已访问。
 * 3. 尝试沿着当前方向前进，如果下一步会出界或遇到已访问过的格子，则顺时针转向。
 * 4. 再次尝试前进，如果新方向仍然无法前进，说明已经走到了尽头，遍历结束。
 * 5. 否则，递归地在下一个位置继续行走。
 */
class Solution {
private:
    // 存储矩阵的维度，避免在递归中重复获取
    int m, n; 
    
    // visited 矩阵用于标记一个格子是否已被访问，防止重复遍历
    vector<vector<bool>> visited;
    
    // res 向量用于存储螺旋遍历的结果
    vector<int> res;
    
    // dirs 数组定义了四个方向：右, 下, 左, 上。
    // 索引 0: 右 {0, 1} (行不变, 列+1)
    // 索引 1: 下 {1, 0} (行+1, 列不变)
    // 索引 2: 左 {0,-1} (行不变, 列-1)
    // 索引 3: 上 {-1,0} (行-1, 列不变)
    // (directionIndex + 1) % 4 可以实现顺时针 90 度转向。
    int dirs[4][2] = {
        {0, 1}, {1, 0}, {0, -1}, {-1, 0}
    };

public:
    /**
     * @brief 深度优先搜索的递归函数
     * @param matrix 输入的矩阵
     * @param row 当前所在的行
     * @param col 当前所在的列
     * @param directionIndex 当前的前进方向索引 (0:右, 1:下, 2:左, 3:上)
     */
    void dfs(const vector<vector<int>>& matrix, int row, int col, int directionIndex) {
        // --- 1. 处理当前节点 ---
        // 将当前格子的值添加到结果中，并标记为已访问
        res.push_back(matrix[row][col]);
        visited[row][col] = true;

        // --- 2. 决定下一步的方向 ---
        // 尝试沿着当前方向前进，计算出下一个格子的坐标
        int next_row = row + dirs[directionIndex][0];
        int next_col = col + dirs[directionIndex][1];
        int next_direction = directionIndex; // 默认保持原方向

        // 如果下一步会出界或者遇到已经访问过的格子，就需要转向
        if (next_row < 0 || next_row >= m || next_col < 0 || next_col >= n || visited[next_row][next_col]) {
            // 顺时针转向90度
            next_direction = (directionIndex + 1) % 4;
        }

        // --- 3. 执行下一步或终止 ---
        // 使用更新后的方向，再次计算下一个格子的坐标
        next_row = row + dirs[next_direction][0];
        next_col = col + dirs[next_direction][1];

        // 检查新路径是否有效。如果转向后仍然出界或遇到已访问格子，说明遍历完成
        if (next_row < 0 || next_row >= m || next_col < 0 || next_col >= n || visited[next_row][next_col]) {
            return; // 已经无路可走，结束递归
        }

        // 如果路径有效，则递归到下一个格子
        dfs(matrix, next_row, next_col, next_direction);
    }

    /**
     * @brief 螺旋矩阵的主函数入口
     * @param matrix m x n 的二维整数矩阵
     * @return 按照螺旋顺序排列的一维向量
     */
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        // 处理空矩阵的边界情况
        if (matrix.empty() || matrix[0].empty()) {
            return {};
        }

        // --- 初始化成员变量 ---
        this->m = matrix.size();
        this->n = matrix[0].size();
        
        // 调整 visited 矩阵的大小，并全部初始化为 false
        visited.assign(m, vector<bool>(n, false));
        
        // 清空 res，以防在同一个 Solution 对象上多次调用
        res.clear();

        // 从左上角 (0,0) 开始，初始方向向右 (索引 0)
        dfs(matrix, 0, 0, 0);

        return res;
    }
};
```

### 额外说明：迭代解法

虽然您的 DFS 解法非常巧妙，但在解决螺旋矩阵问题时，最常见和推荐的通常是**迭代解法**。迭代法通过维护四个边界（`top`, `bottom`, `left`, `right`）来模拟螺旋路径，通常代码更直接，且没有递归带来的栈深度限制风险。

迭代法的思路如下：
1.  定义四个边界：`top = 0`, `bottom = m-1`, `left = 0`, `right = n-1`。
2.  在一个循环中，依次遍历四条边：
    *   从 `left` 到 `right` 遍历上边界（`top`行）。遍历完后 `top++`。
    *   从 `top` 到 `bottom` 遍历右边界（`right`列）。遍历完后 `right--`。
    *   从 `right` 到 `left` 遍历下边界（`bottom`行）。遍历完后 `bottom--`。
    *   从 `bottom` 到 `top` 遍历左边界（`left`列）。遍历完后 `left++`。
3.  循环直到 `left > right` 或 `top > bottom`。
