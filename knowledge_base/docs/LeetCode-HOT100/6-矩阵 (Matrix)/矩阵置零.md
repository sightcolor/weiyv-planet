# 矩阵置零

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/set-matrix-zeroes/)

---

## 题目描述

> 给定一个 `m x n` 的矩阵，如果一个元素为 `0` ，则将其所在行和列的所有元素都设为 `0` 。请使用 **原地** 算法。
>
> **示例:**
> ```
> 输入: matrix = [[1,1,1],[1,0,1],[1,1,1]]
> 输出: [[1,0,1],[0,0,0],[1,0,1]]
> ```

---

## 解题思路

### 核心思想
为了实现 O(1) 的原地空间复杂度，我们不能使用额外的数组来记录需要置零的行和列。一个巧妙的方法是利用矩阵的**第一行和第一列**作为标记空间。

但是，第一行和第一列本身也可能需要被置零，如果直接用来标记，它们自身的原始状态信息就会丢失。因此，我们需要使用两个独立的布尔变量 `row_zero` 和 `col_zero` 来专门记录第一行和第一列是否**最初**就包含零。

### 算法步骤
1.  **预处理标记变量**:
    *   创建两个布尔变量 `row_zero` 和 `col_zero`，初始为 `false`。
    *   遍历第一行，如果发现任何一个元素为 `0`，则将 `row_zero` 设为 `true`。
    *   遍历第一列，如果发现任何一个元素为 `0`，则将 `col_zero` 设为 `true`。
    *   这一步是为了保存第一行和第一列的最终状态，防止被后续的标记操作污染。

2.  **用第一行/列标记内部矩阵**:
    *   遍历除第一行和第一列之外的内部矩阵（即从 `(1, 1)` 到 `(m-1, n-1)`）。
    *   如果发现 `matrix[i][j] == 0`，就将这个信息标记到对应的第一行和第一列上，即 `matrix[i][0] = 0` 和 `matrix[0][j] = 0`。

3.  **根据标记置零内部矩阵**:
    *   再次遍历内部矩阵（从 `(1, 1)` 开始）。
    *   对于每个位置 `(i, j)`，检查其对应的标记位 `matrix[i][0]` 或 `matrix[0][j]` 是否为 `0`。
    *   如果任意一个标记位为 `0`，就将 `matrix[i][j]` 置为 `0`。

4.  **处理第一行和第一列**:
    *   最后，根据第一步中记录的 `row_zero` 和 `col_zero` 的值来决定是否要将第一行和第一列整体置零。
    *   如果 `row_zero` 为 `true`，则将整个第一行置零。
    *   如果 `col_zero` 为 `true`，则将整个第一列置零。

### 复杂度分析
- **时间复杂度**: O(M * N)
  *我们需要对矩阵进行数次遍历，但每次都是线性的，所以总的时间复杂度与矩阵的大小成正比。*
- **空间复杂度**: O(1)
  *我们只使用了两个额外的布尔变量来存储状态，这是常数级别的空间。*

---

## 代码实现

```cpp
class Solution {
public:
    /**
     * 将矩阵中包含0的行和列置零，使用原地算法（O(1)额外空间）。
     * 思路：使用两个标记变量记录第一行和第一列是否原本包含0。
     * 然后，利用第一行和第一列作为标记数组，记录内部矩阵中需要置零的行/列。
     * 最后，根据标记置零内部矩阵，并处理第一行/列。
     * 
     * 一个自然的想法就是将需要置0的行和列保存到数组中 然后遍历数组来置零
     * 但是这样空间复杂度为O(m + n) 
     * 看过题解之后 我的理解如下
     * 首先使用两个标记变量来标记第一行和第一列是否该被置0 然后遍历除了第一行和第一列之外的数组 这样第一行和第一列就成为了我们的标记数组 最后我们就可以通过第一行和第一列来执行置零操作 然后通过标记变量来决定第一行和第一列是否该被置零
     * 
     * @param matrix 输入的二维矩阵（将被原地修改）
     */
    void setZeroes(std::vector<std::vector<int>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) {
            return;  // 处理空矩阵，直接返回
        }

        int m = matrix.size();    // 矩阵行数
        int n = matrix[0].size(); // 矩阵列数

        // 初始化标记变量：记录第一行和第一列是否原本包含0
        bool first_row_has_zero = false;
        bool first_col_has_zero = false;

        // 检查第一行是否包含0
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                first_row_has_zero = true;
                break;
            }
        }

        // 检查第一列是否包含0
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                first_col_has_zero = true;
                break;
            }
        }

        // 使用第一行和第一列标记内部矩阵中需要置零的行/列
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;  // 标记该行需要置零
                    matrix[0][j] = 0;  // 标记该列需要置零
                }
            }
        }

        // 根据标记，将内部矩阵的对应行/列置零
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        // 使用标记变量处理第一行
        if (first_row_has_zero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }

        // 使用标记变量处理第一列
        if (first_col_has_zero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
};
```