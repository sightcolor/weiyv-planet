# 寻找旋转排序数组中的最小值

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)

---

## 题目描述

> 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 可能变为：
> -   若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
> -   若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
>
> 给你一个元素 **值互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了若干次旋转。请你找出并返回数组中的 **最小元素** 。
>
> 你必须设计一个时间复杂度为 `O(log n)` 的算法来解决此问题。
>
> **示例:**
> ```
> 输入：nums = [3,4,5,1,2]
> 输出：1
> 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
> ```
>
> ```
> 输入：nums = [4,5,6,7,0,1,2]
> 输出：0
> 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
> ```

---

## 解题思路

### 核心思想
**利用旋转数组的局部有序性进行二分查找**

`O(log n)` 的时间复杂度要求明确指向了**二分查找**。旋转后的数组虽然整体无序，但它被“旋转点”（即最小值）分成了两个单调递增的段落。我们的目标就是通过二分查找，不断缩小范围，最终定位到这个最小值。

最小值是整个数组中唯一一个**比它前一个元素小**的数（如果考虑循环的话），这也是数组的“拐点”。

### 特殊情况处理
首先，可以处理一个特殊情况：如果数组根本没有旋转（或旋转了n次），那么 `nums[0] <= nums[n-1]`。此时，`nums[0]` 就是最小值，可以直接返回。这可以作为算法的优化，也可以被包含在主逻辑中。

---

### 方法一：比较 `nums[mid]` 和 `nums[right]` (或 `nums[left]`)
这个方法的思路是，通过比较中间元素 `nums[mid]` 和区间右端点 `nums[right]` 的大小，来判断最小值（拐点）在哪一侧。

-   **`if (nums[mid] < nums[right])`**:
    -   这意味着从 `mid` 到 `right` 这个区间是**单调递增**的。
    -   那么，最小值**不可能**在这个区间内（除非就是 `nums[mid]` 本身）。
    -   因此，我们可以安全地舍弃右半部分，将搜索范围缩小到 `[left, mid]`。即 `right = mid`。
-   **`else (nums[mid] > nums[right])`**:
    -   这意味着 `mid` 位于前半段（值较大的那段），而拐点一定在 `mid` 的**右侧**。
    -   `nums[mid]` 本身不可能是最小值，所以我们可以将搜索范围缩小到 `[mid + 1, right]`。即 `left = mid + 1`。

循环结束后，`left` 和 `right` 会相遇，指向的位置就是最小值。

### 方法二：比较 `nums[mid]` 和 `nums.back()`
这个方法与“搜索旋转排序数组”的思路一致，通过与一个固定的参照物（数组最后一个元素 `nums.back()`）比较，来判断 `mid` 位于前半段还是后半段。
-   **前半段**: 值较大，所有元素都 `> nums.back()`。
-   **后半段**: 值较小，所有元素都 `<= nums.back()`。最小值就在这个段的开头。

-   **`if (nums[mid] > nums.back())`**:
    -   说明 `mid` 在前半段（值较大的那段）。
    -   那么，最小值一定在 `mid` 的**右侧**。
    -   我们可以安全地舍弃左半部分，将搜索范围缩小到 `[mid + 1, right]`。即 `left = mid + 1`。
-   **`else (nums[mid] <= nums.back())`**:
    -   说明 `mid` 在后半段（值较小的那段），`nums[mid]` **有可能是最小值**。
    -   我们需要继续在左侧（包含 `mid`）寻找更小的值。
    -   将搜索范围缩小到 `[left, mid]`。即 `right = mid`。

循环结束后，`left` 指向的位置就是最小值。

### 复杂度分析 (两种方法相同)
- **时间复杂度**: O(log N)
- **空间复杂度**: O(1)

---

## 代码实现

### 方法一：比较 `nums[mid]` 和 `nums[right]`
```cpp
#include <vector>

class Solution {
public:
    int findMin(std::vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] < nums[right]) {
                // mid 在右半段（值小），最小值在 [left, mid]
                right = mid;
            } else { // nums[mid] > nums[right]
                // mid 在左半段（值大），最小值在 [mid + 1, right]
                left = mid + 1;
            }
        }
        // 循环结束时, left == right, 指向最小值
        return nums[left];
    }
};
```
### 方法二：比较 nums[mid] 和 nums.back()
```C++
#include <vector>

class Solution {
public:
    int findMin(std::vector<int>& nums) {
        int n = nums.size();
        // 优化：处理未旋转或旋转n次的情况
        if (nums[0] <= nums[n - 1]) {
            return nums[0];
        }
        
        int left = 0, right = n - 1;
        int last = nums.back();
        
        // 寻找后半段（值小）的第一个元素
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] > last) {
                // mid 在前半段（值大），最小值在右侧
                left = mid + 1;
            } else { // nums[mid] <= last
                // mid 在后半段（值小），可能是最小值，继续向左找
                right = mid;
            }
        }
        return nums[left];
    }
};
```