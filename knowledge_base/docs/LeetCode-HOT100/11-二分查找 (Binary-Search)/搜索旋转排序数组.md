# 搜索旋转排序数组

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

---

## 题目描述

> 整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。
>
> 在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如, `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。
>
> 给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。
>
> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。
>
> **示例:**
> ```
> 输入：nums = [4,5,6,7,0,1,2], target = 0
> 输出：4
> ```
>
> ```
> 输入：nums = [4,5,6,7,0,1,2], target = 3
> 输出：-1
> ```

---

## 解题思路

### 核心思想
**改造二分查找 — 判断 `mid` 和 `target` 是否在同一侧**

`O(log n)` 的时间复杂度要求明确指向了**二分查找**。然而，由于数组被旋转，标准的二分查找失效了，因为数组不再是完全单调递增的。

关键在于，旋转后的数组实际上由**两个**单调递增的段落组成。例如 `[4,5,6,7,0,1,2]`，可以看作 `[4,5,6,7]` 和 `[0,1,2]` 两段。我们的挑战是在二分查找的每一步，都能正确地判断应该舍弃哪一半区间。

一个非常巧妙的思路是，选取一个**参照物**（例如数组的第一个或最后一个元素），来判断 `nums[mid]` 和 `target` 是否在旋转点的同一侧。我们选择 `nums.back()` 作为参照物：
-   所有在**前半段**（值较大）的数，都 **大于** `nums.back()`。
-   所有在**后半段**（值较小）的数，都 **小于或等于** `nums.back()`。

这样，我们就可以在二分查找的 `while` 循环中进行分类讨论：

1.  **`nums[mid]` 和 `target` 在旋转点的两侧**:
    *   **情况 A**: `nums[mid]` 在前半段 (`> nums.back()`)，而 `target` 在后半段 (`<= nums.back()`)。此时，`target` 一定在 `mid` 的右边，所以我们收缩左边界：`left = mid + 1`。
    *   **情况 B**: `nums[mid]` 在后半段 (`<= nums.back()`)，而 `target` 在前半段 (`> nums.back()`)。此时，`target` 一定在 `mid` 的左边，所以我们收缩右边界：`right = mid`。

2.  **`nums[mid]` 和 `target` 在旋转点的同一侧**:
    *   在这种情况下，`mid` 和 `target` 之间的关系恢复了局部的单调性。我们可以像**标准二分查找**一样处理：
    *   如果 `nums[mid] < target`，说明目标在右边，`left = mid + 1`。
    *   如果 `nums[mid] >= target`，说明目标在左边或者就是 `mid`，`right = mid`。

通过这套逻辑，我们可以在每一步都正确地缩小搜索范围。

### 算法步骤
1.  **初始化**: `left = 0`, `right = nums.size()` (左闭右开区间)。选取 `last = nums.back()` 作为参照。
2.  **二分查找循环**: 当 `left < right` 时：
    *   计算 `mid`。
    *   判断 `nums[mid]` 和 `target` 是否在 `last` 的同一侧。
    *   **异侧**: 根据上述情况 A 或 B，更新 `left` 或 `right`。
    *   **同侧**: 根据标准二分查找的逻辑，更新 `left` 或 `right`。
3.  **返回结果**: 循环结束后，`left` 指向的是第一个大于等于 `target` 的位置（在“概念上”的排序数组中）。我们需要进行最后的检查：
    *   `left` 是否越界？
    *   `nums[left]` 是否真的等于 `target`？
    *   如果都满足，返回 `left`；否则返回 `-1`。

### 复杂度分析
- **时间复杂度**: O(log N)
  *(每次循环都将搜索区间缩小一半。)*
- **空间复杂度**: O(1)
  *(只需要常数级别的额外空间。)*

---

## 代码实现

### C++ 
```cpp
#include <vector>

class Solution {
public:
    int search(std::vector<int>& nums, int target) {
        if (nums.empty()) {
            return -1;
        }

        int n = nums.size();
        int left = 0, right = n; // 左闭右开区间 [left, right)
        int last = nums.back();

        while (left < right) {
            int mid = left + (right - left) / 2;
            int x = nums[mid];

            // Case 1: mid 和 target 在旋转点的两侧
            // mid 在前半段 (大), target 在后半段 (小)
            if (x > last && target <= last) {
                left = mid + 1; // target 在 mid 右侧
            } 
            // mid 在后半段 (小), target 在前半段 (大)
            else if (x <= last && target > last) {
                right = mid; // target 在 mid 左侧
            }
            // Case 2: mid 和 target 在旋转点的同侧，退化为标准二分
            else {
                if (x < target) {
                    left = mid + 1;
                } else { // x >= target
                    right = mid;
                }
            }
        }
        
        // 循环结束后, left 是第一个 >= target 的位置（或 n）
        // 必须检查 left 是否越界，以及该位置的值是否真的是 target
        if (left < n && nums[left] == target) {
            return left;
        }
        
        return -1;
    }
};
```