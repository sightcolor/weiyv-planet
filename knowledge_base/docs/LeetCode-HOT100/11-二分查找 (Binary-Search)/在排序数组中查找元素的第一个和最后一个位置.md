# 在排序数组中查找元素的第一个和最后一个位置

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

---

## 题目描述

> 给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。
>
> 如果数组中不存在目标值 `target`，返回 `[-1, -1]`。
>
> 你必须设计并实现时间复杂度为 `O(log n)` 的算法来解决此问题。
>
> **示例:**
> ```
> 输入：nums = [5,7,7,8,8,10], target = 8
> 输出：[3,4]
> ```
>
> ```
> 输入：nums = [5,7,7,8,8,10], target = 6
> 输出：[-1,-1]
> ```

---

## 解题思路

### 核心思想
**二分查找 (Binary Search)**

题目要求在排序数组中以 `O(log n)` 的时间复杂度查找，这明确指向了**二分查找**算法。由于我们需要找到一个可能重复出现的目标值的“起始位置”和“结束位置”，简单的二分查找（找到任意一个目标值就返回）是不够的。

我们有两种主要的实现策略：

### 方法一：利用 C++ STL `lower_bound` 和 `upper_bound`
C++ 算法库提供了两个非常有用的函数，它们本身就是基于二分查找实现的：
-   `std::lower_bound(begin, end, val)`: 返回一个指向**第一个不小于** `val` 的元素的迭代器。
-   `std::upper_bound(begin, end, val)`: 返回一个指向**第一个大于** `val` 的元素的迭代器。

这完美地契合了我们的需求：
1.  `target` 的**左边界**就是 `lower_bound` 找到的位置。
2.  `target` 的**右边界**就是 `upper_bound` 找到的位置再减 1。

**算法步骤**:
1.  调用 `lower_bound` 寻找左边界 `left`。
2.  进行合法性检查：如果 `left` 指向了数组末尾，或者 `*left` 的值不等于 `target`，说明 `target` 不存在，返回 `[-1, -1]`。
3.  调用 `upper_bound` 寻找右边界 `right`。
4.  计算索引并返回：左边界索引是 `left - nums.begin()`，右边界索引是 `right - nums.begin() - 1`。

### 方法二：手写二分查找 + 中心扩散
这个方法更直观，分两步走：
1.  **快速定位**: 使用一个标准的二分查找，**找到任意一个** `target` 的位置 `initial_pos`。如果找不到，直接返回 `[-1, -1]`。
2.  **中心扩散**: 从 `initial_pos` 开始，分别向左和向右进行线性扫描，直到找到 `target` 连续区间的两个端点。

**算法步骤**:
1.  **二分查找定位**:
    *   使用标准的左闭右闭 `[left, right]` 二分查找模板。
    *   如果 `nums[mid] == target`，记录 `mid` 并 `break`。
    *   如果循环结束都未找到 `target`，返回 `[-1, -1]`。
2.  **向两边扩散**:
    *   初始化 `start = initial_pos`, `end = initial_pos`。
    *   向左扫描：`while (start > 0 && nums[start - 1] == target) start--;`
    *   向右扫描：`while (end < n - 1 && nums[end + 1] == target) end++;`
3.  返回 `{start, end}`。

### 复杂度分析 (两种方法相同)
- **时间复杂度**: O(log N)
  *(方法一的 `lower/upper_bound` 都是 O(log N)。方法二的二分查找是 O(log N)，中心扩散在最坏情况下（整个数组都是 `target`）是 O(N)，但平均情况下很快，整体复杂度由二分主导。)*
- **空间复杂度**: O(1)
  *(只需要常数级别的额外空间。)*

---

## 代码实现

### 方法一：使用 C++ STL
```cpp
#include <vector>
#include <algorithm> // for lower_bound, upper_bound

class Solution {
public:
    std::vector<int> searchRange(std::vector<int>& nums, int target) {
        // 1. 使用 lower_bound 寻找左边界
        auto left_it = std::lower_bound(nums.begin(), nums.end(), target);
        
        // 2. 检查 target 是否存在
        if (left_it == nums.end() || *left_it != target) {
            return {-1, -1};
        }
        
        // 3. 使用 upper_bound 寻找右边界的下一个位置
        auto right_it = std::upper_bound(nums.begin(), nums.end(), target);
        
        // 4. 计算索引并返回
        int left_idx = static_cast<int>(left_it - nums.begin());
        int right_idx = static_cast<int>(right_it - nums.begin() - 1);
        
        return {left_idx, right_idx};
    }
};
```
### 方法二：手写二分 + 中心扩散
```C++

#include <vector>

class Solution {
public:
    std::vector<int> searchRange(std::vector<int>& nums, int target) {
        if (nums.empty()) {
            return {-1, -1};
        }

        int n = nums.size();
        int left = 0, right = n - 1;
        int initial_pos = -1;

        // 步骤1: 标准二分查找，定位任意一个 target
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                initial_pos = mid;
                break;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else { // nums[mid] > target
                right = mid - 1;
            }
        }

        if (initial_pos == -1) {
            return {-1, -1};
        }

        // 步骤2: 中心扩散
        int start = initial_pos, end = initial_pos;

        // 向左扩散
        while (start > 0 && nums[start - 1] == target) {
            start--;
        }

        // 向右扩散
        while (end < n - 1 && nums[end + 1] == target) {
            end++;
        }

        return {start, end};
    }
};
```