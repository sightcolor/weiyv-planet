# 搜索插入位置

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/search-insert-position/)

---

## 题目描述

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
> **示例:**
> ```
> 输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
>
> ```
> 输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```
>
> ```
> 输入: nums = [1,3,5,6], target = 7
> 输出: 4
> ```

---

## 解题思路

### 核心思想
**二分查找 (Binary Search)**

题目给出了一个**已排序**的数组，并要求 `O(log n)` 的时间复杂度，这立刻提示我们应该使用**二分查找**。

这个问题的本质可以统一为：**寻找数组中第一个大于或等于 `target` 的元素的位置**。
- 如果 `target` 存在于数组中，这个位置就是 `target` 的索引。
- 如果 `target` 不存在，这个位置就是 `target` 应该被插入的位置，以保持数组的有序性。

我们采用**左闭右开 `[left, right)`**的区间定义来进行二分查找。这是一个非常优雅的模板，其特点如下：
- **区间定义**: 搜索区间为 `[left, right)`，包含 `left`，但不包含 `right`。
- **初始化**: `left = 0`, `right = nums.size()`。`right` 初始化为 `size()` 而不是 `size() - 1` 正是为了满足右开的定义，这也巧妙地处理了 `target` 应该插入到数组末尾的情况。
- **循环条件**: `while (left < right)`。当 `left == right` 时，区间 `[left, left)` 为空，搜索结束。
- **区间收缩**:
  - `if (nums[mid] < target)`: 如果中间值小于目标，说明目标值（或其插入位置）一定在 `mid` 的右侧。因此，我们将搜索区间的左边界收缩到 `mid` 的下一个位置，即 `left = mid + 1`。
  - `else (nums[mid] >= target)`: 如果中间值大于或等于目标，说明目标值（或其插入位置）**可能就是 `mid`**，或者在 `mid` 的左侧。我们不能排除 `mid`，所以将搜索区间的右边界收缩到 `mid`，即 `right = mid`。
- **返回结果**: 循环结束时，`left` 和 `right` 指针会相遇。此时 `left`（或 `right`）指向的位置，就是第一个大于或等于 `target` 的元素位置。

### 算法步骤
1.  **初始化指针**: `left = 0`, `right = nums.size()`，定义搜索区间 `[0, nums.size())`。
2.  **循环搜索**: 当 `left < right` 时，执行循环：
    *   计算中间位置 `mid = left + (right - left) / 2` (防止溢出)。
    *   比较 `nums[mid]` 和 `target`。
    *   如果 `nums[mid] < target`，说明 `mid` 以及其左边的元素都太小了，更新 `left = mid + 1`。
    *   否则（`nums[mid] >= target`），说明 `mid` 可能是答案，或者答案在 `mid` 左边，更新 `right = mid`。
3.  **返回结果**: 循环终止时，`left` 即为所求的插入位置。

### 复杂度分析
- **时间复杂度**: O(log N)
  *(其中 N 是数组 `nums` 的长度。每次循环都将搜索区间缩小一半。)*
- **空间复杂度**: O(1)
  *(只需要常数级别的额外空间来存储 `left`, `right`, `mid` 指针。)*

---

## 代码实现

### C++ (您的实现)
*(该实现是“左闭右开”二分查找的经典模板，简洁且正确。)*
```cpp
#include <vector>

class Solution {
public:
    int searchInsert(std::vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        
        // 定义左闭右开的搜索区间 [left, right)
        while(left < right) {
            int mid = left + (right - left) / 2; // 防止整数溢出
            
            if(nums[mid] < target) {
                // 目标值在右半部分，收缩左边界
                // 新的搜索区间是 [mid + 1, right)
                left = mid + 1;
            } else { // nums[mid] >= target
                // 目标值在左半部分，或者 mid 本身就是目标
                // 新的搜索区间是 [left, mid)
                right = mid;
            }
        }
        
        // 循环结束时，left 指向第一个 >= target 的元素位置
        return left;
    }
};
```