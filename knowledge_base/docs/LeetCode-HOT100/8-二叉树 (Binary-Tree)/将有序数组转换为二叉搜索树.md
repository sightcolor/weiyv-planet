# 将有序数组转换为二叉搜索树

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

---

## 题目描述

> 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。
>
> **高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1」的二叉树。
>
> **示例:**
> ```
> 输入：nums = [-10,-3,0,5,9]
> 输出：[0,-3,9,-10,null,5]
> 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案。
> ```

---

## 解题思路

### 核心思想
**分治法 + 递归 (后序遍历思路)**

要构建一棵 **高度平衡** 的 **二叉搜索树 (BST)**，最佳策略是选择升序数组的 **中点** 作为根节点。这样可以保证根节点左右两侧的节点数量大致相等，从而满足平衡要求；同时，数组的有序性也自然满足了 BST 的 `左 < 根 < 右` 的性质。

我们可以通过递归，将这个思想应用到子数组上，这正是一种分治策略。从实现上来看，它体现了 **后序遍历** 的思想：我们必须先递归地构建好左右子树，然后才能用它们来构建当前的根节点。

### 算法步骤
1.  **定义递归函数**: `build(nums, left, right)`，其功能是利用 `nums` 数组中 `[left, right)` 区间的部分，构建一棵平衡 BST，并返回其根节点。
2.  **递归基 (Base Case)**: 如果 `left >= right`，说明当前区间为空，没有节点可以构建，直接返回 `nullptr`。
3.  **递归过程 (后序遍历)**:
    *   **找到中点**: 计算当前区间的中间索引 `mid = left + (right - left) / 2`。
    *   **构建左子树 (左)**: 递归调用 `build(nums, left, mid)`，得到完全构建好的左子树的根节点。
    *   **构建右子树 (右)**: 递归调用 `build(nums, mid + 1, right)`，得到完全构建好的右子树的根节点。
    *   **构建根节点 (根)**: 使用 `nums[mid]` 的值，以及刚刚得到的左右子树根节点，创建当前子树的根 `new TreeNode(nums[mid], left_child, right_child)`，并将其返回。
4.  **初始调用**: 在主函数中，调用 `build(nums, 0, nums.size())` 来启动整个构建过程。

### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是数组中元素的数量。我们需要遍历数组中的每个元素一次，来创建对应的树节点。)*
- **空间复杂度**: O(logN)
  *(不考虑返回的树本身所占用的空间，空间复杂度主要取决于递归调用栈的深度。由于我们总是选择中点作为根，构建出的树是高度平衡的，其高度为 O(logN)，因此递归栈的深度也是 O(logN)。)*

---

## 代码实现

### C++ (分治递归法)

```cpp
#include <vector>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* sortedArrayToBST(std::vector<int>& nums) {
        // 初始调用，使用左闭右开区间 [0, nums.size())
        return build(nums, 0, nums.size());
    }

private:
    // 辅助函数，处理 [left, right) 区间的数组
    TreeNode* build(std::vector<int>& nums, int left, int right) {
        // 递归基：如果区间为空，则没有节点可构建
        if (left >= right) {
            return nullptr;
        }

        // 找到中点
        int mid = left + (right - left) / 2;
        
        // 后序遍历思想：先构建好左右子树，再构建根节点
        // C++会先求值构造函数的所有参数，再调用构造函数
        return new TreeNode(nums[mid], 
                            build(nums, left, mid),       // 递归构建左子树
                            build(nums, mid + 1, right)  // 递归构建右子树
                           );
    }
};
```