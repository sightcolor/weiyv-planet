# 验证二叉搜索树

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/validate-binary-search-tree/)

---

## 题目描述

> 给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。
>
> **有效** 二叉搜索树定义如下：
> *   节点的左子树只包含 **小于** 当前节点的数。
> *   节点的右子树只包含 **大于** 当前节点的数。
> *   所有左子树和右子树自身必须也是二叉搜索树。
>
> **示例:**
> ```
> 输入：root = [2,1,3]
> 输出：true
> ```
>
> ```
> 输入：root = [5,1,4,null,null,3,6]
> 输出：false
> 解释：根节点的值是 5 ，但是右子节点的值是 4 。
> ```

---

## 解题思路

### 思路一：中序遍历

#### 核心思想
二叉搜索树有一个非常重要的性质：它的 **中序遍历** 结果是一个 **严格递增** 的序列。利用这个性质，我们可以在中序遍历的过程中，检查当前节点的值是否大于前一个被访问的节点的值。如果整个遍历过程中这个条件都成立，那么这棵树就是一棵有效的二叉搜索树。

#### 算法步骤
1.  **初始化**: 创建一个全局或成员变量 `pre`，用于记录中序遍历中前一个节点的值，初始化为一个极小值（如 `LLONG_MIN`）。
2.  **定义递归函数 `isValidBST(node)`**:
    *   **递归基**: 如果 `node` 为空，返回 `true`。
    *   **遍历左子树**: 递归调用 `isValidBST(node->left)`。如果左子树不是 BST，立即返回 `false`。
    *   **访问根节点**:
        *   比较当前节点的值 `node->val` 和前一个节点的值 `pre`。
        *   如果 `node->val <= pre`，说明不满足严格递增，返回 `false`。
        *   更新 `pre = node->val`，为下一个节点的比较做准备。
    *   **遍历右子树**: 递归调用 `isValidBST(node->right)`，并返回其结果。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点被访问一次。)*
- **空间复杂度**: O(H)
  *(递归栈的深度，H 为树的高度。)*

---

### 思路二：前序遍历 (范围约束)

#### 核心思想
这种方法在遍历树的同时，为每个节点维护一个有效的取值范围 `(lower, upper)`。一个节点要合法，它自身的值必须在这个范围内，并且它的左右子树也要满足各自更新后的范围约束。
*   对于根节点，范围是 `(-∞, +∞)`。
*   当遍历到左子节点时，它的值必须小于其父节点的值，所以它的新范围是 `(lower, parent->val)`。
*   当遍历到右子节点时，它的值必须大于其父节点的值，所以它的新范围是 `(parent->val, upper)`。

#### 算法步骤
1.  **定义递归函数 `dfs(node, lower, upper)`**:
    *   **递归基**: 如果 `node` 为空，返回 `true`。
    *   **访问根节点**:
        *   检查 `node->val` 是否在 `(lower, upper)` 范围内。即 `node->val > lower` 且 `node->val < upper`。
        *   如果不在，立即返回 `false`。
    *   **遍历子树**:
        *   递归调用 `dfs(node->left, lower, node->val)` 检查左子树。
        *   递归调用 `dfs(node->right, node->val, upper)` 检查右子树。
        *   只有当两者都为 `true` 时，才返回 `true`。

#### 复杂度分析
- **时间复杂度**: O(N)
- **空间复杂度**: O(H)

---

### 思路三：后序遍历 (子树信息汇总)

#### 核心思想
这是一种自底向上的方法。对于每个节点，我们先递归地处理它的左右子树，然后让左右子树返回它们是否是 BST，以及它们内部的 **最小值** 和 **最大值**。
当前节点拿到这些信息后，就可以判断：
1.  左右子树本身是否是有效的 BST。
2.  当前节点的值是否大于 **左子树的最大值**。
3.  当前节点的值是否小于 **右子树的最小值**。

如果都满足，那么以当前节点为根的子树就是一棵有效的 BST。然后，它将自己的信息（有效性、子树最小值、子树最大值）返回给它的父节点。

#### 算法步骤
1.  **定义递归函数 `dfs(node)`**: 该函数返回一个 `pair`，包含 `{子树最小值, 子树最大值}`。同时使用一个全局 `bool` 变量来记录有效性。
    *   **递归基**: 如果 `node` 为空，返回一个特殊值，如 `{LLONG_MAX, LLONG_MIN}`，这样任何父节点的值都能满足 `val > l_max` 和 `val < r_min` 的条件。
    *   **遍历子树**:
        *   递归调用 `dfs(node->left)` 得到 `{l_min, l_max}`。
        *   递归调用 `dfs(node->right)` 得到 `{r_min, r_max}`。
    *   **访问根节点**:
        *   检查 `node->val > l_max` 且 `node->val < r_min`。
        *   如果不满足，将全局 `bool` 标志设为 `false`。
    *   **返回信息**: 返回以当前节点为根的子树的范围，即 `{min(l_min, node->val), max(r_max, node->val)}`。

#### 复杂度分析
- **时间复杂度**: O(N)
- **空间复杂度**: O(H)

---

## 代码实现

### C++ (思路一：中序遍历)
```cpp
class Solution {
private:
    long long pre = LLONG_MIN; // 使用 long long 防止溢出
public:
    bool isValidBST(TreeNode* root) {
        if (!root) {
            return true;
        }
        // 1. 检查左子树
        if (!isValidBST(root->left)) {
            return false;
        }
        // 2. 检查当前节点
        if (root->val <= pre) {
            return false;
        }
        pre = root->val;
        // 3. 检查右子树
        return isValidBST(root->right);
    }
};
```

### C++ (思路二：前序遍历 - 范围约束)
```C++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return dfs(root, LLONG_MIN, LLONG_MAX);
    }
private:
    bool dfs(TreeNode* root, long long lower, long long upper) {
        if (!root) {
            return true;
        }
        // 1. 检查当前节点
        if (root->val <= lower || root->val >= upper) {
            return false;
        }
        // 2. 检查左右子树
        return dfs(root->left, lower, root->val) && 
               dfs(root->right, root->val, upper);
    }
};
```

### C++ (思路三：后序遍历 - 子树信息汇总)
```C++
class Solution {
private:
    bool isValid = true;

public:
    bool isValidBST(TreeNode* root) {
        dfs(root);
        return isValid;
    }
private:
    // 返回 pair{min_val, max_val}
    std::pair<long long, long long> dfs(TreeNode* root) {
        if (!root) {
            // 空节点的范围，使其对父节点判断总为 true
            return {LLONG_MAX, LLONG_MIN};
        }

        // 1. 递归获取左右子树信息
        auto [l_min, l_max] = dfs(root->left);
        auto [r_min, r_max] = dfs(root->right);

        // 2. 判断当前节点是否满足 BST 条件
        if (root->val <= l_max || root->val >= r_min) {
            isValid = false;
        }

        // 3. 返回以当前节点为根的子树的范围
        return {std::min((long long)root->val, l_min), 
                std::max((long long)root->val, r_max)};
    }
};
```