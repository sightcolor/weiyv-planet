# 对称二叉树

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/symmetric-tree/)

---

## 题目描述

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。
>
> **示例:**
> ```
> 输入：root = [1,2,2,3,4,4,3]
> 输出：true
> ```
>
> ```
> 输入：root = [1,2,2,null,3,null,3]
> 输出：false
> ```

---

## 解题思路

### 思路一：递归法

#### 核心思想
一棵树是否是轴对称的，可以递归地定义：
1.  它的根节点 `root` 的左子树和右子树是 **镜像对称** 的。

那么，如何判断两个子树 `p` 和 `q` 是镜像对称的呢？
1.  它们的根节点值必须相等 (`p->val == q->val`)。
2.  `p` 的 **左** 子树必须和 `q` 的 **右** 子树是镜像对称的。
3.  `p` 的 **右** 子树必须和 `q` 的 **左** 子树是镜像对称的。

这个定义可以直接转换成一个递归函数。我们不需要比较一棵树和它自己，而是需要比较它的左子树和右子树。

#### 算法步骤
1.  **主函数**: `isSymmetric(root)`
    *   如果 `root` 为空，它本身就是对称的，返回 `true`。
    *   否则，调用一个辅助函数 `isMirror(root->left, root->right)` 来判断其左右子树是否镜像对称。
2.  **辅助函数**: `isMirror(p, q)`
    *   **递归基 (Base Case)**:
        *   如果 `p` 和 `q` 都为 `nullptr`，说明这对称位置都是空的，是镜像的，返回 `true`。
        *   如果 `p` 和 `q` 中只有一个为 `nullptr`，或者它们的值不相等 (`p->val != q->val`)，说明不对称，返回 `false`。
    *   **递归过程**:
        *   递归地比较 `p` 的左子树和 `q` 的右子树：`isMirror(p->left, q->right)`。
        *   递归地比较 `p` 的右子树和 `q` 的左子树：`isMirror(p->right, q->left)`。
        *   只有当以上两个都为 `true` 时，`p` 和 `q` 才是镜像对称的。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是树中节点的数量。我们需要遍历整棵树一次。)*
- **空间复杂度**: O(H)
  *(其中 H 是树的高度。空间复杂度主要取决于递归调用栈的深度。)*

---

### 思路二：迭代法 (使用队列)

#### 核心思想
我们可以使用一个队列来进行迭代判断。关键在于，我们每次从队列中取出 **两个节点** 进行比较，这两个节点应该是镜像位置上的节点。然后，我们将它们的孩子节点 **成对地、以镜像的顺序** 加入队列。

#### 算法步骤
1.  **处理边界**: 如果 `root` 为空，返回 `true`。
2.  **初始化**:
    *   创建一个队列 `queue`。
    *   将 `root->left` 和 `root->right` 作为第一对需要比较的节点入队。
3.  **迭代比较**:
    *   当队列不为空时，循环执行。
    *   从队列中 **同时取出两个节点** `p` 和 `q`。
    *   **比较 `p` 和 `q`**:
        *   如果它们都为 `nullptr`，说明这对是合法的，`continue` 继续下一轮循环。
        *   如果只有一个为 `nullptr`，或者它们的值不相等，说明不对称，立即返回 `false`。
    *   **按镜像顺序入队**:
        *   将 `p` 的左孩子和 `q` 的右孩子入队。
        *   将 `p` 的右孩子和 `q` 的左孩子入队。
4.  **返回**: 如果循环正常结束，说明所有镜像位置的节点都匹配，返回 `true`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点都会被入队和出队一次。)*
- **空间复杂度**: O(W)
  *(其中 W 是树的最大宽度。队列中最多存储一层的所有节点，最坏情况下为 O(N)。)*

---

## 代码实现

### C++ (思路一：递归法)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) {
            return true;
        }
        return isMirror(root->left, root->right);
    }
private:
    bool isMirror(TreeNode* p, TreeNode* q) {
        // 递归基：都为空，对称
        if (!p && !q) {
            return true;
        }
        // 递归基：一个为空或值不等，不对称
        if (!p || !q || p->val != q->val) {
            return false;
        }
        // 递归比较：p的左子树 vs q的右子树 AND p的右子树 vs q的左子树
        return isMirror(p->left, q->right) && isMirror(p->right, q->left);
    }
};
```
### C++ (思路二：迭代法)
```C++

#include <queue>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) {
            return true;
        }
        std::queue<TreeNode*> q;
        q.push(root->left);
        q.push(root->right);

        while (!q.empty()) {
            TreeNode* p = q.front(); q.pop();
            TreeNode* q_node = q.front(); q.pop();

            if (!p && !q_node) continue;
            if (!p || !q_node || p->val != q_node->val) return false;
            
            // 按镜像顺序将子节点入队
            q.push(p->left);
            q.push(q_node->right);
            
            q.push(p->right);
            q.push(q_node->left);
        }
        return true;
    }
};
```