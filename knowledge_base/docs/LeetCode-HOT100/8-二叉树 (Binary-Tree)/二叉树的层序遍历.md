# 二叉树的层序遍历

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

---

## 题目描述

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
>
> **示例:**
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[9,20],[15,7]]
> ```
>
> ```
> 输入：root = [1]
> 输出：[[1]]
> ```
>
> ```
> 输入：root = []
> 输出：[]
> ```

---

## 解题思路

### 思路一：广度优先搜索 (BFS)

#### 核心思想
层序遍历的本质就是广度优先搜索（BFS）。BFS 的特性是逐层向外扩展，这与层序遍历的要求完全吻合。我们使用一个 **队列 (Queue)** 作为辅助数据结构来存储待访问的节点。

关键在于如何将每一层的节点值分开放入不同的数组中。我们可以在每一层遍历开始前，记录下当前队列中的节点数量 `level_size`，这个数量就是当前层的节点总数。然后，我们循环 `level_size` 次，将这些节点逐一出队处理，并将其子节点入队。这样就保证了每一轮外层循环处理的都是同一层的节点。

#### 算法步骤
1.  **处理边界**: 如果 `root` 为 `nullptr`，返回一个空数组。
2.  **初始化**:
    *   创建一个结果数组 `vector<vector<int>> res`。
    *   创建一个队列 `queue`，并将根节点 `root` 入队。
3.  **层次遍历循环**:
    *   当队列不为空时，进入循环。
    *   **记录当前层大小**: `int level_size = queue.size();`
    *   **创建当前层结果数组**: `vector<int> current_level;`
    *   **遍历当前层**: 循环 `level_size` 次。
        *   从队列中取出一个节点 `node = queue.front(); queue.pop();`
        *   将 `node->val` 存入 `current_level`。
        *   如果 `node` 的左孩子不为空，将其入队。
        *   如果 `node` 的右孩子不为空，将其入队。
    *   内层循环结束后，`current_level` 中就包含了当前层的所有节点值，将其加入到最终结果 `res` 中。
4.  **返回**: 循环结束，返回 `res`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是树中节点的数量。每个节点都会被入队和出队一次。)*
- **空间复杂度**: O(W)
  *(其中 W 是树的最大宽度。在最坏情况下（完全二叉树），队列中可能存储约 N/2 个节点，空间复杂度为 O(N)。)*

---

### 思路二：深度优先搜索 (DFS) / 递归

#### 核心思想
虽然 BFS 是层序遍历最自然的方法，但 DFS 也可以实现。我们可以在递归时传递一个额外的参数 `level` 来表示当前节点的层级。当我们遍历到一个节点时，就将它的值加入到结果数组 `res` 中对应层级的子数组 `res[level]` 里。

#### 算法步骤
1. **定义递归函数**: `dfs(node, level)`。
2. **处理新层级**: 如果当前 `level` 等于 `res.size()`，说明我们第一次到达这一层，需要在 `res` 中创建一个新的空数组来存放该层的节点。
3. **存储节点值**: 将 `node->val` 添加到 `res[level]` 中。
4. **递归调用**: 对左右子节点进行递归调用，同时将 `level` 加 1。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点都会被访问一次。)*
- **空间复杂度**: O(H)
  *(其中 H 是树的高度。空间复杂度主要取决于递归调用栈的深度。)*

---

## 代码实现

### C++ (思路一：广度优先搜索 / BFS)

```cpp
#include <vector>
#include <queue>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    std::vector<std::vector<int>> levelOrder(TreeNode* root) {
        std::vector<std::vector<int>> res;
        if (!root) {
            return res;
        }

        std::queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            // 关键：在开始遍历一层前，记录下该层节点数
            int level_size = q.size();
            std::vector<int> current_level;
            
            // 循环 level_size 次，恰好处理完当前层所有节点
            for (int i = 0; i < level_size; ++i) {
                TreeNode* node = q.front();
                q.pop();
                current_level.push_back(node->val);

                if (node->left) {
                    q.push(node->left);
                }
                if (node->right) {
                    q.push(node->right);
                }
            }
            res.push_back(current_level);
        }
        return res;
    }
};
```
### C++ (思路二：深度优先搜索 / DFS)

```C++

#include <vector>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    std::vector<std::vector<int>> levelOrder(TreeNode* root) {
        std::vector<std::vector<int>> res;
        dfs(root, 0, res);
        return res;
    }

private:
    void dfs(TreeNode* node, int level, std::vector<std::vector<int>>& res) {
        if (!node) {
            return;
        }
        // 如果是新的一层，需要创建新的子数组
        if (level == res.size()) {
            res.push_back({});
        }
        // 将当前节点值加入对应层的数组
        res[level].push_back(node->val);

        // 递归处理左右子节点
        dfs(node->left, level + 1, res);
        dfs(node->right, level + 1, res);
    }
};
```
