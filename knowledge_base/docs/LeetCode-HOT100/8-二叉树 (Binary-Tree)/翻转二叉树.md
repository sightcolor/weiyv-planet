# 翻转二叉树

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/invert-binary-tree/)

---

## 题目描述

> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
>
> **示例:**
> ```
> 输入：root = [4,2,7,1,3,6,9]
> 输出：[4,7,2,9,6,3,1]
> ```

---

## 解题思路

### 思路一：深度优先搜索 (DFS) / 递归

#### 核心思想
这道题用递归来解决最为直观。翻转一棵树，可以分解为：
1.  先（或后）递归地翻转其左子树。
2.  再（或后）递归地翻转其右子树。
3.  最后，交换当前节点的左、右子节点指针。

这个过程可以从根节点开始，层层深入，直到叶子节点。当递归返回时，每一层的子树都已经被翻转，我们只需完成当前层的交换即可。

#### 算法步骤
1.  **递归基 (Base Case)**: 如果当前节点 `root` 为 `nullptr`，说明到达了树的末端，直接返回 `nullptr`。
2.  **递归调用 (后序遍历方式)**:
    *   `invertTree(root->left)`: 递归翻转左子树。
    *   `invertTree(root->right)`: 递归翻转右子树。
3.  **交换节点**: 此时，左右子树内部已经翻转完毕。我们交换当前 `root` 节点的左右孩子指针。
    *   `TreeNode* temp = root->left;`
    *   `root->left = root->right;`
    *   `root->right = temp;`
4.  **返回**: 返回当前已翻转的 `root` 节点。

*(注：交换操作也可以放在递归调用之前（前序遍历方式），效果是等价的。)*

#### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是树中节点的数量。每个节点都会被访问一次。)*
- **空间复杂度**: O(H)
  *(其中 H 是树的高度。空间复杂度取决于递归调用栈的深度。最坏情况下树退化为链表，为 O(N)；平衡树情况下为 O(logN)。)*

---

### 思路二：广度优先搜索 (BFS) / 迭代

#### 核心思想
我们也可以使用迭代的方式，通过层次遍历来解决。使用一个队列，逐层处理树的节点。每从队列中取出一个节点，就交换它的左右子节点，然后将它的（原始）左右子节点（如果存在）加入队列，以便后续处理。

#### 算法步骤
1.  **处理边界**: 如果 `root` 为 `nullptr`，直接返回。
2.  **初始化**: 创建一个队列 `queue`，并将根节点 `root` 入队。
3.  **层次遍历**:
    *   当队列不为空时，循环执行。
    *   从队列中取出一个节点 `curr`。
    *   **交换** `curr` 的左右子节点。
    *   如果 `curr` 的（交换后的）左子节点不为空，则将其入队。
    *   如果 `curr` 的（交换后的）右子节点不为空，则将其入队。
4.  **返回**: 循环结束后，整棵树的节点都已被翻转，返回 `root`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点都会被入队和出队一次。)*
- **空间复杂度**: O(W)
  *(其中 W 是树的最大宽度。在最坏情况下（完全二叉树），队列中可能存储约 N/2 个节点，空间复杂度为 O(N)。)*

---

## 代码实现

### C++ (思路一：深度优先搜索 / 递归)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        // 递归基
        if (!root) {
            return nullptr;
        }
        
        // 递归地翻转左右子树
        TreeNode* left_inverted = invertTree(root->left);
        TreeNode* right_inverted = invertTree(root->right);
        
        // 交换当前节点的左右孩子
        root->left = right_inverted;
        root->right = left_inverted;
        
        return root;
    }
};
```
### C++ (思路二：广度优先搜索 / 迭代)

```C++

#include <queue>
#include <algorithm> // for std::swap

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) {
            return nullptr;
        }

        std::queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            TreeNode* curr = q.front();
            q.pop();

            // 交换当前节点的左右子节点
            std::swap(curr->left, curr->right);

            // 将子节点加入队列，以便下一层处理
            if (curr->left) {
                q.push(curr->left);
            }
            if (curr->right) {
                q.push(curr->right);
            }
        }
        
        return root;
    }
};
```