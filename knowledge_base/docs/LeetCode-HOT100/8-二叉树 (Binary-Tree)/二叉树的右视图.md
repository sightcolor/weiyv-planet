# 二叉树的右视图

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/binary-tree-right-side-view/)

---

## 题目描述

> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
>
> **示例:**
> ```
> 输入: [1,2,3,null,5,null,4]
> 输出: [1,3,4]
> ```
>
> ```
> 输入: [1,null,3]
> 输出: [1,3]
> ```

---

## 解题思路

### 思路一：深度优先搜索 (DFS) - 根->右->左 遍历

#### 核心思想
虽然层序遍历（BFS）是解决此问题最直观的方法，但 DFS 也能通过一个巧妙的技巧实现。
常规的先序遍历是“根->左->右”，但如果我们将其顺序改为 **“根->右->左”**，那么对于树的每一层，我们 **最先访问到** 的节点就一定是该层的 **最右侧节点**。

我们可以利用这个特性，在 DFS 的过程中记录当前的深度 `depth`。当 `depth` 等于结果数组 `res` 的大小时，就说明我们是 **第一次** 到达这一层，而由于我们是“右先”遍历，这个节点必然是该层的最右节点。此时，我们将该节点的值加入结果数组。

#### 算法步骤
1.  **定义递归函数**: `dfs(node, depth)`。
2.  **递归基**: 如果 `node` 为空，直接返回。
3.  **处理当前节点**:
    *   检查当前深度 `depth` 是否等于结果数组 `res` 的大小。
    *   如果 `depth == res.size()`，说明这是我们第一次访问这一层，将 `node->val` 加入 `res`。
4.  **递归调用 (右先左后)**:
    *   先递归调用 `dfs(node->right, depth + 1)`。
    *   再递归调用 `dfs(node->left, depth + 1)`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是树中节点的数量。每个节点都会被访问一次。)*
- **空间复杂度**: O(H)
  *(其中 H 是树的高度。空间复杂度取决于递归调用栈的深度。)*

---

### 思路二：广度优先搜索 (BFS) - 层次遍历

#### 核心思想
这个问题的描述 “从右侧看”，天然地指向了层次遍历。我们可以使用 BFS 对树进行逐层遍历，在每一层遍历的过程中，**最后一个被访问的节点** 就是该层的最右侧节点，也就是从右边能看到的节点。

#### 算法步骤
1.  **初始化**: 创建一个结果数组 `res` 和一个队列 `queue`，并将根节点入队。
2.  **层次遍历**:
    *   当队列不为空时，循环执行。
    *   记录当前层的节点数量 `level_size`。
    *   循环 `level_size` 次，处理当前层的所有节点。
    *   在循环中，从队列取出一个节点 `node`。
    *   **关键**：判断当前节点是否是该层的最后一个节点 (例如，通过循环变量 `i == level_size - 1`)。如果是，则将其值加入 `res`。
    *   将 `node` 的非空左、右孩子依次入队。
3.  **返回**: 循环结束，返回 `res`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点都会被入队和出队一次。)*
- **空间复杂度**: O(W)
  *(其中 W 是树的最大宽度。队列中最多存储一层的所有节点。)*

---

## 代码实现

### C++ (思路一：深度优先搜索 / DFS)

```cpp
#include <vector>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    std::vector<int> res;

public:
    void dfs(TreeNode* root, int depth) {
        if (!root) {
            return;
        }
        // 当第一次到达新深度时，该节点就是最右侧节点
        if (depth == res.size()) {
            res.push_back(root->val);
        }
        // 关键：先遍历右子树，再遍历左子树
        dfs(root->right, depth + 1);
        dfs(root->left, depth + 1);
    }
    
    std::vector<int> rightSideView(TreeNode* root) {
        dfs(root, 0);
        return res;
    }
};
```
### C++ (思路二：广度优先搜索 / BFS)
```C++

#include <vector>
#include <queue>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    std::vector<int> rightSideView(TreeNode* root) {
        std::vector<int> res;
        if (!root) {
            return res;
        }
        
        std::queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            int level_size = q.size();
            for (int i = 0; i < level_size; ++i) {
                TreeNode* node = q.front();
                q.pop();

                // 如果是当前层的最后一个节点，则加入结果集
                if (i == level_size - 1) {
                    res.push_back(node->val);
                }

                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
        }
        return res;
    }
};
```