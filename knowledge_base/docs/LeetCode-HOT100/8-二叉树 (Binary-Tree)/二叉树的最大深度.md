# 二叉树的最大深度

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

---

## 题目描述

> 给定一个二叉树，找出其最大深度。
>
> 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
> **说明:** 叶子节点是指没有子节点的节点。
>
> **示例:**
> ```
> 给定二叉树 [3,9,20,null,null,15,7]，
>     3
>    / \
>   9  20
>     /  \
>    15   7
> 返回它的最大深度 3 。
> ```

---

## 解题思路

### 思路一：深度优先搜索 (DFS) / 递归

#### 核心思想
树的深度天然地具有递归结构。一个二叉树的最大深度，可以定义为：
*   如果树为空，深度为 0。
*   如果树不为空，其深度为 **左、右子树深度的较大值，再加 1** (这 1 代表根节点本身)。

这个定义可以直接转化为一个递归函数。

#### 算法步骤
1.  **定义递归函数 `maxDepth(node)`**: 该函数计算并返回以 `node` 为根的子树的最大深度。
2.  **递归基 (Base Case)**: 如果当前 `node` 为 `nullptr`，说明这是一个空树，其深度为 0，直接返回 `0`。
3.  **递归过程**:
    *   递归调用 `maxDepth(node->left)`，得到左子树的深度 `left_depth`。
    *   递归调用 `maxDepth(node->right)`，得到右子树的深度 `right_depth`。
    *   返回 `max(left_depth, right_depth) + 1`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是树中节点的总数。因为我们必须访问树中的每一个节点一次。)*
- **空间复杂度**: O(H)
  *(其中 H 是树的高度。空间复杂度主要取决于递归调用栈的深度。在最坏情况下，树退化成一个链表，高度为 N，空间复杂度为 O(N)。对于一棵平衡二树，高度为 O(logN)，空间复杂度也为 O(logN)。)*

---

### 思路二：广度优先搜索 (BFS) / 层次遍历

#### 核心思想
树的最大深度，其实就是树的 **层数**。我们可以使用广度优先搜索（BFS）来逐层遍历整个树，并记录遍历的层数。遍历完所有层后，记录的层数就是树的最大深度。

#### 算法步骤
1.  **处理边界**: 如果 `root` 为 `nullptr`，直接返回 `0`。
2.  **初始化**:
    *   创建一个队列 `queue`，并将根节点 `root` 入队。
    *   初始化深度计数器 `depth = 0`。
3.  **层次遍历**:
    *   当队列不为空时，进入循环。
    *   在每一层的开始，记录当前队列中的节点数量 `level_size`，这代表了当前层拥有的节点总数。
    *   将 `depth` 加 1。
    *   循环 `level_size` 次，将当前层的所有节点依次出队，并将其非空的左、右子节点入队。
4.  **返回**: 当外层循环结束时，`depth` 的值就是树的总层数，即最大深度。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点都会被入队和出队一次。)*
- **空间复杂度**: O(W)
  *(其中 W 是树的最大宽度。在最坏情况下（一个完美的完全二叉树），最后一层可能有约 N/2 个节点，所以空间复杂度为 O(N)。)*

---

## 代码实现

### C++ (思路一：深度优先搜索 / 递归)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        // 递归基：空树的深度为0
        if (!root) {
            return 0;
        }
        // 树的深度 = max(左子树深度, 右子树深度) + 1
        return std::max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```
### C++ (思路二：广度优先搜索 / 层次遍历)
```C++

#include <queue>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) {
            return 0;
        }

        std::queue<TreeNode*> q;
        q.push(root);
        int depth = 0;

        while (!q.empty()) {
            int level_size = q.size();
            depth++; // 进入新的一层

            // 处理当前层的所有节点
            for (int i = 0; i < level_size; ++i) {
                TreeNode* node = q.front();
                q.pop();

                if (node->left) {
                    q.push(node->left);
                }
                if (node->right) {
                    q.push(node->right);
                }
            }
        }
        return depth;
    }
};
```