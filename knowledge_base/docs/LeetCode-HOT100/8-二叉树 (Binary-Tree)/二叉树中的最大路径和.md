# 二叉树中的最大路径和

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

---

## 题目描述

> **路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。
>
> **路径和** 是路径中各节点值的总和。
>
> 给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。
>
> **示例:**
> ```
> 输入：root = [1,2,3]
> 输出：6
> 解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
> ```
>
> ```
> 输入：root = [-10,9,20,null,null,15,7]
> 输出：42
> 解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
> ```

---

## 解题思路

### 核心思想
**深度优先搜索 (DFS) / 树形 DP**

这个问题的核心难点在于，“路径”可以在任何节点“转折”，形成一个“拱形”，而不必是一条从上到下的直线。

为了解决这个问题，我们采用 **后序遍历** 的递归思想。我们定义一个递归函数 `dfs(node)`，它承担着 **双重职责**：

1.  **更新全局最大值**: 对于当前节点 `node`，计算以它为 **“转折点”** 的最大路径和。这个路径和等于 `node->val + 左子树提供的最大贡献 + 右子树提供的最大贡献`。我们用这个值来更新全局的最大路径和 `res`。

2.  **返回给父节点的值**: 当前节点 `node` 必须向它的父节点返回一个值，表示 **从 `node` 出发往下走**，能提供的 **单边最大路径和**。这个值等于 `node->val + max(左子树贡献, 右子树贡献)`。父节点只能选择走左边或者右边，不能两边都走，否则就不是一条简单路径了。

还有一个关键细节：如果子树提供的最大贡献是 **负数**，那么对于父节点来说，还不如不走这条路。因此，我们从子树获得的贡献应该是 `max(0, child_dfs_result)`。

### 算法步骤
1.  **初始化**: 创建一个全局或成员变量 `res`，用于存储找到的最大路径和，初始值为 `INT_MIN` (因为节点值可能为负)。
2.  **定义递归函数 `dfs(node)`**:
    *   **功能**: 返回从 `node` 出发向下的**单边**最大路径和，并在过程中更新全局 `res`。
    *   **递归基 (Base Case)**: 如果 `node` 为 `nullptr`，它不能提供任何贡献，返回 `0`。
3.  **递归过程 (后序遍历)**:
    *   `int left_gain = dfs(node->left);`: 递归计算左子树能提供的最大贡献。
    *   `int right_gain = dfs(node->right);`: 递归计算右子树能提供的最大贡献。
    *   **更新全局最大路径和 (处理“转折”路径)**:
        *   以当前 `node` 为转折点的路径和是 `node->val + left_gain + right_gain`。
        *   用这个值更新 `res = max(res, node->val + left_gain + right_gain);`
    *   **计算并返回单边路径和**:
        *   从当前 `node` 向下走，能提供的最大贡献是 `node->val + max(left_gain, right_gain)`。
        *   由于贡献不能是负的，所以实际返回 `max(0, node->val + max(left_gain, right_gain))`。*(您的代码将 `max(0, ...)` 融合到了 `left_gain` 和 `right_gain` 的计算中，逻辑等价且更简洁)*

4.  **初始调用**: 在主函数中，从 `root` 节点开始调用 `dfs` 函数。函数执行完毕后，全局变量 `res` 中存储的就是最终答案。

### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是树中节点的数量。我们对树进行了一次完整的深度优先遍历，每个节点仅被访问一次。)*
- **空间复杂度**: O(H)
  *(其中 H 是树的高度。空间复杂度取决于递归调用栈的深度。)*

---

## 代码实现

### C++ (后序遍历递归法)

```cpp
#include <algorithm> // for std::max
#include <climits>   // for INT_MIN

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private: 
    int res = INT_MIN;

public:
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return res;
    }

private:
    /**
     * @brief 递归函数，返回以 root 为起点的最大【单边】路径和
     * @param root 当前节点
     * @return 从 root 出发向下的最大路径和（如果为负，则为0）
     */
    int dfs(TreeNode* root) {
        if (!root) {
            return 0;
        }

        // 1. 递归计算左右子树能提供的最大贡献值
        // 如果子树贡献为负，则取 0，表示不选该子树
        int left_gain = std::max(0, dfs(root->left));
        int right_gain = std::max(0, dfs(root->right));

        // 2. 更新全局最大路径和：以当前节点为“转折点”的路径
        res = std::max(res, root->val + left_gain + right_gain);
        
        // 3. 返回给父节点的贡献值：必须是单边路径
        return root->val + std::max(left_gain, right_gain);
    }
};
```