# 二叉树的中序遍历

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

---

## 题目描述

> 给定一个二叉树的根节点 `root` ，返回 **中序遍历** 后（左 -> 根 -> 右）的节点值。
>
> **示例:**
> ```
> 输入：root = [1,null,2,3]
> 输出：[1,3,2]
> ```
>
> ```
> 输入：root = []
> 输出：[]
> ```
>
> ```
> 输入：root = [1]
> 输出：[1]
> ```

---

## 解题思路

### 思路一：递归法

#### 核心思想
递归是实现树遍历的最自然、最直观的方法。中序遍历的顺序是 **“左子树 -> 根节点 -> 右子树”**。我们可以定义一个递归函数，严格按照这个顺序执行：
1.  先对当前节点的左子树调用递归函数。
2.  然后访问当前节点自身（将其值存入结果数组）。
3.  最后对当前节点的右子树调用递归函数。

#### 算法步骤
1.  **定义递归函数**: `dfs(TreeNode* node)`。
2.  **递归基 (Base Case)**: 如果当前 `node` 为 `nullptr`，说明已经到达叶子节点的子节点，直接返回。
3.  **递归过程**:
    *   `dfs(node->left)`: 递归进入左子树。
    *   `res.push_back(node->val)`: 访问根节点。
    *   `dfs(node->right)`: 递归进入右子树。
4.  **初始调用**: 在主函数中，从 `root` 节点开始调用 `dfs`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是树中节点的数量。每个节点都会被访问一次。)*
- **空间复杂度**: O(N)
  *(空间复杂度主要取决于递归调用栈的深度。在最坏情况下，树退化成一个链表，递归深度为 N。对于一棵平衡二树，深度为 O(logN)。)*

---

### 思路二：迭代法 (使用栈)

#### 核心思想
迭代法的核心是使用一个 **栈 (Stack)** 来模拟递归的过程。中序遍历的特点是，要先处理完一个节点的所有左子树，才能处理该节点。
我们可以利用栈来“暂存”我们路径上遇到的节点，遵循以下逻辑：
1.  一路向左，将遇到的所有节点都压入栈中。
2.  当无法再向左走时，从栈中弹出一个节点。这个节点就是当前需要访问的“根节点”。
3.  访问完该节点后，转向其右子树，重复步骤1。

#### 算法步骤
1.  **初始化**: 创建一个结果数组 `res` 和一个空栈 `stk`。
2.  **循环**: 当 `root` 指针不为空或栈不为空时，继续循环。这个条件保证了能处理完所有节点。
3.  **深入左子树**:
    *   内层循环：只要 `root` 不为空，就将 `root` 压入栈中，然后令 `root = root->left`。这个过程会一直把当前节点及其所有左孩子压栈。
4.  **访问并转向右子树**:
    *   当内层循环结束，说明已经走到了最左边。从栈顶弹出一个节点，这个节点就是当前应该访问的节点。将其值存入 `res`。
    *   然后，将 `root` 指针指向弹出节点的右孩子 (`root = popped_node->right`)，准备处理右子树。
5.  **返回**: 循环结束后，返回 `res`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点都会被入栈和出栈一次，所以总时间复杂度是线性的。)*
- **空间复杂度**: O(N)
  *(在最坏情况下（树退化成链表），栈中会存储 N 个节点。对于平衡树，空间复杂度为 O(logN)。)*

---

## 代码实现

### C++ (思路一：递归法)

```cpp
#include <vector>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    std::vector<int> res;
    void dfs(TreeNode* root) {
        // 递归基
        if (!root) {
            return;
        }
        // 严格按照 左 -> 根 -> 右 的顺序
        dfs(root->left);
        res.push_back(root->val);
        dfs(root->right);
    }
public:
    std::vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }
};
```

### C++ (思路二：迭代法)
```C++
#include <vector>
#include <stack>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    std::vector<int> inorderTraversal(TreeNode* root) {
        std::vector<int> res;
        std::stack<TreeNode*> stk;
        
        while (root != nullptr || !stk.empty()) {
            // 1. 一路向左，将路径上的节点全部入栈
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            
            // 2. 左边到头，弹出栈顶节点并访问
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            
            // 3. 转向右子树，准备对右子树重复以上过程
            root = root->right;
        }
        return res;
    }
};
```