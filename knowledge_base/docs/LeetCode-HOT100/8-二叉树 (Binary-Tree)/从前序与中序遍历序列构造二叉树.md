# 从前序与中序遍历序列构造二叉树

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

---

## 题目描述

> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的 **先序遍历** ， `inorder` 是同一棵树的 **中序遍历** ，请构造二叉树并返回其根节点。
>
> **示例:**
> ```
> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
> 输出: [3,9,20,null,null,15,7]
> ```

---

## 解题思路

### 核心思想
**分治法 + 哈希表优化**

这道题的突破口在于深刻理解两种遍历序列的特性：

1.  **前序遍历 (Pre-order)**: `[ 根节点, [左子树的前序遍历], [右子树的前序遍历] ]`
    *   **关键特性**: 任何子树的前序遍历序列中，**第一个元素** 永远是该子树的 **根节点**。

2.  **中序遍历 (In-order)**: `[ [左子树的中序遍历], 根节点, [右子树的中序遍历] ]`
    *   **关键特性**: **根节点** 会将中序遍历序列完美地 **分割** 成两部分：左边是其所有左子树的节点，右边是其所有右子树的节点。

结合这两点，我们可以设计一个递归的 **分治** 算法：
1.  从 `preorder` 序列中取出第一个元素，它就是当前要构建的树（或子树）的根节点。
2.  在 `inorder` 序列中找到这个根节点的值。
3.  根据该值在 `inorder` 中的位置，我们可以确定其左、右子树分别包含哪些节点。同时，我们也能计算出左子树的节点数量。
4.  利用左子树的节点数量，我们可以在 `preorder` 序列中确定左、右子树对应的子序列范围。
5.  递归地对左、右子序列重复以上过程，分别构建出左右子树，然后连接到根节点上。

为了快速在 `inorder` 序列中找到根节点的位置，我们可以预先用一个 **哈希表** 存储 `(值, 索引)` 的映射，将 O(N) 的查找操作优化为 O(1)。

### 算法步骤
1.  **预处理**: 创建一个哈希表 `mp`，存储 `inorder` 数组中每个元素的值到其索引的映射。
2.  **定义递归函数 `dfs(pre_range, in_range)`**:
    *   该函数接收前序和中序遍历的当前处理范围（例如，用 `std::pair` 或四个索引表示）。
    *   **递归基 (Base Case)**: 如果范围为空（例如，`pre_left >= pre_right`），说明没有节点需要构建，返回 `nullptr`。
3.  **递归过程 (后序构建思想)**:
    *   **找到根**: `preorder` 范围的第一个元素 `root_val = preorder[pre_left]` 就是当前子树的根。
    *   **分割中序**: 使用哈希表找到 `root_val` 在 `inorder` 中的索引 `in_root_idx`。
    *   **计算左子树大小**: `left_size = in_root_idx - in_left`。
    *   **构建左子树 (左)**: 递归调用 `dfs`，传入左子树对应的前序范围 `[pre_left + 1, pre_left + 1 + left_size)` 和中序范围 `[in_left, in_root_idx)`。
    *   **构建右子树 (右)**: 递归调用 `dfs`，传入右子树对应的前序范围 `[pre_left + 1 + left_size, pre_right)` 和中序范围 `[in_root_idx + 1, in_right)`。
    *   **构建根节点 (根)**: 创建根节点 `new TreeNode(root_val, left_child, right_child)`，将已构建好的左右子树连接起来，并返回。
4.  **初始调用**: 在主函数中，传入完整的 `preorder` 和 `inorder` 范围来启动递归。

### 复杂度分析
- **时间复杂度**: O(N)
  *(哈希表的构建需要 O(N) 时间。递归构建过程中，每个节点只被访问一次，哈希表查找为 O(1)，因此总时间为 O(N)。)*
- **空间复杂度**: O(N)
  *(哈希表需要 O(N) 的空间。递归调用栈的深度在最坏情况下（链状树）也为 O(N)。)*

---

## 代码实现

### C++ (分治递归法)

```cpp
#include <vector>
#include <unordered_map>

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    std::vector<int> preorder;
    // 使用哈希表优化中序遍历的查找
    std::unordered_map<int, int> inorder_map;

public:
    TreeNode* buildTree(std::vector<int>& preorder, std::vector<int>& inorder) {
        this->preorder = preorder;
        // 1. 预处理：构建中序遍历的哈希映射
        for(int i = 0; i < inorder.size(); ++i) {
            inorder_map[inorder[i]] = i;
        }
        // 初始调用，传入完整的范围
        return build(0, preorder.size(), 0, inorder.size());
    }

private:
    // 递归函数，处理左闭右开区间
    TreeNode* build(int pre_left, int pre_right, int in_left, int in_right) {
        // 递归基：范围为空
        if (pre_left >= pre_right) {
            return nullptr;
        }

        // 2. 找到根节点的值
        int root_val = preorder[pre_left];
        
        // 3. 在中序遍历中找到根节点位置，以分割左右子树
        int in_root_idx = inorder_map[root_val];
        
        // 4. 计算左子树的大小
        int left_subtree_size = in_root_idx - in_left;
        
        // 后序构建思想：先递归构建左右子树，再创建根节点
        return new TreeNode(root_val, 
                            // 5. 递归构建左子树
                            build(pre_left + 1, pre_left + 1 + left_subtree_size, in_left, in_root_idx),
                            // 6. 递归构建右子树
                            build(pre_left + 1 + left_subtree_size, pre_right, in_root_idx + 1, in_right)
                           );
    }
};
```