# 二叉树的直径

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/diameter-of-binary-tree/)

---

## 题目描述

> 给定一棵二叉树，你需要计算它的直径长度。
>
> 一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径**可能穿过也可能不穿过**根结点。
>
> **注意：** 两结点之间的路径长度是以它们之间边的数目表示。
>
> **示例:**
> ```
> 给定二叉树
>
>           1
>          / \
>         2   3
>        / \     
>       4   5    
>
> 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
> ```

---

## 解题思路

### 核心思想
**深度优先搜索 (DFS) + 后序遍历**

这道题的关键在于理解“直径”的定义。二叉树的直径是树中任意两个节点之间最长路径的长度。这条最长路径有一个重要的特性：它必然是某个节点的 **左子树深度** 与 **右子树深度** 之和。

但是，这条路径 **不一定** 经过整棵树的根节点 `root`。它可能完全包含在左子树中，也可能完全包含在右子树中，或者穿过 `root` 节点。

因此，我们需要遍历树中的 **每一个节点**，并以该节点为“根”（或路径的转折点），计算穿过它的最长路径（即 `左子树深度 + 右子树深度`），然后从所有这些路径中取一个最大值。

这个过程可以通过一次 **后序遍历**（左 -> 右 -> 根）巧妙地完成。我们定义一个递归函数，它具有双重任务：
1.  **返回值**: 计算并返回以当前节点为根的 **子树深度**。
2.  **副作用**: 在计算深度的过程中，顺便计算穿过当前节点的直径，并更新一个全局变量来记录遇到的最大直径。

### 算法步骤
1.  **初始化**: 创建一个全局变量 `res`（或成员变量）来存储找到的最大直径，初始值为 0。
2.  **定义递归函数 `depth(node)`**:
    *   **递归基 (Base Case)**: 如果当前 `node` 为 `nullptr`，说明到达叶子节点的子节点，其深度为 0，返回 0。
3.  **递归过程 (后序遍历)**:
    *   `int l = depth(node->left);`: 递归计算左子树的深度。
    *   `int r = depth(node->right);`: 递归计算右子树的深度。
    *   **更新最大直径**: 在处理完左右子树后，我们得到了它们的深度 `l` 和 `r`。穿过当前 `node` 的路径长度就是 `l + r`。我们用它来更新全局最大值：`res = max(res, l + r);`
    *   **返回当前子树深度**: 此函数的返回值是为它的父节点服务的。以 `node` 为根的子树的深度是 `max(l, r) + 1`。将其返回。
4.  **初始调用**: 在主函数中，从 `root` 节点开始调用 `depth` 函数。函数执行完毕后，全局变量 `res` 中存储的就是最终答案。

### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是树中节点的数量。我们对树进行了一次完整的深度优先遍历，每个节点仅被访问一次。)*
- **空间复杂度**: O(H)
  *(其中 H 是树的高度。空间复杂度取决于递归调用栈的深度。最坏情况下树退化为链表，为 O(N)；平衡树情况下为 O(logN)。)*

---

## 代码实现

### C++ (后序遍历递归法)

```cpp
#include <algorithm> // for std::max

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int maxDiameter = 0; // 用于记录全局最大直径

public:
    int diameterOfBinaryTree(TreeNode* root) {
        calculateDepth(root);
        return maxDiameter;
    }

private:
    // 该函数返回以node为根的子树的深度，并在此过程中更新maxDiameter
    int calculateDepth(TreeNode* node) {
        // 递归基：空节点的深度为0
        if (!node) {
            return 0;
        }

        // 递归计算左右子树的深度
        int leftDepth = calculateDepth(node->left);
        int rightDepth = calculateDepth(node->right);

        // 更新全局最大直径：穿过当前节点的路径长度为 leftDepth + rightDepth
        maxDiameter = std::max(maxDiameter, leftDepth + rightDepth);

        // 返回当前节点的深度，供上层节点使用
        return std::max(leftDepth, rightDepth) + 1;
    }
};
```