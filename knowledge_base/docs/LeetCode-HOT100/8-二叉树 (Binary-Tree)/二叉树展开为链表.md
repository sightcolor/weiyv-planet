# 二叉树展开为链表

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

---

## 题目描述

> 给你二叉树的根结点 `root` ，请你将它展开为一个单链表：
>
> *   展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
> *   展开后的单链表应该与二叉树的 **先序遍历** 顺序相同。
>
> **示例:**
> ```
> 输入：root = [1,2,5,3,4,null,6]
> 输出：[1,null,2,null,3,null,4,null,5,null,6]
> ```

---

## 解题思路

### 核心思想
**按前序遍历顺序重新连接节点**

题目的核心要求是将树的结构改变为前序遍历 (`根 -> 左 -> 右`) 顺序的单链表。无论是哪种解法，都围绕着如何高效、正确地实现节点间的重新链接。你的两种解法分别代表了两种非常经典的树形问题处理思路：**迭代思想的递归实现** 和 **分治思想**。

### 思路一：逆后序遍历 (寻找前驱)

这个思路非常巧妙，它通过逆转前序遍历的顺序 (`右 -> 左 -> 根`)，从后往前地构建链表，可以看作是一种**头插法**的递归实现。

#### 算法步骤
1.  **定义遍历顺序**: 采用 `右 -> 左 -> 根` 的递归顺序。
2.  **递归到底**: 首先递归处理右子树，然后递归处理左子树。
3.  **处理当前节点**: 当一个节点的左右子树都处理完毕后，我们开始处理该节点本身。
    *   此时，我们利用一个全局（或成员）指针 `prev`，它始终指向**已经处理好的链表的头节点**。
    *   将当前 `root` 节点的 `right` 指针指向 `prev`。
    *   将当前 `root` 节点的 `left` 指针设为 `nullptr`。
    *   更新 `prev` 为当前 `root` 节点，因为它成了新链表的头。
4.  **返回**: 递归返回后，整棵树就被拉平了。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点只被访问一次。)*
- **空间复杂度**: O(H)
  *(递归栈的深度，H是树的高度。)*

---

### 思路二：分治法 (后序遍历)

这个思路遵循经典的分治策略：假设子问题已经解决，然后考虑如何合并子问题的结果来解决当前问题。

#### 算法步骤
1.  **定义子问题**: 设计一个递归函数 `dfs(root)`，它的功能是：将以 `root` 为根的子树拉平，并**返回拉平后链表的尾节点**。
2.  **分解 (Divide)**:
    *   递归调用 `dfs(root->left)`，得到左子树拉平后的尾节点 `l_tail`。
    *   递归调用 `dfs(root->right)`，得到右子树拉平后的尾节点 `r_tail`。
3.  **合并 (Conquer)**:
    *   这是核心步骤。此时左右子树已经分别是两条链表了。我们需要将 `root`、左链表、右链表拼接起来。
    *   拼接顺序为: `root -> 左链表 -> 右链表`。
    *   如果左链表存在 (`l_tail != nullptr`):
        *   将左链表的尾巴 (`l_tail`) 的 `right` 指针指向右链表的头 (`root->right`)。
        *   将 `root` 的 `right` 指针指向左链表的头 (`root->left`)。
        *   将 `root` 的 `left` 指针设为 `nullptr`。
4.  **返回结果**:
    *   返回合并后**整个新链表的尾节点**。
    *   如果右子树存在，尾节点就是 `r_tail`。
    *   如果右子树不存在但左子树存在，尾节点就是 `l_tail`。
    *   如果左右子树都不存在，尾节点就是 `root` 本身。

#### 复杂度分析
- **时间复杂度**: O(N)
- **空间复杂度**: O(H)

---

## 代码实现

### C++ (思路一：逆后序遍历)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    TreeNode* prev = nullptr;
public:
    void flatten(TreeNode* root) {
        // 逆向前序遍历 右-左-根
        // 这样保证后面状态不影响前面
        // 也就是头插法
        if(!root)
            return ;
        flatten(root->right);
        flatten(root->left);
        // 处理当前节点
        root->right = prev;
        root->left = nullptr;
        prev = root;
    }
};
```
### C++ (思路二：分治法)
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 辅助函数：将 root 为根的树拉平，并返回拉平后链表的“尾节点”
    TreeNode* dfs(TreeNode* root) {
        if(!root)
            return nullptr;
        
        // 分解：递归处理左右子树
        TreeNode* l_tail = dfs(root->left);
        TreeNode* r_tail = dfs(root->right);
        
        // 合并：将 root, 左链表, 右链表拼接
        if(l_tail) {
            l_tail->right = root->right;
            root->right = root->left;
            root->left = nullptr;
        }

        // 返回新链表的尾节点
        if (r_tail != nullptr) {
            return r_tail;
        }
        if (l_tail != nullptr) {
            return l_tail;
        }
        return root;
    }

    void flatten(TreeNode* root) {
        dfs(root);
    }
};
```