# 跳跃游戏 II

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/jump-game-ii/)

---

## 题目描述

> 给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。
>
> 每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:
> -   `0 <= j <= nums[i]`
> -   `i + j < n`
>
> 返回到达 `nums[n - 1]` 的最小跳跃次数。生成的数据保证总是可以到达 `nums[n - 1]`。
>
> **示例:**
> ```
> 输入: nums = [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>      从下标 0 跳到下标 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
> ```
>
> ```
> 输入: nums = [2,3,0,1,4]
> 输出: 2
> ```

---

## 解题思路

### 核心思想
**贪心算法 (Greedy) — "造桥"思想**

这个问题要求最少的跳跃次数，可以看作是一个广度优先搜索（BFS）问题，每一跳都代表 BFS 的一层。但使用纯粹的 BFS 会导致超时，因此我们需要一种更高效的贪心策略。

我们可以把问题想象成“过河”，目标是用最少的“桥”到达对岸（数组末尾）。
- 我们站在 `i = 0` 的位置，这是我们的**第一座桥**。这座桥的覆盖范围是 `[0, nums[0]]`。
- 我们需要在这座桥的覆盖范围内，寻找一个起跳点，来搭建**下一座桥**。为了让下一座桥尽可能地延伸，我们应该选择一个能跳得最远的起跳点。
- 贪心策略就体现在这里：在当前桥的覆盖范围内，我们遍历所有可以起跳的位置，并实时更新**下一座桥能到达的最远距离**。

**变量定义**:
-   `res` (或 `steps`): 跳跃次数，即我们已经“搭建”了多少座桥。
-   `curr_right`: **当前**这一跳（这座桥）所能覆盖的最远边界。
-   `next_right`: 在当前桥的覆盖范围内，我们能找到的、**下一跳**（下一座桥）所能覆盖的最远边界。

### 算法步骤
1.  **初始化**:
    *   `res = 0` (跳跃次数)。
    *   `curr_right = 0` (当前能到达的最远位置，初始在起点)。
    *   `next_right = 0` (下一步能到达的最远位置)。
2.  **遍历数组**: 我们 `for` 循环遍历数组，但**不需要到达最后一个元素**，因为我们的目标是在到达终点**之前**完成最后一次跳跃。所以循环条件是 `for (int i = 0; i < nums.size() - 1; i++)`。
    *   **更新下一跳的最远边界**: 在当前位置 `i`，我们可以跳到 `i + nums[i]`。我们用这个值来更新 `next_right`：
        `next_right = max(next_right, i + nums[i])`。
    *   **判断是否需要跳跃**: 当我们的遍历指针 `i` 到达了当前这一跳的最远边界 `curr_right` 时，意味着我们必须做出一次跳跃了。
        *   `if (i == curr_right)`:
            *   跳跃次数 `res` 加 1。
            *   更新当前的最远边界为我们之前计算好的 `next_right`：`curr_right = next_right`。
            *   （可选优化）如果此时 `curr_right` 已经覆盖了终点，可以提前 `break`。
3.  **返回结果**: 循环结束后，`res` 就是到达终点的最小跳跃次数。

### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是 `nums` 数组的长度。我们只需要遍历一次数组。)*
- **空间复杂度**: O(1)
  *(只需要常数级别的额外空间来存储 `res`, `curr_right`, `next_right`。)*

---

## 代码实现

### C++ (贪心算法 - 您的实现)
*(该实现逻辑清晰，通过两个边界变量巧妙地模拟了层次遍历（BFS）的思想，是此问题的最优解。)*
```cpp
#include <vector>
#include <algorithm> // for std::max

class Solution {
public:
    int jump(std::vector<int>& nums) {
        int n = nums.size();
        if (n <= 1) {
            return 0;
        }

        int steps = 0;           // 跳跃次数
        int current_reach = 0;   // 当前这一跳能到达的最远位置
        int next_reach = 0;      // 在当前覆盖范围内，下一步能到达的最远位置

        // 遍历到倒数第二个元素即可
        for (int i = 0; i < n - 1; ++i) {
            // 更新下一步能到达的最远距离
            next_reach = std::max(next_reach, i + nums[i]);

            // 到达了当前跳跃的边界，必须进行下一次跳跃
            if (i == current_reach) {
                steps++;
                current_reach = next_reach; // 更新当前边界为下一跳的边界
                
                // 优化：如果下一跳已经可以覆盖终点，提前结束
                if (current_reach >= n - 1) {
                    break;
                }
            }
        }
        return steps;
    }
};
```