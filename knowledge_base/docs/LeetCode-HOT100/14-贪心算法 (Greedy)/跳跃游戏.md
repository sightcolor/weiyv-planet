# 跳跃游戏

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/jump-game/)

---

## 题目描述

> 给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个下标。
>
> **示例:**
> ```
> 输入：nums = [2,3,1,1,4]
> 输出：true
> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
> ```
>
> ```
> 输入：nums = [3,2,1,0,4]
> 输出：false
> 解释：无论怎样，总会到达下标 3 。但该下标的最大跳跃长度为 0 ， 所以永远不可能到达最后一个下标。
> ```

---

## 解题思路

### 核心思想
**贪心算法 (Greedy) — 维护最远可达距离**

这个问题的目标是判断是否“可达”最后一个位置，而不是找到具体的路径或最少的步数。这提示我们可以使用贪心策略。

我们的核心思路是：在遍历数组的过程中，实时地维护一个变量 `farthest`，表示从起点出发，**目前能够到达的最远位置的索引**。

**算法逻辑**:
- 我们从左到右遍历数组。对于当前位置 `i`，我们必须首先确保 `i` 本身是**可达**的。也就是说，`i` 必须小于或等于 `farthest`。如果 `i > farthest`，说明我们连当前位置都到不了，更不用说终点了，可以直接判断为失败。
- 如果当前位置 `i` 是可达的，那么从 `i` 出发，我们最远可以跳到 `i + nums[i]`。我们就用这个新的可达距离来更新我们的全局最远可达距离：`farthest = max(farthest, i + nums[i])`。
- 我们不断地重复这个过程，一边前进，一边拓展我们的“可达边界”。
- 如果在遍历过程中，`farthest` 已经大于或等于数组的最后一个索引 `n-1`，那么我们就已经成功了，可以直接返回 `true`。
- 如果循环正常结束（意味着我们遍历了所有可达的位置），我们最后再检查一次 `farthest` 是否足以覆盖终点。

### 算法步骤 (优化版)
1.  **初始化**:
    *   `farthest = 0`: 初始时，我们最远只能到达索引 0。
    *   `n = nums.size()`。
2.  **遍历数组**: `for` 循环 `i` 从 `0` 到 `n-1`。
    *   **可达性检查**: 首先判断 `if (i <= farthest)`。只有在当前位置 `i` 可达的前提下，才进行更新。
        *   **更新最远距离**: `farthest = max(farthest, i + nums[i])`。
        *   **提前成功判断**: `if (farthest >= n - 1)`，可以直接返回 `true`。
    *   **不可达情况**: 如果 `i > farthest`，说明我们被“卡住”了，永远到不了 `i`，也到不了终点，可以直接返回 `false`。
3.  **最终返回**: 如果循环能正常结束，说明在 `farthest` 范围内没有被卡住，此时 `farthest >= n - 1` 一定成立，返回 `true`。 (实际上，由于有提前成功判断，循环正常结束本身就意味着成功)。

*(注：你的代码 `for(int i = 0; i <= min(n - 1, constraint); i++)` 的思路，本质上就是融合了可达性检查，因为循环只在可达范围内进行。简化后的 `for (int i=0; ...)` 循环加上 `if (i <= farthest)` 的判断，在逻辑上是等价的，但更易于理解。)*

### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是 `nums` 数组的长度。我们只需要遍历一次数组。)*
- **空间复杂度**: O(1)
  *(只需要常数级别的额外空间来存储 `farthest` 变量。)*

---

## 代码实现

### C++ (贪心算法 )
*(该实现通过维护一个最远可达边界 `constraint`，高效地解决了问题。)*
```cpp
#include <vector>
#include <algorithm> // for std::max

class Solution {
public:
    bool canJump(std::vector<int>& nums) {
        int n = nums.size();
        // farthest 记录从起点出发，目前能到达的最远索引
        int farthest = 0;

        // 遍历数组的每一个位置
        for (int i = 0; i < n; ++i) {
            // 如果当前位置 i 超过了我们能到达的最远距离，
            // 那么 i 以及之后的所有位置都无法到达
            if (i > farthest) {
                return false;
            }

            // 更新从起点出发能到达的最远距离
            farthest = std::max(farthest, i + nums[i]);

            // 优化：如果最远距离已经覆盖了终点，可以提前返回
            if (farthest >= n - 1) {
                return true;
            }
        }

        // 如果循环能走完，说明终点一定可达
        return true;
    }
};
```