# 买卖股票的最佳时机

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

---

## 题目描述

> 给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。
>
> 你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。
>
> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。
>
> **示例:**
> ```
> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
> ```
>
> ```
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
> ```

---

## 解题思路

### 核心思想
**一次遍历 — 动态维护最低价格和最大利润**

这个问题的目标是找到一个最大的差值 `prices[j] - prices[i]`，其中 `j > i`。

一个暴力的方法是使用两层循环，枚举所有的买入日 `i` 和卖出日 `j`，但这会导致 O(N^2) 的时间复杂度，效率低下。

更优化的方法是只进行**一次遍历**。当我们遍历到第 `i` 天时，我们可以思考一个问题：**如果在今天（第 `i` 天）卖出股票，能获得的最大利润是多少？**

答案是：`prices[i] - (前 i-1 天的最低价格)`。

因此，我们的算法可以简化为：
1.  遍历 `prices` 数组。
2.  在遍历过程中，用一个变量 `min_price` 实时记录**到当前天为止**所遇到的历史最低价格。
3.  对于每一天 `i`，我们计算 `prices[i] - min_price`，这就是在今天卖出可能获得的最大利润。
4.  用另一个变量 `max_profit` 来维护这个“可能的最大利润”的最大值。

通过这种方式，我们只需遍历一次数组，就能找到全局的最大利润。

### 算法步骤
1.  **初始化**:
    *   初始化 `min_price` 为第一天的价格 `prices[0]`（或者一个极大值如 `INT_MAX`）。
    *   初始化 `max_profit` 为 `0`。
2.  **遍历数组**: 从第二天（索引 `i = 1`）开始遍历 `prices` 数组。
    *   **计算当前利润**: 计算 `current_profit = prices[i] - min_price`。
    *   **更新最大利润**: `max_profit = max(max_profit, current_profit)`。
    *   **更新最低价格**: `min_price = min(min_price, prices[i])`，为未来的计算做准备。
3.  **返回结果**: 遍历结束后，返回 `max_profit`。

**注意**: 更新最大利润和更新最低价格的顺序很重要。在你的实现中，先用**之前**的最低价计算利润，再更新**当天**的最低价，这个顺序是完全正确的。

### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是 `prices` 数组的长度。我们只需要遍历一次数组。)*
- **空间复杂度**: O(1)
  *(只需要常数级别的额外空间来存储 `min_price` 和 `max_profit`。)*

---

## 代码实现

### C++ (一次遍历)
*(该实现逻辑清晰，通过一次遍历高效地解决了问题。)*
```cpp
#include <vector>
#include <algorithm> // for std::min, std::max
#include <climits>   // for INT_MAX

class Solution {
public:
    int maxProfit(std::vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }

        int max_profit = 0;
        // min_price 记录 [0...i-1] 天的最低价格
        int min_price = prices[0]; 
        
        // 从第二天开始遍历
        for (int i = 1; i < prices.size(); ++i) {
            // 1. 计算如果在今天卖出，能获得的最大利润
            max_profit = std::max(max_profit, prices[i] - min_price);
            
            // 2. 更新到今天为止的历史最低价格，供明天使用
            min_price = std::min(min_price, prices[i]);
        }
        
        return max_profit;
    }
};
```