# 划分字母区间

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/partition-labels/)

---

## 题目描述

> 给你一个字符串 `s`。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。
>
> 返回一个表示每个字符串片段的长度的列表。
>
> **示例:**
> ```
> 输入：s = "ababcbacadefegdehijhklij"
> 输出：[9,7,8]
> 解释：
> 划分结果为 "ababcbaca", "defegde", "hijhklij"。
> 每个字母最多出现在一个片段中。
> 像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。
> ```

---

## 解题思路

### 核心思想
**贪心算法 + 区间合并**

题目的核心要求是“同一字母最多出现在一个片段中”。这意味着，对于任何一个片段，其中出现的所有字母，都**不能**出现在字符串的其他片段中。

这启发我们思考：一个片段的**边界**是如何确定的？
- 假设我们正在确定第一个片段。它从 `s[0]` 开始。这个片段必须包含 `s[0]` 这个字母在字符串中**所有**出现的位置。因此，这个片段的右边界**至少**要延伸到 `s[0]` 最后一次出现的位置。
- 在这个初步的区间 `[0, last_occurrence_of_s[0]]` 内，可能又出现了新的字母。为了满足题意，这个片段的右边界又必须**至少**延伸到这些新字母最后一次出现的位置。
- 这个过程不断进行，直到我们确定的右边界 `end` 之后，再也没有区间内的字母出现在 `end` 的右边。此时，`[start, end]` 就是一个合法的、最短的片段。

这正是一个**贪心**策略：我们希望每个片段尽可能短，这样总的片段数才能尽可能多。我们为每个片段找到一个“不得不”延伸到的最远右边界。

### 算法步骤
1.  **预处理：统计最后出现位置**:
    *   创建一个哈希表 `last_occurrence` (或大小为 26 的数组)，用来存储每个字母在字符串 `s` 中最后一次出现的索引。
    *   遍历一次字符串 `s` 来填充这个哈希表。
2.  **遍历与划分**:
    *   使用两个指针 `start` 和 `end` 来标记当前正在处理的片段的边界。初始时，`start = 0`。
    *   用一个 `for` 循环遍历字符串，指针为 `i`。
    *   在遍历过程中，`end` 始终被更新为当前片段内所有字母的最远出现位置。
        `end = max(end, last_occurrence[s[i]])`
    *   **找到分割点**: 当遍历指针 `i` 恰好等于 `end` 时，说明我们找到了一个片段的末尾。这个片段 `[start, end]` 包含了它内部所有字母的全部出现，且是满足此条件的最短片段。
        *   计算该片段的长度 `end - start + 1`，并存入结果列表。
        *   更新下一个片段的起始位置 `start = end + 1`。
3.  **返回结果**: 遍历结束后，返回结果列表。

### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是字符串 `s` 的长度。我们需要遍历一次字符串来统计最后出现位置，再遍历一次来进行划分。)*
- **空间复杂度**: O(Σ)
  *(其中 Σ 是字符集的大小，对于小写英文字母是 26。哈希表或数组需要常数级别的额外空间。)*

---

## 代码实现

### C++ (贪心算法)
*(您的实现通过 `while` 循环和内部 `for` 循环来确定每个片段的边界，逻辑清晰。下面的版本是另一种等价的、更常见的单 `for` 循环写法，但核心思想完全相同。)*
```cpp
#include <vector>
#include <string>
#include <unordered_map>
#include <algorithm> // for std::max

class Solution {
public:
    std::vector<int> partitionLabels(std::string s) {
        // 1. 预处理：统计每个字符的最后出现位置
        std::unordered_map<char, int> last_occurrence;
        for (int i = 0; i < s.length(); ++i) {
            last_occurrence[s[i]] = i;
        }

        std::vector<int> result;
        int start = 0; // 当前片段的起始位置
        int end = 0;   // 当前片段需要延伸到的最远右边界

        // 2. 遍历字符串进行划分
        for (int i = 0; i < s.length(); ++i) {
            // 更新当前片段的最远边界
            end = std::max(end, last_occurrence[s[i]]);
            
            // 如果 i 已经到达了当前片段的最远边界，说明一个片段结束了
            if (i == end) {
                result.push_back(end - start + 1);
                // 更新下一个片段的起始位置
                start = end + 1;
            }
        }
        
        return result;
    }
};
```