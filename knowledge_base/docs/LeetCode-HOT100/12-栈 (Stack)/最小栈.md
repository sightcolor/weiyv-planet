# 最小栈

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/min-stack/)

---

## 题目描述

> 设计一个支持 `push` ，`pop` ，`top` 和 `getMin` 操作的栈。
>
> 实现 `MinStack` 类:
> *   `MinStack()` 初始化堆栈对象。
> *   `void push(int val)` 将元素 `val` 推入堆栈。
> *   `void pop()` 删除堆栈顶部的元素。
> *   `int top()` 获取堆栈顶部的元素。
> *   `int getMin()` 获取堆栈中的最小元素。
>
> **要求**: `push`、`pop`、`top` 和 `getMin` 方法的时间复杂度都为 **O(1)**。
>
> **示例:**
> ```
> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.getMin();   // 返回 -3.
> minStack.pop();
> minStack.top();      // 返回 0.
> minStack.getMin();   // 返回 -2.
> ```

---

## 解题思路

### 核心思想
**辅助栈 (或在主栈中存储额外信息)**

这个问题的难点在于，`getMin` 操作也必须是 O(1) 的。如果我们只用一个普通的栈，每次 `getMin` 都需要遍历整个栈来找到最小值，时间复杂度是 O(N)，不符合要求。

为了实现 O(1) 的 `getMin`，我们必须在数据入栈时，就用某种方式**记录下当前的最小值状态**。当数据出栈时，也能同步地恢复到之前的最小值状态。

一个非常优雅的解决方案是，不只存储元素本身，而是将**元素值**和**到当前元素为止的最小值**（即前缀最小值）绑定在一起存储。

### 实现方案：存储 `pair`
我们可以使用一个 `stack<pair<int, int>>`：
-   `pair.first`: 存储元素本身的值 `val`。
-   `pair.second`: 存储当 `val` 入栈时，栈中所有元素的最小值。

**操作逻辑**:
-   **`push(val)`**:
    1.  获取当前栈顶的最小值 `current_min` (如果栈为空，可以认为最小值是 `INT_MAX`)。
    2.  新的最小值为 `new_min = min(val, current_min)`。
    3.  将 `<val, new_min>` 这个 `pair` 压入栈中。
-   **`pop()`**:
    *   直接弹出栈顶的 `pair`。由于最小值信息是与元素绑定的，弹出元素的同时，最小值状态也自动回退到了上一个状态。
-   **`top()`**:
    *   返回当前栈顶 `pair` 的 `first` 元素。
-   **`getMin()`**:
    *   返回当前栈顶 `pair` 的 `second` 元素。这正是我们实时维护的当前栈的最小值。

通过这种方式，所有操作都只涉及栈顶，因此时间复杂度都是 O(1)。

### 另一种常见思路：辅助栈
另一个常见的方法是使用两个栈：
-   **`data_stack`**: 和普通栈一样，存储所有元素。
-   **`min_stack`**: 一个“单调递减”的辅助栈。
    -   **`push(val)`**: 当 `val` 小于或等于 `min_stack` 的栈顶元素时，才将 `val` 压入 `min_stack`。
    -   **`pop()`**: 如果 `data_stack` 弹出的元素恰好等于 `min_stack` 的栈顶元素，那么 `min_stack` 也需要弹出栈顶。
    -   **`getMin()`**: 直接返回 `min_stack` 的栈顶元素。

两种方法的核心思想都是同步维护最小值，你选择的 `pair` 方法在实现上更为简洁。

### 复杂度分析
- **时间复杂度**: O(1)
  *(所有操作都只涉及对栈顶的访问。)*
- **空间复杂度**: O(N)
  *(其中 N 是栈中元素的数量。我们需要额外的空间来存储每个元素对应的最小值信息。)*

---

## 代码实现

### C++ (使用 `stack<pair>` )
*(该实现通过将元素值和当前最小值绑定为一个 `pair` 存储，代码简洁且高效。)*
```cpp
#include <stack>
#include <utility> // for std::pair and std::make_pair
#include <algorithm> // for std::min
#include <climits> // for INT_MAX

class MinStack {
private:
    // pair.first: 元素值, pair.second: 到当前元素的最小值
    std::stack<std::pair<int, int>> stk;

public:
    MinStack() {
        // 初始化时，可以压入一个哨兵值，避免对空栈的额外判断
        // INT_MAX 保证第一个压入的元素一定是最小值
        stk.push({0, INT_MAX}); 
    }
    
    void push(int val) {
        // 获取当前栈的最小值 (即上一个元素的最小值)
        int current_min = stk.top().second;
        // 新的最小值是 val 和 current_min 中较小的那个
        stk.push({val, std::min(val, current_min)});
    }
    
    void pop() {
        // 保证不弹出哨兵
        if (stk.size() > 1) {
            stk.pop();
        }
    }
    
    int top() {
        return stk.top().first;
    }
    
    int getMin() {
        return stk.top().second;
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
 ```