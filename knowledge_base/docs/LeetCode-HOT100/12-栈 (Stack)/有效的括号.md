# 有效的括号

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/valid-parentheses/)

---

## 题目描述

> 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。
>
> 有效字符串需满足：
> 1.  左括号必须用相同类型的右括号闭合。
> 2.  左括号必须以正确的顺序闭合。
> 3.  每个右括号都有一个对应的相同类型的左括号。
>
> **示例:**
> ```
> 输入：s = "()"
> 输出：true
> ```
>
> ```
> 输入：s = "()[]{}"
> 输出：true
> ```
>
> ```
> 输入：s = "(]"
> 输出：false
> ```

---

## 解题思路

### 核心思想
**栈 (Stack) — 后进先出 (LIFO) 的完美匹配**

括号匹配问题具有典型的“后进先出”特性。当我们遇到一个右括号时，它需要匹配的是离它最近的、尚未被匹配的那个左括号。这正是**栈**这种数据结构的用武之地。

我们可以把这个问题想象成“消消乐”：
-   当我们遇到一个**左括号**，就把它看作一个待匹配的“坑”，我们将它**推入栈中**。
-   当我们遇到一个**右括号**，就尝试去填最近的一个“坑”。我们查看栈顶的左括号，看是否能与之匹配。
    -   如果能匹配，说明一对括号成功闭合，我们将栈顶的左括号**弹出**（“消掉”）。
    -   如果不能匹配（或者栈是空的，根本没有坑），那么这个字符串就是无效的。

**算法的最终判断**:
在遍历完整个字符串后：
-   如果栈是**空的**，说明所有的左括号都被成功匹配了，字符串有效。
-   如果栈**不为空**，说明有多余的左括号没有被匹配，字符串无效。

### 算法步骤
1.  **初始化**:
    *   创建一个栈 `stk` 用于存放左括号。
    *   （可选）创建一个 `map` 来存储右括号到左括号的映射，方便匹配。
2.  **遍历字符串**: 遍历输入字符串 `s` 的每一个字符 `ch`。
    *   **如果是左括号**: (`(`, `[`, `{`)，直接将其推入栈中 `stk.push(ch)`。
    *   **如果是右括号**: (`)`, `]`, `}`)，进行匹配判断：
        *   **检查栈是否为空**: 如果此时栈是空的，说明没有左括号与之匹配，直接返回 `false`。
        *   **检查是否匹配**: 取出栈顶元素 `top = stk.top()`，看它是否是当前右括号对应的左括号。
            *   如果不匹配，返回 `false`。
            *   如果匹配，将栈顶元素弹出 `stk.pop()`。
3.  **返回结果**:
    *   循环结束后，检查栈 `stk` 是否为空。如果为空，返回 `true`；否则，返回 `false`。

### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是字符串 `s` 的长度。我们只需要遍历一次字符串。)*
- **空间复杂度**: O(N)
  *(在最坏情况下（例如 `s = "((((("`），我们需要将所有字符都压入栈中。)*

---

## 代码实现

### C++ (修正后的标准实现)
*(该实现逻辑清晰，严格区分左括号的入栈和右括号的匹配操作，是解决此问题的标准范式。)*
```cpp
#include <stack>
#include <string>
#include <unordered_map>

class Solution {
public:
    bool isValid(std::string s) {
        // 哈希表，存储右括号到左括号的映射
        std::unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        std::stack<char> stk;

        for (char ch : s) {
            // 如果是右括号
            if (pairs.count(ch)) {
                // 检查栈是否为空，或栈顶是否匹配
                if (stk.empty() || stk.top() != pairs[ch]) {
                    return false;
                }
                stk.pop(); // 匹配成功，弹出栈顶
            } 
            // 如果是左括号
            else {
                stk.push(ch); // 直接入栈
            }
        }

        // 最终栈应为空，才算全部匹配成功
        return stk.empty();
    }
};
```