# 柱状图中最大的矩形

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

---

## 题目描述

> 给定 `n` 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 `1` 。
>
> 求在该柱状图中，能够勾勒出来的矩形的最大面积。
>
> **示例:**
> ```
> 输入：heights = [2,1,5,6,2,3]
> 输出：10
> 解释：最大的矩形为图中红色区域，面积为 10。
> ```
> ![Largest Rectangle Example](https://assets.leetcode.com/uploads/2021/01/05/bar_chart_area_1.jpg)

---

## 解题思路

### 核心思想
**枚举高度 + 单调栈**

一个常见的思路是**枚举矩形的高度**。对于柱状图中的每一个柱子 `i`，我们可以计算出以它自身的高度 `heights[i]` 为矩形高度时，所能形成的最大矩形的面积。

这个矩形的**高度**是 `heights[i]`，而它的**宽度**则取决于 `heights[i]` 能向左和向右延伸多远。具体来说，我们需要找到：
-   `left[i]`: `i` 左边**第一个**高度**小于** `heights[i]` 的柱子的索引。
-   `right[i]`: `i` 右边**第一个**高度**小于** `heights[i]` 的柱子的索引。

那么，以 `heights[i]` 为高的矩形，其宽度就是 `right[i] - left[i] - 1`，面积为 `heights[i] * (right[i] - left[i] - 1)`。

我们的最终答案就是所有 `i` 对应的这个面积的最大值。

问题的关键就转化为了：如何高效地为每个 `i` 找到 `left[i]` 和 `right[i]`？这正是**单调栈**的用武之地。

---

## 解法一：三次遍历 (两次单调栈 + 一次计算)

这是最容易理解的解法。我们分别用两次单调栈来计算 `left` 和 `right` 数组。
1.  **第一次遍历 (从左到右)**: 使用单调栈计算所有 `left[i]`。
2.  **第二次遍历 (从右到左)**: 使用单调栈计算所有 `right[i]`。
3.  **第三次遍历**: 遍历 `heights` 数组，利用 `left[i]` 和 `right[i]` 计算以 `heights[i]` 为高的面积，并更新最大值。

**单调栈逻辑 (以计算 `left` 为例)**:
- 维护一个**单调递增**的栈（存储索引）。
- 遍历 `i` 从 `0` 到 `n-1`：
  - `while` 循环，如果当前 `heights[i]` 小于等于栈顶高度，则不断 `pop()` 栈顶。
  - 循环结束后，栈顶就是 `i` 左边第一个比它小的元素，即 `left[i]`。
  - 将 `i` 入栈。

### 解法二：两次遍历 (一次单调栈)

我们可以优化解法一。在从左到右遍历，构建单调递增栈的过程中，当我们因为 `heights[i]` 小于栈顶高度而要将栈顶 `top_idx` 弹出时，我们其实获得了一个重要的信息：
> **`i` 就是 `top_idx` 右边第一个比 `heights[top_idx]` 小的柱子。**

这意味着，在弹出的那一刻，我们确定了 `right[top_idx] = i`。
而 `left[top_idx]` 呢？`top_idx` 出栈后，新的栈顶就是它左边第一个比它小的柱子。

**算法步骤**:
1.  **一次遍历 (从左到右)**:
    - 维护一个单调递增栈。
    - 遍历 `i` 从 `0` 到 `n-1`：
      - `while` 循环，如果 `heights[i]` 小于等于栈顶高度，则：
        - 弹出栈顶 `top_idx`。
        - 此时，`right[top_idx]` 就确定为 `i`。
        - `left[top_idx]` 就是 `top_idx` 出栈后的**新栈顶**。
      - `left[i]` 就是当前 `i` 入栈前的栈顶。
      - 将 `i` 入栈。
2.  **第二次遍历**: 计算最终面积。

### 解法三：一次遍历 (终极优化)

这是对解法二的进一步升华。既然在元素 `top_idx` 出栈的时候，我们已经同时知道了它的 `left` 边界（新栈顶）和 `right` 边界（当前 `i`），为什么不**直接计算面积**，而要等到最后呢？

**算法步骤**:
1.  在 `heights` 数组的末尾添加一个哨兵值 `-1` (或 `0`)。这确保了所有原来在栈中的元素最终都会被弹出。
2.  在栈中预先放入一个哨兵索引 `-1`。这简化了左边界的计算。
3.  **一次遍历 (从左到右)**:
    - 遍历 `i` 从 `0` 到 `n-1` (包括新加的哨兵)。
    - `while` 循环，如果 `heights[i]` 小于等于栈顶高度，则：
      - 弹出栈顶 `top_idx`。
      - `h = heights[top_idx]` (高度)。
      - `right = i` (右边界)。
      - `left = stk.top()` (左边界)。
      - 计算面积 `h * (right - left - 1)` 并更新最大值。
    - 将 `i` 入栈。

这种方法只用一次遍历就完成了所有工作，是最高效的解法。

### 复杂度分析 (三种方法相同)
- **时间复杂度**: O(N)
- **空间复杂度**: O(N)

---

## 代码实现

### 解法一：三次遍历 (您的实现)
```cpp
#include <vector>
#include <stack>
#include <algorithm> // for std::max
#include <climits>   // for INT_MIN

class Solution {
public:
    int largestRectangleArea(std::vector<int>& heights) {
        int n = heights.size();
        std::vector<int> left(n, -1);
        std::vector<int> right(n, n);
        std::stack<int> stk;

        // 1. 填充 left 数组
        for(int i = 0; i < n; i++) {
            while(!stk.empty() && heights[i] <= heights[stk.top()])
                stk.pop();
            if(!stk.empty())
                left[i] = stk.top();
            stk.push(i);
        }

        // 清空栈以便复用
        while (!stk.empty()) stk.pop();

        // 2. 填充 right 数组
        for(int i = n - 1; i >= 0; i--) {
            while(!stk.empty() && heights[i] <= heights[stk.top()]) 
                stk.pop();
            if(!stk.empty())
                right[i] = stk.top();
            stk.push(i);
        }

        // 3. 计算最大面积
        int res = 0;
        for(int i = 0; i < n; i++) {
            res = std::max(res, heights[i] * (right[i] - left[i] - 1));
        }
        return res;
    }
};
```
### 解法二：两次遍历
```C++

#include <vector>
#include <stack>
#include <algorithm>
#include <climits>

class Solution {
public:
    int largestRectangleArea(std::vector<int>& heights) {
        int n = heights.size();
        std::vector<int> left(n, -1);
        std::vector<int> right(n, n);
        std::stack<int> stk;

        // 1. 一次遍历确定所有 right 和部分 left
        for(int i = 0; i < n; i++) {
            while(!stk.empty() && heights[i] <= heights[stk.top()]) {
                right[stk.top()] = i;
                stk.pop();
            }
            if(!stk.empty()) {
                left[i] = stk.top();
            }
            stk.push(i);
        }

        // 2. 计算最大面积
        int res = 0;
        for(int i = 0; i < n; i++) {
            res = std::max(res, heights[i] * (right[i] - left[i] - 1));
        }
        return res;
    }
};
```

### 解法三：一次遍历 
```C++

```cpp
#include <vector>
#include <stack>
#include <algorithm> // for std::max

class Solution {
public:
    int largestRectangleArea(std::vector<int>& heights) {
        // 哨兵1: 在数组末尾添加一个0，确保所有柱子都能被弹出计算
        heights.push_back(0);
        int n = heights.size();
        std::stack<int> stk;
        // 哨兵2: 在栈底放入-1，简化左边界的计算
        stk.push(-1);
        int max_area = 0;

        for (int i = 0; i < n; ++i) {
            // 维护单调递增栈
            // 当遇到更矮的柱子时，开始出栈并计算面积
            while (stk.top() != -1 && heights[i] <= heights[stk.top()]) {
                // 弹出栈顶，计算以此柱子为高的矩形
                int h = heights[stk.top()];
                stk.pop();
                
                // 右边界是 i，左边界是新的栈顶
                int left = stk.top();
                int w = i - left - 1;
                max_area = std::max(max_area, h * w);
            }
            // 当前索引入栈
            stk.push(i);
        }
        
        heights.pop_back(); // 恢复原始 heights (可选)
        return max_area;
    }
};
```