# 杨辉三角

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/pascals-triangle/)

---

## 题目描述

> 给定一个非负整数 `numRows`，生成「杨辉三角」的前 `numRows` 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。
>
> ![Pascal's Triangle](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)
>
> **示例:**
> ```
> 输入: numRows = 5
> 输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
> ```
>
> ```
> 输入: numRows = 1
> 输出: [[1]]
> ```

---

## 解题思路

### 核心思想
**动态规划 (或直接模拟)**

杨辉三角的生成规则本身就具有动态规划的特性。每一行的元素都依赖于其上一行的元素。
-   **状态定义**: `triangle[i][j]` 表示杨辉三角第 `i` 行、第 `j` 列的数值（索引从 0 开始）。
-   **状态转移方程**: 根据定义，`triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]`。
-   **边界条件**: 每一行的第一个和最后一个元素永远是 `1`。即 `triangle[i][0] = 1` 和 `triangle[i][i] = 1`。

我们可以直接模拟这个生成过程，逐行构建杨辉三角。

### 算法步骤
1.  **初始化**:
    *   创建一个二维向量（`vector<vector<int>>`） `result` 作为最终的杨辉三角。
2.  **逐行生成**:
    *   使用一个外层 `for` 循环，从 `i = 0` 到 `numRows - 1`，代表要生成的行号。
    *   对于每一行 `i`，创建一个临时的一维向量 `current_row`，其大小为 `i + 1`。
    *   **处理边界**: 将 `current_row` 的第一个和最后一个元素都设置为 `1`。
    *   **计算中间元素**: 使用一个内层 `for` 循环，`j` 从 `1` 到 `i - 1`，根据状态转移方程计算 `current_row` 的中间元素：
        `current_row[j] = result[i-1][j-1] + result[i-1][j]`
    *   将构建完成的 `current_row` 添加到 `result` 中。
3.  **返回结果**: 循环结束后，返回 `result`。

### 复杂度分析
- **时间复杂度**: O(numRows^2)
  *(我们需要填充一个三角形，其总元素个数大约是 (1 + numRows) * numRows / 2，所以时间复杂度是平方级别的。)*
- **空间复杂度**: O(1) (不包括返回结果) 或 O(numRows^2) (包括返回结果)
  *(如果我们不考虑存储最终结果所需的空间，那么只需要 O(numRows) 的空间来存储当前行。但题目要求返回整个三角，所以需要 O(numRows^2) 的空间。)*

---

## 代码实现

### C++ (模拟生成)
*(该实现完全遵循杨辉三角的定义，逐行构建，逻辑清晰易懂。)*
```cpp
#include <vector>

class Solution {
public:
    std::vector<std::vector<int>> generate(int numRows) {
        std::vector<std::vector<int>> result;

        // 遍历每一行
        for (int i = 0; i < numRows; ++i) {
            // 第 i 行有 i + 1 个元素
            std::vector<int> current_row(i + 1);
            
            // 1. 设置边界值
            current_row[0] = 1;
            current_row[i] = 1;

            // 2. 计算中间值
            // j 从 1 开始，到 i-1 结束
            for (int j = 1; j < i; ++j) {
                // 当前数等于上一行的前一列与当前列之和
                current_row[j] = result[i - 1][j - 1] + result[i - 1][j];
            }
            
            // 3. 将当前行加入结果
            result.push_back(current_row);
        }
        
        return result;
    }
};
```