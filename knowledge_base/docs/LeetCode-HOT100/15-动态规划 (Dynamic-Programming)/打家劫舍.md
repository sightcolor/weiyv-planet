# 打家劫舍

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/house-robber/)

---

## 题目描述

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是 **相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。
>
> **示例:**
> ```
> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> ```
>
> ```
> 输入：[2,7,9,3,1]
> 输出：12
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>      偷窃到的最高金额 = 2 + 9 + 1 = 12 。
> ```

---

## 解题思路

### 核心思想
**动态规划 (Dynamic Programming)**

这是一个经典的动态规划问题。对于每一间房屋，我们都有两种选择：**偷**或**不偷**。这两种选择会影响我们后续的决策，符合动态规划的特征。

**状态定义**:
我们定义 `dp[i]` 为：考虑前 `i` 间房屋（从第 0 间到第 `i-1` 间），能够偷窃到的最高金额。

**状态转移方程**:
当我们决策到第 `i` 间房屋时（其金额为 `nums[i]`），我们有两种选择：
1.  **不偷第 `i` 间房屋**: 如果不偷，那么我们能获得的最大金额就等于偷前 `i-1` 间房屋的最大金额，即 `dp[i-1]`。
2.  **偷第 `i` 间房屋**: 如果决定偷，根据规则，我们就**不能**偷第 `i-1` 间房屋。因此，我们能获得的总金额是“偷前 `i-2` 间房屋的最大金额”加上“第 `i` 间房屋的金额”，即 `dp[i-2] + nums[i]`。

我们在这两种选择中取一个最大值，就得到了 `dp[i]` 的值：
> **`dp[i] = max(dp[i-1], dp[i-2] + nums[i])`**

---

### 实现方法

#### 方法一：记忆化搜索 (自顶向下 DP - 您的实现)
这种方法从目标 `dp[n-1]` 出发，通过递归向前求解。为了避免重复计算子问题（例如 `dfs(i-2)` 会被 `dfs(i)` 和 `dfs(i-1)` 多次调用），我们使用一个 `memo` 数组来缓存已经计算过的结果。
- **函数定义**: `dfs(i)` 表示偷到第 `i` 间房屋为止的最大金额。
- **递归逻辑**: `dfs(i) = max(dfs(i-1), dfs(i-2) + nums[i])`。
- **Base Case**: `if (i < 0) return 0`。
- **记忆化**: 在函数开头检查 `memo[i]` 是否已被计算，如果计算过，直接返回。在函数返回前，将结果存入 `memo[i]`。

#### 方法二：标准 DP (自底向上)
这种方法从 Base Case 出发，通过迭代逐步构建出最终答案。
1.  **初始化 `dp` 数组**: `dp` 数组大小为 `n`。
2.  **Base Case**:
    *   `dp[0] = nums[0]` (只有一间房，必须偷)。
    *   `dp[1] = max(nums[0], nums[1])` (有两间房，偷金额大的那间)。
3.  **循环迭代**: 从 `i = 2` 到 `n-1`，应用状态转移方程 `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`。
4.  **返回结果**: `dp[n-1]`。

#### 方法三：状态压缩 (空间优化)
观察状态转移方程，我们发现计算 `dp[i]` 只依赖 `dp[i-1]` 和 `dp[i-2]`。因此，我们不需要一个完整的 `dp` 数组，只需要两个变量来存储前两个状态即可，实现空间复杂度的优化。
- `prev2`: 存储 `dp[i-2]` 的值。
- `prev1`: 存储 `dp[i-1]` 的值。
- `current`: 存储 `dp[i]` 的计算结果 `max(prev1, prev2 + nums[i])`。

### 复杂度分析
- **时间复杂度**: O(N)
  *(三种方法都需要遍历一次数组或递归解决 N 个子问题。)*
- **空间复杂度**:
  *   记忆化搜索: O(N) (递归栈 + memo 数组)
  *   标准 DP: O(N) (dp 数组)
  *   **状态压缩: O(1)** (仅需常数个变量)

---

## 代码实现

### C++ (记忆化搜索)
```cpp
#include <vector>
#include <functional>
#include <algorithm> // for std::max

class Solution {
public:
    int rob(std::vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        
        std::vector<int> memo(n, -1);
        
        // dfs(i) 表示偷窃到第 i 间房屋为止能获得的最大金额
        std::function<int(int)> dfs = [&](int i) -> int {
            // Base Case: 没有房屋了
            if (i < 0) {
                return 0;
            }
            // 如果已经计算过，直接返回
            if (memo[i] != -1) {
                return memo[i];
            }
            
            // 状态转移：max(不偷当前房, 偷当前房)
            int result = std::max(dfs(i - 1), dfs(i - 2) + nums[i]);
            
            // 缓存结果
            memo[i] = result;
            return result;
        };
        
        return dfs(n - 1);
    }
};
```
### C++ (状态压缩 - 最优解)
```C++

#include <vector>
#include <algorithm>

class Solution {
public:
    int rob(std::vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        if (n == 1) return nums[0];

        int prev2 = 0;           // 相当于 dp[i-2]
        int prev1 = 0;           // 相当于 dp[i-1]
        
        for (int i = 0; i < n; ++i) {
            int current = std::max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = current;
        }
        
        return prev1; // 最终结果存储在 prev1 中
    }
};
```