# 爬楼梯

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/climbing-stairs/)

---

## 题目描述

> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> **示例:**
> ```
> 输入：n = 2
> 输出：2
> 解释：有两种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶
> 2. 2 阶
> ```
>
> ```
> 输入：n = 3
> 输出：3
> 解释：有三种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶
> ```

---

## 解题思路

### 核心思想
**动态规划 (Dynamic Programming) — 斐波那契数列**

这个问题是一个经典的动态规划入门题。我们来分析一下问题的结构：
- 我们的目标是到达第 `n` 阶楼梯。
- 思考一下，我们是如何到达第 `n` 阶的？根据题目，我们只能爬 `1` 或 `2` 阶。
  - 要么，我们是从第 `n-1` 阶爬了 `1` 阶上来的。
  - 要么，我们是从第 `n-2` 阶爬了 `2` 阶上来的。
- 因此，到达第 `n` 阶的总方法数，就等于 **(到达第 `n-1` 阶的方法数) + (到达第 `n-2` 阶的方法数)**。

如果我们用 `dp[i]` 表示到达第 `i` 阶的方法数，那么我们就得到了状态转移方程：
> **`dp[i] = dp[i-1] + dp[i-2]`**

这正是**斐波那契数列**的定义！

### 算法步骤

#### 方法一：标准动态规划
1.  **定义 `dp` 数组**: `dp[i]` 表示爬到第 `i` 阶的不同方法数。
2.  **确定 Base Case**:
    *   `dp[1] = 1` (爬到第1阶只有1种方法：爬1阶)。
    *   `dp[2] = 2` (爬到第2阶有2种方法：1+1 或 2)。
3.  **遍历求解**: 从 `i = 3` 开始，利用状态转移方程 `dp[i] = dp[i-1] + dp[i-2]` 填充 `dp` 数组，直到 `dp[n]`。
4.  **返回结果**: `dp[n]` 就是最终答案。
- **时间复杂度**: O(N)
- **空间复杂度**: O(N)

#### 方法二：状态压缩 (滚动数组)
观察状态转移方程，我们发现计算 `dp[i]` 只需要 `dp[i-1]` 和 `dp[i-2]` 这两个值。我们完全没有必要保存整个 `dp` 数组。
我们可以只用三个变量来“滚动”计算：
- `a`: 存储 `dp[i-2]` 的值。
- `b`: 存储 `dp[i-1]` 的值。
- `res`: 存储 `dp[i]` 的计算结果 `a + b`。

**算法步骤 (您的实现)**:
1.  **处理 Base Case**: 如果 `n <= 2`，直接返回 `n`。
2.  **初始化**: `a = 1` (代表 `dp[1]`), `b = 2` (代表 `dp[2]`)。
3.  **循环迭代**: 从 `i = 3` 到 `n`：
    *   计算当前结果: `res = a + b`。
    *   更新状态用于下一轮: `a = b`, `b = res`。
4.  **返回结果**: 循环结束后，`res` (或 `b`) 中存储的就是最终答案。
- **时间复杂度**: O(N)
- **空间复杂度**: O(1)

这是对标准动态规划的空间优化，也是解决此问题的最优方法。

---

## 代码实现

### C++ (动态规划 + 状态压缩)
*(该实现准确地识别了问题的斐波那契数列本质，并使用了滚动变量进行空间优化，是此问题的最优解。)*
```cpp
class Solution {
public:
    int climbStairs(int n) {
        // Base cases
        if (n <= 2) {
            return n;
        }

        // a 相当于 dp[i-2], b 相当于 dp[i-1]
        int a = 1; // dp[1]
        int b = 2; // dp[2]
        int result = 0;

        // 从第 3 阶开始迭代计算
        for (int i = 3; i <= n; ++i) {
            // result 相当于 dp[i] = dp[i-1] + dp[i-2]
            result = a + b;
            
            // 状态向前滚动，为下一轮计算做准备
            a = b;
            b = result;
        }
        
        return result;
    }
};
```