# 完全平方数

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/perfect-squares/)

---

## 题目描述

> 给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。
>
> **完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。
>
> **示例:**
> ```
> 输入：n = 12
> 输出：3
> 解释：12 = 4 + 4 + 4
> ```
>
> ```
> 输入：n = 13
> 输出：2
> 解释：13 = 4 + 9
> ```

---

## 解题思路

### 核心思想
**方法一：动态规划 (完全背包模型)**

这个问题可以完美地抽象为一个**完全背包**问题。
-   **背包容量**: 目标整数 `n`。
-   **物品**: 所有小于等于 `n` 的完全平方数，即 `1*1, 2*2, 3*3, ...`。
-   **物品价值/重量**: 每个物品的“重量”和“价值”都是它本身，即 `i*i`。
-   **问题转化**: 我们需要用最少的“物品”来恰好装满容量为 `n` 的背包。由于每个完全平方数可以被无限次使用，所以这是一个**完全背包**问题。

---
**方法二：广度优先搜索 (BFS)**

这个问题也可以看作是一个图论中的**最短路径**问题。
-   **节点**: `0` 到 `n` 之间的所有整数。
-   **边**: 如果两个数 `a` 和 `b` 之间可以通过一个完全平方数相连（即 `a = b + k*k`），那么 `a` 和 `b` 之间就有一条边。
-   **问题转化**: 我们要寻找从节点 `n` 到节点 `0` 的**最短路径**。路径的长度就是所用完全平方数的数量。BFS 是解决此类问题的经典算法。

---

## 代码实现

### 方法一：动态规划 (完全背包)

#### 记忆化搜索 (自顶向下 DP - 您的实现)
-   **函数定义**: `dfs(i, j)` 表示使用前 `i` 个完全平方数，凑成 `j` 的最少数量。
-   **递归逻辑**: `dfs(i, j) = min(dfs(i-1, j), dfs(i, j - i*i) + 1)`。
-   **时间复杂度**: O(n * sqrt(n))
-   **空间复杂度**: O(n * sqrt(n))
```cpp
#include <vector>
#include <functional>
#include <cmath>
#include <algorithm>
#include <climits>

class Solution {
public:
    int numSquares(int n) {
        int k = static_cast<int>(sqrt(n));
        // memo[i][j]: 使用前 i 个完全平方数凑成 j 的最少数量
        std::vector<std::vector<int>> memo(k + 1, std::vector<int>(n + 1, -1));

        std::function<int(int, int)> dfs = 
            [&](int i, int rest) -> int {
            // Base Case: 成功凑成
            if (rest == 0) {
                return 0;
            }
            // Base Case: 物品用完或容量为负，无法凑成
            if (i <= 0 || rest < 0) {
                return INT_MAX / 2; // 返回一个极大值表示无法到达
            }
            // 如果已计算过，直接返回
            if (memo[i][rest] != -1) {
                return memo[i][rest];
            }

            int square = i * i;
            int res;
            // 如果当前物品放不下，只能不选
            if (rest < square) {
                res = dfs(i - 1, rest);
            } 
            // 否则，在“不选”和“选”之间取最优
            else {
                // dfs(i-1, rest): 不选第 i 个物品
                // dfs(i, rest - square) + 1: 选第 i 个物品（注意第一个参数是 i，表示可重复选）
                res = std::min(dfs(i - 1, rest), dfs(i, rest - square) + 1);
            }
            
            return memo[i][rest] = res;
        };
        
        return dfs(k, n);
    }
};
```
### 二维 DP (自底向上)
- `dp[i][j]` 表示：使用前 `i` 个完全平方数，凑成 `j` 的最少数量。  
- 时间复杂度: $O(n * \text{sqrt}(n))$  
- 空间复杂度: $O(n * \text{sqrt}(n))$  
```C++

#include <vector>
#include <cmath>
#include <algorithm>
#include <climits>

class Solution {
public:
    int numSquares(int n) {
        int k = static_cast<int>(sqrt(n));
        std::vector<std::vector<int>> dp(k + 1, std::vector<int>(n + 1, INT_MAX / 2));
        
        for (int i = 0; i <= k; ++i) dp[i][0] = 0;

        for (int i = 1; i <= k; ++i) {
            int square = i * i;
            for (int j = 1; j <= n; ++j) {
                if (j < square) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = std::min(dp[i - 1][j], dp[i][j - square] + 1);
                }
            }
        }
        return dp[k][n];
    }
};
```

### 一维 DP (空间优化)
- `dp[j]` 表示凑成 `j` 的最少数量。  
- 时间复杂度: $O(n * \text{sqrt}(n))$  
- 空间复杂度: $O(n)$  
```C++

#include <vector>
#include <cmath>
#include <algorithm>
#include <climits>

class Solution {
public:
    int numSquares(int n) {
        std::vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;

        for (int i = 1; i * i <= n; ++i) {
            int square = i * i;
            for (int j = square; j <= n; ++j) {
                dp[j] = std::min(dp[j], dp[j - square] + 1);
            }
        }
        return dp[n];
    }
};
```
### 方法二：广度优先搜索 (BFS)
- **时间复杂度**: $O(n * \text{sqrt}(n))$  
- **空间复杂度**: $O(n)$  

```C++

#include <vector>
#include <queue>
#include <cmath>

class Solution {
public:
    int numSquares(int n) {
        std::queue<int> q;
        q.push(n);
        std::vector<bool> visited(n + 1, false);
        visited[n] = true;
        int level = 0;

        while (!q.empty()) {
            int size = q.size();
            level++;
            for (int i = 0; i < size; ++i) {
                int current = q.front();
                q.pop();
                for (int j = 1; j * j <= current; ++j) {
                    int next = current - j * j;
                    if (next == 0) return level;
                    if (!visited[next]) {
                        q.push(next);
                        visited[next] = true;
                    }
                }
            }
        }
        return n;
    }
};
```

