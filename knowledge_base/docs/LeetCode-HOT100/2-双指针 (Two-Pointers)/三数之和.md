# 三数之和

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/3sum/)

---

## 题目描述

> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请
>
> 你返回所有和为 `0` 且不重复的三元组。
>
> **注意：** 答案中不可以包含重复的三元组。
>
> **示例:**
> ```
> 输入: nums = [-1,0,1,2,-1,-4]
> 输出: [[-1,-1,2],[-1,0,1]]
> ```

---

## 解题思路

### 核心思想
采用**排序 + 双指针**的策略。先对数组进行排序，这是为了方便地处理重复解以及使用双指针进行查找。然后，遍历数组固定第一个数，再用双指针在剩余部分中寻找另外两个数，使三数之和为零。

### 算法步骤
1.  **初始化与排序**: 创建一个结果向量 `res`。对整个 `nums` 数组进行升序排序。
2.  **外层循环（固定第一个数）**: 遍历数组，用索引 `i` 固定第一个数 `nums[i]`。
    *   **剪枝优化**: 如果 `nums[i] > 0`，由于数组已排序，后面的数都大于等于 `nums[i]`，三数之和不可能为零，可以直接结束循环。
    *   **`i` 指针去重**: 如果 `i > 0` 且 `nums[i] == nums[i-1]`，说明这个数已经作为起点处理过了，为避免重复解，`continue` 到下一次循环。
3.  **内层循环（双指针）**: 初始化左指针 `left = i + 1` 和右指针 `right = nums.size() - 1`。
4.  **移动双指针**: 在 `left < right` 的条件下循环：
    *   计算三数之和 `sum = nums[i] + nums[left] + nums[right]`。
    *   如果 `sum > 0`，和太大，需要减小，将 `right` 左移。
    *   如果 `sum < 0`，和太小，需要增大，将 `left` 右移。
    *   如果 `sum == 0`，找到了一个解：
        *   将 ` {nums[i], nums[left], nums[right]}` 存入 `res`。
        *   **先将指针向内移动**：`left++` 和 `right--`。
        *   **然后跳过重复项**：
            *   检查新的 `left` 是否和它**前一个位置** `left - 1` 的值相同，如果相同则继续 `left++`，直到找到一个不同的值。
            *   检查新的 `right` 是否和它**前一个位置** `right + 1` 的值相同，如果相同则继续 `right--`，直到找到一个不同的值。
5.  **返回**: 遍历结束后，返回 `res`。

### 复杂度分析
- **时间复杂度**: O(N^2)
  *数组排序的时间复杂度为 O(N log N)。外层循环遍历 N 次，内层的双指针 `while` 循环在最坏情况下也是 O(N)。因此，总的时间复杂度为 O(N log N + N^2) = O(N^2)。*
- **空间复杂度**: O(log N) 或 O(N)
  *主要取决于排序算法所使用的额外空间。如果原地排序（如快速排序），空间复杂度为 O(log N)；如果使用了需要额外空间的排序，则为 O(N)。*

---

## 代码实现

```cpp
#include <vector>
#include <algorithm>

class Solution {
public:
    std::vector<std::vector<int>> threeSum(std::vector<int>& nums) {
        int n = nums.size();
        // 对数组进行排序
        sort(nums.begin(), nums.end());
        std::vector<std::vector<int>> res;

        // 遍历数组，固定第一个数 a
        for(int i = 0; i < n; i++) {
            // 对第一个数进行去重
            if(i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            // 剪枝：如果固定的数大于0，则和必大于0
            if(nums[i] > 0) {
                break;
            }

            // 初始化双指针
            int left = i + 1, right = n - 1;
            while(left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == 0) {
                    // 找到一个解
                    res.push_back({nums[i], nums[left], nums[right]});
                    
                    // 先将指针向内移动
                    left++;
                    right--;

                    // 然后对 left 指针去重：跳过所有与前一个元素相同的元素
                    while(left < right && nums[left] == nums[left - 1]) {
                        left++;
                    } 
                    // 对 right 指针去重：跳过所有与前一个元素相同的元素
                    // 注意：这里是 nums[right] == nums[right + 1]，因为 right 已经 --
                    while(right > left && nums[right] == nums[right + 1]) {
                        right--;
                    }
                } else if(sum > 0) {
                    // 和太大，移动右指针
                    right--;
                } else {
                    // 和太小，移动左指针
                    left++;
                }
            }
        }
        return res;
    }
};
```