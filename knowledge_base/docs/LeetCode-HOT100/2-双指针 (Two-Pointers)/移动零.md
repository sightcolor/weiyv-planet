# 移动零

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/move-zeroes/)

---

## 题目描述

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
> **示例:**
> ```
> 输入: nums = [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```

---

## 解题思路

### 核心思想
采用**双指针法**（快慢指针）进行原地操作。定义一个慢指针 `left` 和一个快指针 `right`。`left` 指针指向下一个非零元素应该被放置的位置，而 `right` 指针则负责遍历整个数组去寻找非零元素。通过这种方式，所有非零元素被依次移动到数组的前部，而零元素自然就被留在了后面。

### 算法步骤
1.  **初始化**: 创建一个慢指针 `left`，并将其初始化为 `0`。这个指针的含义是 `[0, left)` 范围内的所有元素都是已处理好的非零元素。
2.  **遍历**: 使用快指针 `right` 从 `0` 开始遍历整个 `nums` 数组。
3.  **逻辑判断**: 在循环中，检查快指针 `right` 指向的元素 `nums[right]` 是否为非零。
    *   如果 `nums[right]` **不为零**，说明找到了一个需要前移的元素。
4.  **交换与移动**: 将 `nums[right]` 与 `nums[left]` 进行交换。这样，非零元素就被移动到了它应该在的位置。然后，将慢指针 `left` 向右移动一位，扩大非零元素区间的边界。
5.  **继续遍历**: 如果 `nums[right]` 为零，则 `left` 指针不动，只有 `right` 指针继续向后移动，直到找到下一个非零元素。
6.  **完成**: 当 `right` 指针遍历完整个数组后，所有非零元素都已按照其原始相对顺序被移动到了数组的前部，所有零元素则被交换到了数组的后部。

### 复杂度分析
- **时间复杂度**: O(N)
  *其中 N 是 `nums` 数组的长度。快指针 `right` 和慢指针 `left` 都只从头到尾遍历数组一次。*
- **空间复杂度**: O(1)
  *我们只使用了常数级别的额外空间（两个指针变量），操作是在原数组上进行的，因此空间复杂度为 O(1)。*

---

## 代码实现

```cpp
#include <vector>
#include <algorithm> // for std::swap

class Solution {
public:
    void moveZeroes(std::vector<int>& nums) {
        int n = nums.size();
        // left 指针指向下一个非零元素应该被放置的位置
        // [0, left) 区间内的元素都是非零元素
        int left = 0; 
        
        // right 指针用于遍历整个数组
        for(int right = 0; right < n; right++) {
            // 当 right 指针找到一个非零元素时
            if(nums[right] != 0) {
                // 将这个非零元素与 left 指针指向的位置进行交换
                // 这会将非零元素移动到数组的前部
                std::swap(nums[left], nums[right]);
                
                // 将 left 指针向右移动一位，准备放置下一个非零元素
                left++;
            }
        }
    }
};
```