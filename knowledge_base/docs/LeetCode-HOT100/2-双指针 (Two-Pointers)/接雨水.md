# 接雨水

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/trapping-rain-water/)

---

## 题目描述

> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
> **示例:**
> ```
> 输入: height =
> 输出: 6
> 解释: 上面是由数组 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。
> ```

---

## 解题思路

### 核心思想
无论使用哪种方法，解决这个问题的核心思想是相同的：对于数组中的每一个位置 `i`，它能接的雨水等于其**左边最高柱子**和**右边最高柱子**中的**较小者**，再减去当前位置 `i` 本身的高度。

即：`water[i] = min(left_max[i], right_max[i]) - height[i]`

如果 `min(...)` 比 `height[i]` 还小，则当前位置无法接水，积水为 `0`。最终的总雨水量就是所有位置 `i` 的积水之和。

下面介绍两种实现这一思想的方法。

---

### 解法一：前后缀分解 (动态规划)

#### 算法步骤
1.  **初始化**: 创建两个与 `height` 等长的数组，`left` 和 `right`，分别用于存储每个位置左边的最高柱子和右边的最高柱子。
2.  **计算左侧最大值**: 从左到右遍历 `height` 数组。对于每个位置 `i`，`left[i]` 的值等于 `max(height[i], left[i-1])`。这样 `left[i]` 就记录了从 `0` 到 `i` 的最高柱子高度。
3.  **计算右侧最大值**: 从右到左遍历 `height` 数组。对于每个位置 `i`，`right[i]` 的值等于 `max(height[i], right[i+1])`。这样 `right[i]` 就记录了从 `i` 到 `n-1` 的最高柱子高度。
4.  **累加结果**: 再次遍历 `height` 数组。对于每个位置 `i`，根据核心公式 `min(left[i], right[i]) - height[i]` 计算该位置的积水量，并累加到最终结果 `res` 中。
5.  **返回**: 返回 `res`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *需要三次独立的线性遍历，总时间复杂度为 O(N) + O(N) + O(N) = O(N)。*
- **空间复杂度**: O(N)
  *需要两个额外的数组 `left` 和 `right` 来存储前后缀最大值。*

---

### 解法二：双指针

#### 算法步骤
这是一种空间优化的方法，它在一次遍历中完成所有计算。

1.  **初始化**: 设置左指针 `left = 0`，右指针 `right = n - 1`。设置左侧最高柱子 `pre_max = 0`，右侧最高柱子 `suf_max = 0`。初始化结果 `res = 0`。
2.  **循环**: 当 `left < right` 时，持续循环。
3.  **更新前后缀最大值**: 在循环内部，首先更新 `pre_max = max(pre_max, height[left])` 和 `suf_max = max(suf_max, height[right])`。
4.  **核心判断与计算**:
    *   比较 `pre_max` 和 `suf_max`。
    *   如果 `pre_max < suf_max`，这意味着对于 `left` 指针当前的位置，它的左侧最高点 `pre_max` 一定是它的瓶颈（因为右侧有一个更高的已知点 `suf_max`）。因此，该位置能接的雨水量由 `pre_max` 决定，即 `res += pre_max - height[left]`。然后将 `left` 指针右移。
    *   反之，如果 `pre_max >= suf_max`，则对于 `right` 指针当前的位置，它的右侧最高点 `suf_max` 是瓶颈。该位置能接的雨水量由 `suf_max` 决定，即 `res += suf_max - height[right]`。然后将 `right` 指针左移。
5.  **返回**: 循环结束后，`res` 就是总的积水量。

#### 复杂度分析
- **时间复杂度**: O(N)
  *`left` 和 `right` 指针只会相向移动，遍历数组一次。*
- **空间复杂度**: O(1)
  *只使用了常数级别的额外变量，成功将空间复杂度从 O(N) 优化到 O(1)。*

---

## 代码实现

### 解法一：前后缀分解

```cpp
#include <vector>
#include <algorithm>

class Solution {
public:
    int trap(std::vector<int>& height) {
        int n = height.size();
        if (n <= 2) return 0; // 边长小于等于2无法接水

        // left[i] 表示从下标 0 到 i 的最高柱子高度
        std::vector<int> left(n, 0);
        left = height;
        for(int i = 1; i < n; i++) {
            left[i] = std::max(height[i], left[i - 1]);
        }

        // right[i] 表示从下标 i 到 n-1 的最高柱子高度
        std::vector<int> right(n, 0);
        right[n - 1] = height[n - 1];
        for(int i = n - 2; i >= 0; i--) {
            right[i] = std::max(height[i], right[i + 1]);
        }

        int res = 0;
        // 遍历每个位置，累加该位置的积水量
        for(int i = 0; i < n; i++) {
            // 积水量 = min(左边最高, 右边最高) - 当前高度
            res += (std::min(left[i], right[i]) - height[i]);
        }
        return res;
    }
};
```

### 解法二：双指针
```cpp
#include <vector>
#include <algorithm>

class Solution {
public:
    int trap(std::vector<int>& height) {
        int n = height.size();
        if (n <= 2) return 0;

        int left = 0, right = n - 1;
        // pre_max 记录 [0...left] 的最高柱子
        // suf_max 记录 [right...n-1] 的最高柱子
        int pre_max = 0, suf_max = 0;
        int res = 0;
        
        while(left < right) {
            // 更新左右两边的历史最高高度
            pre_max = std::max(pre_max, height[left]);
            suf_max = std::max(suf_max, height[right]);
            
            // 核心：哪边的最高高度更小，就结算哪边的积水
            if(pre_max < suf_max) {
                // 左边的 pre_max 是瓶颈，可以确定 left 位置的积水
                // 因为右边必有 suf_max 这个更高的墙挡着
                res += pre_max - height[left];
                left++;
            } else {
                // 右边的 suf_max 是瓶颈，可以确定 right 位置的积水
                // 因为左边必有 pre_max 这个更高或等高的墙挡着
                res += suf_max - height[right];
                right--;
            }
        }
        return res;
    }
};
```