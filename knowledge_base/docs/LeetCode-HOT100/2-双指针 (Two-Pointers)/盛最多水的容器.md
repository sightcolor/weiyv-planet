# 盛最多水的容器

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/container-with-most-water/)

---

## 题目描述

> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。
>
> 找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。
>
> **说明：** 你不能倾斜容器。
>
> **示例:**
> ```
> 输入: [1,8,6,2,5,4,8,3,7]
> 输出: 49
> 解释: 图中垂直线代表输入数组。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
> ```

---

## 解题思路

### 核心思想
采用**双指针法**。两个指针 `left` 和 `right` 分别指向数组的头和尾，构成一个容器。容器的面积取决于两个指针之间的距离（宽度）和较短的那条垂线的高度。为了找到可能更大的面积，我们必须移动指向**较短**垂线的那个指针，因为移动较长垂线的指针只会让宽度变小，而高度仍然受限于原来那条较短的垂线，面积不可能增大。

### 算法步骤
1.  **初始化**: 创建两个指针，`left` 指向数组起始位置 `0`，`right` 指向数组末尾 `height.size() - 1`。初始化最大面积 `res = 0`。
2.  **循环**: 当 `left < right` 时，持续循环。
3.  **计算面积**: 计算当前 `left` 和 `right` 指针构成的容器面积：`面积 = (right - left) * min(height[left], height[right])`。
4.  **更新最大值**: 将当前计算出的面积 `val`与 `res` 比较，更新 `res = max(res, val)`。
5.  **移动指针**: 比较 `height[left]` 和 `height[right]` 的高度。
    *   如果 `height[left] > height[right]`，说明右边的垂线是短板，移动 `right` 指针向左 (`right--`)，才有可能找到更高的右边界来增大面积。
    *   否则（`height[left] <= height[right]`），说明左边的垂线是短板或一样短，移动 `left` 指针向右 (`left++`)，才有可能找到更高的左边界。
6.  **返回**: 循环结束后，`res` 中存储的就是能够容纳的最大水量，返回 `res`。

### 复杂度分析
- **时间复杂度**: O(N)
  *其中 N 是 `height` 数组的长度。`left` 和 `right` 指针总共只会遍历数组一次，因此时间复杂度是线性的。*
- **空间复杂度**: O(1)
  *我们只使用了 `left`, `right`, `res` 等几个变量，占用了常数级别的额外空间。*

---

## 代码实现

```cpp
#include <vector>
#include <algorithm> // for std::min and std::max

class Solution {
public:
    int maxArea(std::vector<int>& height) {
        // 初始化左指针为数组开头，右指针为数组末尾
        int left = 0, right = height.size() - 1;
        // 初始化结果变量，用于存储最大面积
        int res = 0;
        
        // 当左指针在右指针左边时，持续循环
        while(left < right) {
            // 计算当前指针构成的容器面积
            // 宽度 = right - left
            // 高度 = 两个指针指向的较短垂线的高度
            int val = (right - left) * std::min(height[left], height[right]);
            // 更新最大面积
            res = std::max(res, val);
            
            // 移动指针的逻辑
            // 为了找到可能更大的面积，我们总是移动指向较短垂线的那个指针
            if(height[left] > height[right]) {
                // 如果右边的高度是短板，则向左移动右指针
                right--;
            } else {
                // 如果左边的高度是短板（或一样短），则向右移动左指针
                left++;
            }
        }
        
        // 返回最终计算出的最大面积
        return res;
    }
};
```