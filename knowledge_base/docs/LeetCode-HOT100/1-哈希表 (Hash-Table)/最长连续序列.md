# 最长连续序列

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/longest-consecutive-sequence/)

---

## 题目描述

> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
>
> 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
>
> **示例:**
> ```
> 输入: nums = [100,4,200,1,3,2]
> 输出: 4
> 解释: 最长数字连续序列是。它的长度为 4。
> ```

---

## 解题思路

### 核心思想
利用哈希集合 (`std::unordered_set`) 来优化查找效率。首先将所有数字存入哈希集合中，以便实现 O(1) 的平均时间复杂度查找。然后遍历集合中的每个数，但只对那些**不是**序列中间值的数（即 `num - 1` 不在集合中的数）作为起点开始向后搜索，从而避免了对同一序列的重复计数，确保整体时间复杂度为 O(n)。

### 算法步骤
1.  **初始化**: 将 `nums` 数组中的所有元素存入一个 `unordered_set` 中，记为 `ms`。这不仅能去重，还能提供快速的查找功能。初始化一个结果变量 `res = 0`。
2.  **遍历**: 遍历哈希集合 `ms` 中的每一个元素 `it`。
3.  **寻找起点**: 对于每个元素 `it`，检查 `it - 1` 是否存在于 `ms` 中。
    *   如果 `it - 1` 存在，说明 `it` 不是一个连续序列的起点，直接跳过，继续下一个元素的判断。这是本算法的关键优化。
4.  **扩展序列**: 如果 `it - 1` **不**存在，说明 `it` 是一个连续序列的起点。从 `it + 1` 开始，不断在 `ms` 中检查下一个数是否存在，并累加长度。
5.  **计算长度与更新**: 当找到第一个不存在于 `ms` 中的数 `temp` 时，当前连续序列的长度就是 `temp - it`。用这个长度更新最大结果 `res`。
6.  **返回**: 遍历完整个哈希集合后，返回 `res`。

### 复杂度分析
- **时间复杂度**: O(N)
  *其中 N 是 `nums` 数组中元素的个数。将所有元素插入哈希集合的时间复杂度是 O(N)。外层循环会遍历每个元素一次。内层 `while` 循环虽然看起来可能导致高复杂度，但由于我们只从序列的起点开始扩展，每个数字最多被访问两次（一次在 `for` 循环中，一次在 `while` 循环中），因此总时间复杂度依然是 O(N)。*
- **空间复杂度**: O(N)
  *我们需要一个哈希集合来存储所有不重复的数字，在最坏情况下（所有数字都不同），空间复杂度为 O(N)。*

---

## 代码实现

```cpp
#include <vector>
#include <unordered_set>
#include <algorithm> // for std::max

class Solution {
public:
    int longestConsecutive(std::vector<int>& nums) {
        // 使用 nums 的元素初始化一个哈希集合，用于 O(1) 复杂度的查找
        std::unordered_set<int> ms(nums.begin(), nums.end());
        
        // 用于存储最长连续序列的长度
        int res = 0;
        
        // 遍历哈希集合中的每一个唯一的数
        for(auto& it : ms) {
            // 关键优化：检查当前数 a-1 是否存在于哈希集合中
            // 如果存在，说明当前数不是一个序列的起点，跳过以避免重复计算
            if(ms.find(it - 1) != ms.end()) {
                continue;
            }
            
            // 如果 a-1 不存在，说明 a 是一个连续序列的起点
            // 从 a+1 开始向右扩展，查找序列的终点
            int temp = it + 1;
            while(ms.find(temp) != ms.end()) {
                temp++;
            }
            
            // 此时，[it, temp) 是一个左闭右开的连续整数区间
            // 序列的长度即为 temp - it
            res = std::max(res, temp - it);
        }
        
        // 返回找到的最大长度
        return res;
    }
};
```