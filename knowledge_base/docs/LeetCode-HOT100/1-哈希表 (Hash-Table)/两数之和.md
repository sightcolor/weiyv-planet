# 两数之和

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/two-sum/)

---

## 题目描述

> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** `target` 的那 **两个** 整数，并返回它们的数组下标。
>
> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
>
> 你可以按任意顺序返回答案。
>
> **示例:**
> ```
> 输入: nums =, target = 9
> 输出:
> 解释: 因为 nums + nums == 9 ，返回 。
> ```

---

## 解题思路

### 核心思想
利用哈希表（`std::unordered_map`）来存储已经遍历过的数字及其索引。通过这种“空间换时间”的策略，将查找配对数的时间复杂度从 O(N) 降低到 O(1)，从而使总时间复杂度达到 O(N)。

### 算法步骤
1.  **初始化**: 创建一个空的 `unordered_map<int, int> mp`，用于存放 `{数值: 索引}` 的键值对。
2.  **遍历**: 循环遍历输入的 `nums` 数组，获取当前元素的索引 `i` 和值 `val`。
3.  **逻辑判断**: 在循环的每一步中，计算需要寻找的“另一半”数值 `target - val`。
    *   使用 `mp.find(target - val)` 检查这个“另一半”是否已经存在于哈希表中。
    *   如果 `find` 的结果不等于 `mp.end()`，说明找到了配对的数，立即返回包含“另一半”的索引 `mp[target - val]` 和当前索引 `i` 的向量。
4.  **数据更新**: 如果哈希表中不存在“另一半”，说明还未找到配对。将当前值 `val` 和其索引 `i` 存入哈希表 `mp` 中，供后续的查找使用。
5.  **返回**: 由于题目保证有解，循环必将找到答案并返回。若无解，则在循环结束后返回一个空向量 `{}`。

### 复杂度分析
- **时间复杂度**: O(N)
  *我们只需要单次遍历整个 `nums` 数组。对于每次遍历，`unordered_map` 的 `find` 和插入操作的平均时间复杂度均为 O(1)。因此，总时间复杂度为 O(N)。*
- **空间复杂度**: O(N)
  *在最坏的情况下，我们需要将数组中的所有 N 个元素都存入哈希表中。因此，所需的额外空间与数组大小成正比。*

---

## 代码实现

```cpp
#include <vector>
#include <unordered_map>

class Solution {
public:
    std::vector<int> twoSum(std::vector<int>& nums, int target) {
        // 获取数组的大小
        int n = nums.size();
        // 创建一个哈希表，用于存储<数值, 索引>
        std::unordered_map<int, int> mp;

        // 遍历数组中的每一个元素
        for(int i = 0; i < n; i++) {
            // 获取当前元素的值
            int val = nums[i];
            // 计算我们需要寻找的目标配对数 (complement)
            int complement = target - val;
            
            // 在哈希表中查找是否存在这个配对数
            // mp.find() 返回一个迭代器，如果找不到，它会等于 mp.end()
            if(mp.find(complement) != mp.end()) {
                // 如果找到了，说明配对成功
                // 返回配对数的索引 (存储在哈希表中) 和当前数的索引
                return {mp[complement], i};
            }
            
            // 如果没找到，将当前数的值和索引存入哈希表
            // 以便后续的元素进行配对查找
            mp[val] = i;
        }
        
        // 如果遍历完整个数组都没有找到答案 (根据题意不会发生)
        // 返回一个空向量
        return {};
    }
};

```