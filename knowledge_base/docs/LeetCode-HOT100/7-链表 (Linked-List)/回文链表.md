# 回文链表

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/palindrome-linked-list/)

---

## 题目描述

> 给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。
>
> **示例:**
> ```
> 输入：head = [1,2,2,1]
> 输出：true
> ```
> ```
> 输入：head = [1,2]
> 输出：false
> ```

---

## 解题思路

### 思路一：将链表转换为数组

#### 核心思想
最直观的方法是利用可以随机访问的数据结构（如数组）来辅助判断。我们可以先遍历一遍链表，将所有节点的值按顺序存入一个数组中。然后，我们就可以用双指针法轻松地检查这个数组是否是回文的。

#### 算法步骤
1.  **初始化**: 创建一个 `std::vector<int>`。
2.  **遍历链表并存储**: 从 `head` 开始遍历整个链表，将每个节点的 `val` 依次存入 `vector` 中。
3.  **双指针判断**: 在 `vector` 上使用双指针进行回文判断。
    *   初始化 `left = 0`, `right = values.size() - 1`。
    *   当 `left < right` 时，比较 `values[left]` 和 `values[right]`。
    *   如果不相等，则不是回文链表，返回 `false`。
    *   如果相等，则将指针向中间移动：`left++`, `right--`。
4.  **返回**: 如果循环正常结束，说明链表是回文的，返回 `true`。

*(注：您代码中的实现是遍历第二次链表，同时从数组尾部取值比较，思路是等价的。)*

#### 复杂度分析
- **时间复杂度**: O(N)
  *(遍历链表存入数组需要 O(N)，双指针判断数组需要 O(N)。总时间复杂度为 O(N)。)*
- **空间复杂度**: O(N)
  *(需要一个大小为 N 的数组来存储链表的所有值。)*

---

### 思路二：快慢指针 + 反转后半部分链表

#### 核心思想
为了实现 O(1) 的空间复杂度，我们不能使用额外的存储结构。可以采用以下三步策略：
1.  使用快慢指针找到链表的后半部分的起始点。
2.  将链表的后半部分原地反转。
3.  将前半部分和反转后的后半部分进行比较，判断是否为回文。

**重要提示**：此方法会修改原链表的结构。如果题目要求不能修改原链表，则需要在比较完成后，将反转的后半部分再次反转，以恢复原链表。

#### 算法步骤
1.  **找到链表中点**:
    *   使用快慢指针法。`slow` 指针每次走一步，`fast` 指针每次走两步。
    *   当 `fast` 指针到达链表末尾时，`slow` 指针正好位于链表的中点（或后半部分的第一个节点）。
2.  **反转后半部分**:
    *   从 `slow` 指针指向的节点开始，将链表的后半部分进行反转。可以采用迭代或递归的方式实现。
3.  **比较前后两半**:
    *   设置两个指针，一个指向原链表的 `head`，另一个指向反转后后半部分的头节点。
    *   同时遍历这两个部分，比较对应节点的值。
    *   一旦发现不匹配，立即返回 `false`。
4.  **返回**: 如果后半部分遍历结束都没有发现不匹配，说明链表是回文的，返回 `true`。
5.  **（可选）恢复链表**: 将反转后的后半部分再次反转，然后将其与前半部分的末尾连接起来，恢复原始链表结构。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(找中点 O(N)，反转后半部分 O(N/2)，比较 O(N/2)。总时间复杂度为 O(N)。)*
- **空间复杂度**: O(1)
  *(如果使用迭代法反转链表。在您的实现中，由于使用了 **递归反转**，递归调用栈会消耗 O(N) 的空间。)*

---

## 代码实现

### C++ (思路一：将链表转换为数组)

```cpp
#include <vector>

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        // 将链表值存入数组
        std::vector<int> values;
        ListNode* curr = head;
        while(curr) {
            values.push_back(curr->val);
            curr = curr->next;
        }
        
        // 使用双指针判断数组是否为回文
        int left = 0, right = values.size() - 1;
        while(left < right) {
            if(values[left] != values[right]) {
                return false;
            }
            left++;
            right--;
        }
        
        return true;
    }
};
```
### C++ (思路二：快慢指针 + 反转后半部分)


```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
private:
    // 快慢指针找中点：奇数个节点返回中点，偶数个返回后半部分第一个
    ListNode* findMid(ListNode* head) {
        ListNode* slow = head, *fast = head;
        while(fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }

    // 递归反转链表（注意：此实现空间复杂度为O(N)）
    ListNode* reverse(ListNode* head) {
        if(!head || !head->next) {
            return head;
        }
        ListNode* newHead = reverse(head->next);
        head->next->next = head;
        head->next = nullptr;
        return newHead;
    }

public:
    bool isPalindrome(ListNode* head) {
        if (!head) {
            return true;
        }

        // 1. 找到后半部分的起始节点
        ListNode* midNode = findMid(head);
        
        // 2. 反转后半部分链表
        ListNode* secondHalfHead = reverse(midNode);
        
        // 3. 比较前后两半
        ListNode* p1 = head;
        ListNode* p2 = secondHalfHead;
        bool result = true;
        while (result && p2) {
            if (p1->val != p2->val) {
                result = false;
            }
            p1 = p1->next;
            p2 = p2->next;
        }
        
        // (可选) 恢复链表，将后半部分再次反转
        // reverse(secondHalfHead);

        return result;
    }
};
```