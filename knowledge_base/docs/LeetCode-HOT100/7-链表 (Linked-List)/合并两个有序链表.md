# 合并两个有序链表

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/merge-two-sorted-lists/)

---

## 题目描述

> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的节点组成的。
>
> **示例:**
> ```
> 输入：list1 = [1,2,4], list2 = [1,3,4]
> 输出：[1,1,2,3,4,4]
> ```

---

## 解题思路

### 思路一：迭代法 (创建新链表)

#### 核心思想
这种方法不修改原始链表的结构，而是创建一个全新的链表来存放合并后的结果。我们同时遍历两个输入链表，比较当前节点的值，将较小值的节点**复制**一个新节点，并将其追加到新链表的末尾。

#### 算法步骤
1.  **处理边界情况**: 如果任意一个链表为空，直接返回另一个链表。
2.  **初始化新链表**: 比较 `list1` 和 `list2` 的头节点，创建一个新的头节点 `res`，其值为较小头节点的值。同时，将对应链表的指针向后移动一位。
3.  **创建尾指针**: 创建一个尾指针 `tail`，初始指向新链表的头节点 `res`。
4.  **遍历与合并**:
    *   当 `list1` 和 `list2` 都不为空时，循环比较它们当前节点的值。
    *   创建一个值为较小节点值的新节点。
    *   将这个新节点连接到 `tail->next`，然后将 `tail` 指针移动到这个新节点上。
    *   将提供较小值的那个链表的指针向后移动一位。
5.  **处理剩余部分**: 循环结束后，最多只有一个链表还有剩余节点。将这个剩余链表的所有节点依次复制并追加到新链表的末尾。
6.  **返回**: 返回新链表的头节点 `res`。

#### 复杂度分析
- **时间复杂度**: O(M + N)
  *(其中 M 和 N 分别是两个链表的长度。我们需要遍历两个链表的所有节点。)*
- **空间复杂度**: O(M + N)
  *(我们需要为结果链表创建 M+N 个新节点。)*

---

### 思路二：递归法 (原地合并)

#### 核心思想
递归的思路非常优雅。函数 `merge(l1, l2)` 的作用是合并 `l1` 和 `l2` 并返回合并后链表的头节点。这个大问题可以分解为：
1.  比较 `l1` 和 `l2` 的头节点值。
2.  假设 `l1` 的头节点值更小，那么它就是合并后链表的头。
3.  剩下的问题就变成了合并 `l1->next` 和 `l2`，我们将这个子问题的解（即 `merge(l1->next, l2)` 的返回值）连接到 `l1->next` 上。
4.  返回 `l1` 作为当前问题的解。

如果 `l2` 的头节点值更小，则同理。

#### 算法步骤
1.  **递归基 (Base Case)**: 如果 `list1` 或 `list2` 为 `nullptr`，说明已经没有节点需要合并，直接返回那个非空的链表（或 `nullptr`）。
2.  **递归过程**:
    *   比较 `list1->val` 和 `list2->val`。
    *   如果 `list1->val <= list2->val`，则 `list1` 是当前合并结果的头。它的下一个节点应该是 `list1->next` 和 `list2` 合并后的结果。所以，我们递归调用 `mergeTwoLists(list1->next, list2)`，并将其结果赋给 `list1->next`。然后返回 `list1`。
    *   否则，`list2` 是当前合并结果的头。同理，我们递归调用 `mergeTwoLists(list1, list2->next)`，将其结果赋给 `list2->next`，然后返回 `list2`。

#### 复杂度分析
- **时间复杂度**: O(M + N)
  *(每次递归调用处理一个节点，总共 M+N 个节点。)*
- **空间复杂度**: O(M + N)
  *(递归需要使用函数调用栈。栈的深度最多为两个链表长度之和。)*

---

## 代码实现

### C++ (思路一：迭代法，创建新链表)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 使用一个虚拟头节点（哨兵节点）可以简化代码
        ListNode* dummyHead = new ListNode(-1);
        ListNode* tail = dummyHead;

        while (list1 && list2) {
            if (list1->val < list2->val) {
                // 这里是原地修改，更高效。
                // 若要创建新链表，则是 tail->next = new ListNode(list1->val);
                tail->next = list1;
                list1 = list1->next;
            } else {
                tail->next = list2;
                list2 = list2->next;
            }
            tail = tail->next;
        }

        // 将剩余的链表部分直接连接上
        tail->next = list1 ? list1 : list2;

        ListNode* result = dummyHead->next;
        delete dummyHead; // 释放虚拟头节点
        return result;
    }
};
```
### C++ (思路二：递归法，原地合并)

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 递归基：当任意一个链表为空时，返回另一个
        if (!list1) return list2;
        if (!list2) return list1;
        
        // 比较头节点，确定谁是当前合并后的头
        if (list1->val < list2->val) {
            // list1的头更小，它的next应该和list2合并
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        } else {
            // list2的头更小或相等，它的next应该和list1合并
            list2->next = mergeTwoLists(list1, list2->next);
            return list2;
        }
    }
};
```