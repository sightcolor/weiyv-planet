# 两两交换链表中的节点

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/swap-nodes-in-pairs/)

---

## 题目描述

> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
>
> **示例:**
> ```
> 输入：head = [1,2,3,4]
> 输出：[2,1,4,3]
> ```
>
> ```
> 输入：head = []
> 输出：[]
> ```
>
> ```
> 输入：head = [1]
> 输出：[1]
> ```

---

## 解题思路

### 思路一：迭代法 (哨兵节点)

#### 核心思想
由于链表的头节点可能会被交换，使用一个**哨兵节点 (Dummy Node)**可以极大地简化边界情况的处理。我们以三个节点为一组进行操作：`node0` (待交换对的前一个节点)、`node1` 和 `node2` (待交换的两个节点)。通过调整这三个节点（以及 `node2` 的下一个节点 `node3`）的 `next` 指针，完成交换。

#### 算法步骤
1.  **初始化**:
    *   创建一个哨兵节点 `dummy`，使其 `next` 指向 `head`。
    *   创建一个指针 `node0` 指向 `dummy`，它将永远是待交换对的前一个节点。
2.  **循环交换**: 当 `node0` 的后面至少还有两个节点时 (`node0->next` 和 `node0->next->next` 存在)，进行循环。
3.  **定义节点**: 在循环内部，定义三个关键节点：
    *   `node1 = node0->next;` (第一个待交换节点)
    *   `node2 = node1->next;` (第二个待交换节点)
4.  **执行交换 (指针的舞蹈)**:
    *   `node0->next = node2;`   // 步骤1: node0 指向 node2
    *   `node1->next = node2->next;` // 步骤2: node1 指向 node2 原来的下一个节点
    *   `node2->next = node1;`   // 步骤3: node2 指向 node1
5.  **更新指针**: 完成交换后，`node1` 已经成为了交换后 pair 的第二个节点。为了处理下一对，我们将 `node0` 更新为 `node1`。
    *   `node0 = node1;`
6.  **返回**: 循环结束后，返回 `dummy.next`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是链表的节点数。我们只需要遍历链表一次。)*
- **空间复杂度**: O(1)
  *(只使用了固定的几个指针变量，与链表长度无关。)*

---

### 思路二：递归法

#### 核心思想
递归的精髓在于将大问题分解为性质相同的小问题。`swapPairs(head)` 的功能可以定义为：交换 `head` 和 `head->next`，并返回交换后的新头节点。
1.  我们先将 `head` 和 `head->next` 两个节点从链表中“分离”出来。
2.  剩下的子问题是 `swapPairs(head->next->next)`，即对链表的其余部分执行相同的两两交换操作。
3.  当子问题解决后（即递归调用返回了子链表交换后的新头节点），我们再将第1步中分离出的两个节点进行交换，并与子问题的结果连接起来。

#### 算法步骤
1.  **递归基 (Base Case)**: 如果链表为空（`!head`）或者只有一个节点（`!head->next`），说明没有节点对可供交换，直接返回 `head`。
2.  **定义节点**:
    *   `firstNode = head;`
    *   `secondNode = head->next;`
3.  **递归调用**: `firstNode` 的新 `next` 应该是对剩余链表 `secondNode->next` 进行交换后的结果。
    *   `firstNode->next = swapPairs(secondNode->next);`
4.  **执行交换**: 将 `secondNode` 的 `next` 指向 `firstNode`，完成当前这对节点的交换。
    *   `secondNode->next = firstNode;`
5.  **返回**: `secondNode` 已经成为了交换后这对节点的新头节点，将其返回给上一层调用。
    *   `return secondNode;`

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点都被访问一次。)*
- **空间复杂度**: O(N)
  *(递归需要使用函数调用栈，栈的深度在最坏情况下为 N/2。)*

---

## 代码实现

### C++ (思路一：迭代法)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
      // 使用哨兵节点简化头节点交换的逻辑
      ListNode dummy(0, head);
      ListNode* node0 = &dummy;
      
      while (node0->next && node0->next->next) {
        // 定义需要操作的节点
        ListNode* node1 = node0->next;
        ListNode* node2 = node1->next;

        // 执行交换
        node0->next = node2;
        node1->next = node2->next;
        node2->next = node1;

        // 为下一轮迭代更新 node0
        node0 = node1;
      }
      return dummy.next;
    }
};
```

### C++ (思路二：递归法)
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 递归基：没有节点或只有一个节点，无法交换
        if (!head || !head->next) {
          return head;
        }

        // 定义要交换的两个节点
        ListNode* firstNode = head;
        ListNode* secondNode = head->next;

        // 递归处理剩余部分，并连接到 firstNode 后面
        firstNode->next = swapPairs(secondNode->next);
        
        // 完成当前这对节点的交换
        secondNode->next = firstNode;
        
        // secondNode 是新的头节点，返回它
        return secondNode;
    }
};
```