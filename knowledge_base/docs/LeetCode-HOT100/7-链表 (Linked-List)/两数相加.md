# 两数相加

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/add-two-numbers/)

---

## 题目描述

> 给你两个 **非空** 的链表，表示两个非负整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。
>
> 请你将两个数相加，并以相同形式返回一个表示和的链表。
>
> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。
>
> **示例:**
> ```
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[7,0,8]
> 解释：342 + 465 = 807.
> ```

---

## 解题思路

### 思路一：迭代法 (模拟竖式加法)

#### 核心思想
这种方法模拟了我们上小学时列竖式做加法的过程。从最低位（链表头）开始，逐位相加，并处理进位。为了方便构建新的结果链表，我们通常使用一个“虚拟头节点”（或称哨兵节点），这样可以避免对第一个节点的特殊处理。

#### 算法步骤
1.  **初始化**: 创建一个虚拟头节点 `dummy`，一个 `curr` 指针指向 `dummy` 用于构建新链表。初始化进位 `carry = 0`。
2.  **循环**: 只要 `l1` 或 `l2` 还有节点，或者 `carry` 不为0，就继续循环。这个条件 `(l1 || l2 || carry)` 非常关键，它能确保处理完所有节点并且考虑到最后可能产生的进位。
3.  **计算当前位**:
    *   创建一个变量 `sum` 并初始化为当前的 `carry`。
    *   如果 `l1` 不为空，将 `l1->val` 加到 `sum` 中，并将 `l1` 指向下一个节点。
    *   如果 `l2` 不为空，将 `l2->val` 加到 `sum` 中，并将 `l2` 指向下一个节点。
4.  **创建新节点**:
    *   创建一个新节点，其值为 `sum % 10`（当前位的数字）。
    *   将这个新节点连接到 `curr->next`。
    *   将 `curr` 指针移动到新创建的节点上 (`curr = curr->next`)。
5.  **更新进位**: 更新 `carry` 的值为 `sum / 10`，供下一轮循环使用。
6.  **返回**: 循环结束后，真正的结果链表是 `dummy->next`。

#### 复杂度分析
- **时间复杂度**: O(max(M, N))
  *(其中 M 和 N 分别是两个链表的长度。循环次数取决于较长链表的长度。)*
- **空间复杂度**: O(max(M, N))
  *(返回的新链表的长度最多为 max(M, N) + 1。)*

---

### 思路二：递归法

#### 核心思想
递归解法将问题分解为“计算当前位的和并创建节点”以及“递归计算剩余位的和”。递归函数的状态需要包含两个链表的当前节点以及来自低位的进位。

#### 算法步骤
1.  **定义递归函数**: 定义一个辅助函数，如 `assist(l1, l2, carry)`，它返回 `l1`, `l2` 从当前节点开始加上 `carry` 后的结果链表。
2.  **递归基 (Base Case)**: 当 `l1` 和 `l2` 都为空，并且 `carry` 也为 0 时，说明加法过程已完全结束，返回 `nullptr`。
3.  **递归过程**:
    *   计算当前位的和 `sum`，等于 `carry` 加上 `l1` 和 `l2` 当前节点的值（如果节点存在）。
    *   创建一个新的节点，其值为 `sum % 10`。
    *   这个新节点的 `next` 指针应该指向 **下一位的递归计算结果**。因此，递归调用 `assist(l1->next, l2->next, sum / 10)`，并将其返回值赋给新节点的 `next`。
    *   返回新创建的节点。
4.  **初始调用**: 主函数中，调用 `assist(l1, l2, 0)` 开始递归过程。

#### 复杂度分析
- **时间复杂度**: O(max(M, N))
  *(递归的深度等于较长链表的长度。)*
- **空间复杂度**: O(max(M, N))
  *(递归调用栈的深度最大为 max(M, N)，同时还需要空间存储返回的新链表。)*

---

## 代码实现

### C++ (思路一：迭代法)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode dummy; // 虚拟头节点
        ListNode* curr = &dummy;
        int carry = 0;

        while (l1 || l2 || carry) {
            int sum = carry;
            if (l1) {
                sum += l1->val;
                l1 = l1->next;
            }
            if (l2) {
                sum += l2->val;
                l2 = l2->next;
            }
            curr->next = new ListNode(sum % 10);
            curr = curr->next;
            carry = sum / 10;
        }
        return dummy.next;
    }
};
```
### C++ (思路二：递归法)

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        return assist(l1, l2, 0);
    }
private:
    ListNode* assist(ListNode* l1, ListNode* l2, int carry) {
        // 递归基：两个链表都处理完且没有进位
        if (!l1 && !l2 && carry == 0) {
            return nullptr;
        }

        int sum = carry;
        ListNode* next_l1 = nullptr;
        ListNode* next_l2 = nullptr;

        if (l1) {
            sum += l1->val;
            next_l1 = l1->next;
        }
        if (l2) {
            sum += l2->val;
            next_l2 = l2->next;
        }
        
        // 创建当前节点，并递归构建后续链表
        ListNode* resultNode = new ListNode(sum % 10);
        resultNode->next = assist(next_l1, next_l2, sum / 10);
        
        return resultNode;
    }
};
```