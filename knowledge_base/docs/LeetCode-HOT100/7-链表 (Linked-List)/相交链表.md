# 相交链表

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

---

## 题目描述

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。
>
> 题目数据 **保证** 整个链式结构中不存在环。
> **注意**，函数返回结果后，链表必须 **保持其原始结构** 。
>
> **示例:**
> ```
> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
> 输出：Intersected at '8'
> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
> ```

---

## 解题思路

### 思路一：哈希集合

#### 核心思想
利用哈希集合（`unordered_set`）来存储一个链表的所有节点。由于相交的节点是同一个节点（内存地址相同），我们可以遍历第一个链表，将其所有节点的指针存入哈希集合。然后遍历第二个链表，检查当前节点是否存在于哈希集合中。第一个在集合中找到的节点就是相交的起始节点。

#### 算法步骤
1.  **初始化**: 创建一个哈希集合 `std::unordered_set<ListNode*>` 用于存储节点指针。
2.  **遍历链表A**: 从 `headA` 开始，遍历整个链表 A。将每个节点的指针（内存地址）插入到哈希集合中。
3.  **遍历链表B**: 从 `headB` 开始，遍历整个链表 B。
4.  **逻辑判断**: 在遍历 B 的过程中，对每个节点，检查它的指针是否存在于哈希集合中。
    *   如果存在（`set.find(node) != set.end()`），说明这个节点是第一个公共节点，即相交的起始点。立即返回该节点。
5.  **返回**: 如果遍历完链表 B 仍然没有找到任何存在于哈希集合中的节点，说明两个链表不相交，返回 `nullptr`。

#### 复杂度分析
- **时间复杂度**: O(M + N)
  *(其中 M 和 N 分别是两个链表的长度。需要遍历链表A一次（O(M)），遍历链表B一次（O(N)）。)*
- **空间复杂度**: O(M)
  *(哈希集合需要存储链表 A 的所有 M 个节点指针。)*

---

### 思路二：双指针法

#### 核心思想
这是一种非常巧妙的方法，空间复杂度为 O(1)。
想象一下，如果两个链表长度相同，那么让两个指针 `pA` 和 `pB` 同时从头节点出发，它们会同时到达相交节点。
但链表长度通常不同。我们可以通过一种方式让两个指针走过相同的路程：当一个指针走完自己的链表后，就去走另一个链表的路。

设链表 A 的独有部分长度为 `a`，链表 B 的独有部分长度为 `b`，公共部分长度为 `c`。
*   指针 `pA` 的路径：`a -> c -> b`
*   指针 `pB` 的路径：`b -> c -> a`

当它们走完 `a+c+b` 和 `b+c+a` 的路程后，它们就会在相交点相遇。如果两个链表不相交，那么 `c=0`，它们最终会同时到达终点 `nullptr`。

#### 算法步骤
1.  **初始化**: 创建两个指针，`pA` 指向 `headA`，`pB` 指向 `headB`。
2.  **循环**: 进入一个循环，条件是 `pA != pB`。
3.  **指针移动**:
    *   `pA` 向前移动一步。如果 `pA` 到达链表 A 的末尾（即 `pA` 为 `nullptr`），则将 `pA` 指向 `headB`。否则，`pA = pA->next`。
    *   `pB` 向前移动一步。如果 `pB` 到达链表 B 的末尾（即 `pB` 为 `nullptr`），则将 `pB` 指向 `headA`。否则，`pB = pB->next`。
4.  **返回**: 循环结束时，`pA` 和 `pB` 相等。这个值要么是相交节点，要么是 `nullptr`（两个链表不相交的情况）。直接返回 `pA` (或 `pB`)。

#### 复杂度分析
- **时间复杂度**: O(M + N)
  *(在最坏情况下（无交点或交点在末尾），每个指针都将遍历两个链表的总长度。)*
- **空间复杂度**: O(1)
  *(只使用了两个额外的指针，与输入大小无关。)*

---

## 代码实现

### C++ (思路一：哈希集合)

```cpp
#include <unordered_set>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        // 使用哈希集合存储链表A的所有节点
        std::unordered_set<ListNode*> visited;
        ListNode* curr = headA;
        while(curr) {
            visited.insert(curr);
            curr = curr->next;
        }
        
        // 遍历链表B，查找第一个出现在哈希集合中的节点
        curr = headB;
        while(curr) {
            if(visited.count(curr)) {
                return curr;
            }
            curr = curr->next;
        }
        
        return nullptr;
    }
};
```
### C++ (思路二：双指针法)
``` cpp
// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        // 空间复杂度 O(1) 的双指针解法
        if (!headA || !headB) {
            return nullptr;
        }
        
        ListNode *pA = headA, *pB = headB;
        
        // 当 pA 和 pB 不相等时，继续循环
        // pA走完自己的路，就去走pB的路；pB同理
        // a+c+b = b+c+a, 最终会在交点相遇
        while(pA != pB) {
            pA = pA ? pA->next : headB;
            pB = pB ? pB->next : headA;
        }
        
        // 返回相遇点（交点或nullptr）
        return pA;
    }
};
```