# 复制带随机指针的链表

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/copy-list-with-random-pointer/)

---

## 题目描述

> 给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或 `null`。
>
> 构造这个链表的 **深拷贝**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。
>
> **示例:**
> ```
> 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
> 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
> ```

---

## 解题思路

### 思路一：哈希表映射

#### 核心思想
这个问题的核心难点在于，当我们复制一个节点时，它的 `random` 指针指向的节点可能还没被创建，我们无法直接设置新节点的 `random` 指针。

哈希表提供了一个完美的解决方案。我们可以用一个哈希表来存储 **“旧节点 -> 新节点”** 的映射关系。整个过程分两步：
1.  **创建节点并建立映射**：遍历一遍原链表，为每个旧节点创建一个对应的新节点，并将这个映射关系 `(旧节点, 新节点)` 存入哈希表中。
2.  **连接指针**: 再次遍历原链表，这次我们来设置新节点的 `next` 和 `random` 指针。对于任意一个旧节点 `old_node`，它的新节点是 `new_node = map[old_node]`。那么：
    *   `new_node` 的 `next` 就应该是 `map[old_node->next]`。
    *   `new_node` 的 `random` 就应该是 `map[old_node->random]`。

通过哈希表这个“桥梁”，我们可以轻松地从任何一个旧节点找到其对应的新节点。

#### 算法步骤
1.  **初始化**: 创建一个哈希表 `std::unordered_map<Node*, Node*>`。处理 `head` 为空的边界情况。
2.  **第一遍遍历 (创建节点)**:
    *   从 `head` 开始遍历原链表。
    *   对每个节点 `curr`，创建一个新节点 `new Node(curr->val)`。
    *   将映射关系存入哈希表：`map[curr] = 新节点`。
3.  **第二遍遍历 (连接指针)**:
    *   再次从 `head` 开始遍历原链表。
    *   对每个节点 `curr`，通过哈希表找到对应的新节点 `map[curr]`。
    *   设置指针：`map[curr]->next = map[curr->next]` 和 `map[curr]->random = map[curr->random]`。
4.  **返回**: 返回新链表的头节点，即 `map[head]`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(需要两次遍历链表，每次遍历都是 O(N)。)*
- **空间复杂度**: O(N)
  *(哈希表需要存储 N 个节点的映射关系。)*

---

### 思路二：节点拆分 (O(1) 空间)

#### 核心思想
这是一种非常巧妙的、不需要额外存储空间的方法。它通过修改原链表的结构来完成复制，最后再恢复原样。过程分为三步：

1.  **复制并交织**: 遍历原链表，对每个节点 `A`，复制一个新节点 `A'`，并将其插入到 `A` 的后面。形成 `A -> A' -> B -> B' -> C -> C' -> ...` 的交织链表。
2.  **设置 random 指针**: 再次遍历这个交织链表。对于任意一个原节点 `A`，它的 `random` 指针指向 `X`。那么其对应的复制节点 `A'` 的 `random` 指针就应该指向 `X'`。在交织链表中，`A'` 就是 `A->next`，`X'` 就是 `X->next`。所以，我们只需执行 `A->next->random = A->random->next`。
3.  **拆分链表**: 最后，将这个交织链表拆分成两个独立的链表：一个恢复成原链表，另一个是完整的复制链表。

#### 算法步骤
1.  **复制并交织**:
    *   遍历原链表，对于每个节点 `curr`，创建新节点 `copy = new Node(curr->val)`。
    *   执行 `copy->next = curr->next;` 和 `curr->next = copy;`，将 `copy` 插入到 `curr` 后面。
2.  **设置 random 指针**:
    *   再次遍历，但每次跳两步 (`curr = curr->next->next;`)。
    *   如果 `curr->random` 存在，则设置 `curr->next->random = curr->random->next;`。
3.  **拆分链表**:
    *   创建新链表的虚拟头节点 `dummy`。
    *   遍历交织链表，将新旧节点分离出来，重新连接成两个链表。
4.  **返回**: 返回新链表的头 `dummy->next`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(总共需要三趟遍历，每趟都是 O(N)。)*
- **空间复杂度**: O(1)
  *(除了为新链表本身分配的空间外，没有使用额外的与 N 相关的存储空间。)*

---

## 代码实现

### C++ (思路一：哈希表映射)

```cpp
#include <unordered_map>

/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;

        std::unordered_map<Node*, Node*> map;
        Node* curr = head;

        // 1. 第一遍遍历：创建所有新节点，并建立映射
        while (curr) {
            map[curr] = new Node(curr->val);
            curr = curr->next;
        }

        // 2. 第二遍遍历：连接新节点的 next 和 random 指针
        curr = head;
        while (curr) {
            // map[nullptr] 会得到 nullptr，所以无需特殊处理
            map[curr]->next = map[curr->next];
            map[curr]->random = map[curr->random];
            curr = curr->next;
        }

        // 3. 返回新链表的头节点
        return map[head];
    }
};
```

### C++ (思路二：节点拆分 O(1) 空间)

```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if (!head) return nullptr;

        // 1. 复制并交织：A -> A' -> B -> B'
        for (Node* curr = head; curr != nullptr; curr = curr->next->next) {
            Node* copy = new Node(curr->val);
            copy->next = curr->next;
            curr->next = copy;
        }

        // 2. 设置 random 指针
        for (Node* curr = head; curr != nullptr; curr = curr->next->next) {
            if (curr->random) {
                curr->next->random = curr->random->next;
            }
        }

        // 3. 拆分链表
        Node* dummy = new Node(0);
        Node* tail = dummy;
        for (Node* curr = head; curr != nullptr; curr = curr->next) {
            tail->next = curr->next;      // 连接新节点
            tail = tail->next;            // 移动新链表的尾指针
            curr->next = tail->next;      // 恢复原链表
        }
        
        return dummy->next;
    }
};
```