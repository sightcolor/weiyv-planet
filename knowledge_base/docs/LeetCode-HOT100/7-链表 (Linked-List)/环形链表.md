# 环形链表

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/linked-list-cycle/)

---

## 题目描述

> 给你一个链表的头节点 `head` ，判断链表中是否有环。
>
> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**`pos` 不作为参数进行传递**。仅仅是为了标识链表的实际情况。
>
> **如果链表中存在环**，则返回 `true` 。否则，返回 `false` 。
>
> **示例:**
> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：true
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```

---

## 解题思路

### 核心思想
**快慢指针 (Floyd's Tortoise and Hare Algorithm)**

这个问题的经典解法是使用两个指针，一个“慢”指针和一个“快”指针，来遍历链表。可以把这个过程想象成在一条环形跑道上赛跑：

*   **慢指针 (Tortoise)**: 每次向前移动一个节点。
*   **快指针 (Hare)**: 每次向前移动两个节点。

如果链表中**不存在环**，那么快指针最终会到达链表的末尾（`nullptr`），比赛结束。
如果链表中**存在环**，那么快指针会进入环并不断地在环内“兜圈”。由于快指针比慢指针走得快，它最终必然会从后面“追上”慢指针，两个指针会在环中的某个位置相遇。

因此，我们只需要判断快慢指针是否会相遇，就可以确定链表是否有环。

### 算法步骤
1.  **处理边界情况**: 如果链表为空（`!head`）或只有一个节点（`!head->next`），则不可能形成环，直接返回 `false`。
2.  **初始化**: 创建 `slow` 和 `fast` 两个指针，都指向链表的头节点 `head`。
3.  **遍历**: 进入一个循环，循环条件是 `fast` 指针和 `fast->next` 指针都不能为 `nullptr`（这是为了保证 `fast->next->next` 的访问是安全的）。
4.  **移动指针**: 在循环内部，先移动指针：
    *   `slow = slow->next;`
    *   `fast = fast->next->next;`
5.  **逻辑判断**: 移动之后，判断 `slow` 和 `fast` 是否指向同一个节点 (`slow == fast`)。
    *   如果相等，说明快指针追上了慢指针，链表中存在环，返回 `true`。
6.  **返回**: 如果循环正常结束（即 `fast` 或 `fast->next` 变成了 `nullptr`），说明快指针到达了链表末尾，链表无环，返回 `false`。

### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是链表的节点数。在无环情况下，快指针遍历链表。在有环情况下，慢指针入环前走了 a 步，快指针追上慢指针最多在环内走一圈，总步数也是线性的。)*
- **空间复杂度**: O(1)
  *(我们只使用了 `slow` 和 `fast` 两个额外的指针，与链表长度无关。)*

---

## 代码实现

### C++ (快慢指针法)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // 边界情况：空链表或单节点链表不可能有环
        if (!head || !head->next) {
            return false;
        }

        ListNode* slow = head;
        ListNode* fast = head;

        // 只要快指针没有走到终点，就继续循环
        // fast->next的判断是为了保证 fast->next->next 不会出错
        while (fast != nullptr && fast->next != nullptr) {
            // 慢指针走一步
            slow = slow->next;
            // 快指针走两步
            fast = fast->next->next;

            // 如果快慢指针相遇，则说明有环
            if (slow == fast) {
                return true;
            }
        }

        // 如果循环结束，说明快指针走到了链表末尾，无环
        return false;
    }
};
```