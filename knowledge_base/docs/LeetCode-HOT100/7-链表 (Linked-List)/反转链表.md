# 反转链表

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/reverse-linked-list/)

---

## 题目描述

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
>
> **示例:**
> ```
> 输入：head = [1,2,3,4,5]
> 输出：[5,4,3,2,1]
> ```
>
> ```
> 输入：head = [1,2]
> 输出：[2,1]
> ```

---

## 解题思路

### 思路一：迭代 (双指针法)

#### 核心思想
使用两个指针，一个 `prev` 指向前一个节点，一个 `curr` 指向当前节点。在遍历链表的过程中，不断地将 `curr` 节点的 `next` 指针指向 `prev` 节点，然后同时将 `prev` 和 `curr` 向后移动，从而实现链表的原地反转。

#### 算法步骤
1.  **初始化**: 创建一个 `prev` 指针，初始化为 `nullptr`（它将是反转后链表的尾节点）。创建一个 `curr` 指针，初始化为 `head`。
2.  **遍历**: 当 `curr` 指针不为 `nullptr` 时，循环执行以下操作。
3.  **保存下一个节点**: 因为我们要修改 `curr->next` 的指向，所以需要先用一个临时指针 `next_temp` 保存 `curr` 的原始下一个节点（`next_temp = curr->next`）。
4.  **反转指针**: 将当前节点 `curr` 的 `next` 指针指向前一个节点 `prev`（`curr->next = prev`）。
5.  **移动指针**: 将 `prev` 和 `curr` 指针向后移动。`prev` 移动到当前位置（`prev = curr`），`curr` 移动到之前保存的下一个节点位置（`curr = next_temp`）。
6.  **返回**: 循环结束后，`curr` 会变为 `nullptr`，而 `prev` 会指向原链表的最后一个节点，也就是新链表的头节点。返回 `prev`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(其中 N 是链表的节点数。我们只需要遍历链表一次。)*
- **空间复杂度**: O(1)
  *(我们只使用了固定的几个指针变量，与链表长度无关。)*

---

### 思路二：递归

#### 核心思想
递归的本质是把问题分解为规模更小的子问题。`reverseList(head)` 的功能是“反转从 `head` 开始的链表，并返回反转后的新头节点”。
那么，`reverseList(head)` 可以分解为：
1.  先去用 `reverseList(head->next)` 反转除了头节点 `head` 之外的剩余部分。
2.  拿到反转后的新头节点 `newHead`（也就是原链表的尾节点）。
3.  此时，`head->next` 节点（原链表的第二个节点）已经变成了反转后链表的尾巴。我们只需要将它的 `next` 指针指向 `head`，再将 `head` 的 `next` 指针置为 `nullptr`，就完成了 `head` 节点的反转。

#### 算法步骤
1.  **递归基（Base Case）**: 如果链表为空（`!head`）或者只有一个节点（`!head->next`），那么它本身就是反转后的结果，直接返回 `head`。
2.  **递归调用**: 调用 `reverseList(head->next)`，得到反转后的子链表的头节点 `newHead`。这个 `newHead` 将是最终要返回的结果，所以需要一直传递下去。
3.  **处理当前节点**: 在递归“归”的过程中，执行以下操作：
    *   `head->next->next = head;`：`head->next` 是反转后子链表的尾节点，让它的 `next` 指向当前 `head`，完成反转。
    *   `head->next = nullptr;`：断开 `head` 与原来下一个节点的连接，避免形成环。`head` 现在是新链表的尾部。
4.  **返回**: 返回 `newHead`，将其一路传递到递归的最外层。

#### 复杂度分析
- **时间复杂度**: O(N)
  *(每个节点都被访问一次。)*
- **空间复杂度**: O(N)
  *(递归需要使用调用栈，栈的深度在最坏情况下（链表完全不分叉）为 N。)*

---

## 代码实现

### C++ (思路一：迭代)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) {
            ListNode* next_temp = curr->next; // 1. 保存下一个节点
            curr->next = prev;              // 2. 反转指针
            prev = curr;                    // 3. 移动prev
            curr = next_temp;               // 4. 移动curr
        }
        // 当curr为nullptr时，prev就是新的头节点
        return prev;
    }
};
```


### C++ (思路二：递归)
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 1. 递归基：空链表或只有一个节点
        if (!head || !head->next) {
            return head;
        }
        
        // 2. 递归调用，反转剩余部分，并得到新头节点
        ListNode* newHead = reverseList(head->next);
        
        // 3. 处理当前节点
        head->next->next = head;
        head->next = nullptr;
        
        // 4. 返回新头节点
        return newHead;
    }
};
```