# 排序链表

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/sort-list/)

---

## 题目描述

> 给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。
>
> **进阶：** 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下解决这个问题吗？
>
> **示例:**
> ```
> 输入：head = [4,2,1,3]
> 输出：[1,2,3,4]
> ```
>
> ```
> 输入：head = [-1,5,3,4,0]
> 输出：[-1,0,3,4,5]
> ```

---

## 解题思路

### 核心思想
**归并排序 (Merge Sort)**

对于链表这种数据结构，由于其节点在内存中不连续，无法像数组一样进行随机访问，因此像快速排序这类需要频繁随机访问的算法实现起来较为复杂且效率不高。而 **归并排序** 是一种基于“分治”思想的算法，它只需要顺序访问节点，非常适合链表。

整个过程遵循归并排序的三大步骤：

1.  **分割 (Divide)**: 找到链表的中间节点，将链表从中间断开，分成两个长度大致相等的子链表。
2.  **征服 (Conquer)**: 对这两个子链表分别进行递归调用，继续分割，直到子链表只剩一个或零个节点（此时可认为其已有序）。
3.  **合并 (Combine)**: 将两个已经排好序的子链表合并成一个大的有序链表。

### 算法步骤
1.  **定义递归函数 `sortList(head)`**:
    *   **递归基 (Base Case)**: 如果链表为空或只有一个节点 (`!head || !head->next`)，说明它已经有序，直接返回 `head`。

2.  **分割 (Divide)**:
    *   使用 **快慢指针** 找到链表的中间节点。`slow` 指针每次走一步，`fast` 指针每次走两步。当 `fast` 到达链表末尾时，`slow` 正好在中间位置。
    *   为了将链表断开，需要一个 `prev` 指针记录 `slow` 的前一个节点。找到中点后，执行 `prev->next = nullptr`，将原链表一分为二。
    *   `findMid` 函数负责完成这一步，并返回后半段链表的头节点。

3.  **征服 (Conquer)**:
    *   递归地对两个子链表进行排序：
        *   `sorted_left = sortList(head)` (前半段)
        *   `sorted_right = sortList(mid)` (后半段)

4.  **合并 (Combine)**:
    *   调用一个辅助函数 `mergeTwoLists` (即“合并两个有序链表”)，将 `sorted_left` 和 `sorted_right` 这两个已排序的子链表合并成一个完整的有序链表。
    *   返回合并后的链表头节点。

### 复杂度分析
- **时间复杂度**: O(N logN)
  *(分割链表需要 O(N) 的时间，这个过程在递归中重复了 `logN` 次。合并操作在每一层递归中都需要处理所有 N 个节点，总共 `logN` 层。因此总时间为 O(N logN)。)*
- **空间复杂度**: O(logN)
  *(这是递归调用栈所占用的空间。递归树的深度为 `logN`。)*

---

## 代码实现

### C++ (归并排序递归法)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        // 递归终止条件：链表为空或只有一个节点
        if (!head || !head->next) {
            return head;
        }
        
        // 1. 分割：找到中点并断开链表
        ListNode* mid = findMidAndCut(head);
        
        // 2. 征服：递归排序左右两部分
        ListNode* left_sorted = sortList(head);
        ListNode* right_sorted = sortList(mid);
        
        // 3. 合并：合并已排序的两部分
        return mergeTwoLists(left_sorted, right_sorted);
    }

private:
    // 辅助函数：找到中间节点并从中断开，返回后半部分的头节点
    ListNode* findMidAndCut(ListNode* head) {
        if (!head) return nullptr;
        
        ListNode* slow = head;
        ListNode* fast = head;
        ListNode* prev = nullptr; // 用来记录slow的前一个节点
        
        while (fast && fast->next) {
            prev = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        
        // 从中间断开链表
        if (prev) {
            prev->next = nullptr;
        }
        
        return slow; // slow 是后半部分的头
    }

    // 辅助函数：合并两个有序链表
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (!l1) return l2;
        if (!l2) return l1;
        
        if (l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        } else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
};
```