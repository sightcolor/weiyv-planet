# 除自身以外数组的乘积

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/product-of-array-except-self/)

---

## 题目描述

> 给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。
>
> 题目数据 **保证** 数组 `nums` 中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。
>
> 请**不要使用除法**，且在 O(n) 时间复杂度内完成此题。
>
> **示例:**
> ```
> 输入: nums = nums = [1,2,3,4]
> 输出: [24,12,8,6]
> ```

---

## 解题思路

### 核心思想
采用**前后缀乘积**的思路。对于数组中的任意一个位置 `i`，它对应的结果 `answer[i]` 实际上等于它**左边所有元素的乘积**乘以它**右边所有元素的乘积**。

我们可以通过两次遍历来分别计算出每个位置的前缀积和后缀积。

### 算法步骤
1.  **初始化**:
    *   创建三个与 `nums` 等长的数组：`left` 用于存储前缀积，`right` 用于存储后缀积，`res` 用于存放最终结果。
    *   将 `left` 和 `right` 数组的所有元素初始化为 `1`。
2.  **计算前缀积**:
    *   遍历 `nums` 数组，从第二个元素开始（索引 `i = 1`）。
    *   对于每个位置 `i`，其前缀积 `left[i]` 等于其前一个位置的前缀积 `left[i-1]` 乘以 `nums[i-1]`。
    *   （您的代码通过 `factor` 变量实现了同样的效果）
3.  **计算后缀积**:
    *   从右向左遍历 `nums` 数组，从倒数第二个元素开始（索引 `i = n - 2`）。
    *   对于每个位置 `i`，其后缀积 `right[i]` 等于其后一个位置的后缀积 `right[i+1]` 乘以 `nums[i+1]`。
4.  **合并结果**:
    *   再次遍历数组，从 `i = 0` 到 `n - 1`。
    *   对于每个位置 `i`，最终结果 `res[i]` 就是 `left[i] * right[i]`。
5.  **返回**: 返回 `res` 数组。

### 复杂度分析
- **时间复杂度**: O(N)
  *需要三次独立的线性遍历（计算前缀积、计算后缀积、合并结果），总时间复杂度为 O(N)。*
- **空间复杂度**: O(N)
  *需要两个额外的数组 `left` 和 `right` 来存储前后缀乘积。*

*(**进阶**：这个问题可以将空间复杂度优化到 O(1)，通过在结果数组 `res` 上直接进行两次遍历，一次计算前缀积，一次计算后缀积并与已存入的前缀积相乘。)*

---

## 代码实现

```cpp
#include <vector>

class Solution {
public:
    std::vector<int> productExceptSelf(std::vector<int>& nums) {
        int n = nums.size();
        
        // left[i] 存储 nums[i] 左侧所有元素的乘积
        std::vector<int> left(n, 1);
        // right[i] 存储 nums[i] 右侧所有元素的乘积
        std::vector<int> right(n, 1);
        
        // 1. 计算前缀积
        // left 从左到右累乘
        for(int i = 1; i < n; i++) {
            left[i] = left[i - 1] * nums[i - 1];
        }
        
        // 2. 计算后缀积
        // right 从右到左累乘
        for(int i = n - 2; i >= 0; i--) {
            right[i] = right[i + 1] * nums[i + 1];
        }
        
        // 3. 合并结果
        std::vector<int> res(n);
        for(int i = 0; i < n; i++) {
            // 最终结果是前缀积乘以后缀积
            res[i] = left[i] * right[i];
        }
        
        return res;
    }
};
```