# 合并区间

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/merge-intervals/)

---

## 题目描述

> 以数组 `intervals` 表示若干个区间的集合，其中 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。
>
> **示例:**
> ```
> 输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出: [[1,6],[8,10],[15,18]]
> 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> ```

---

## 解题思路

### 核心思想
首先对所有区间按照**左边界**进行升序排序。排序后，能够合并的区间必然是连续的。然后遍历排序后的区间，维护一个当前正在合并的区间 `[l, r]`，并与下一个区间进行比较，判断是合并还是开启一个新的合并区间。

### 算法步骤
1.  **排序**: 对 `intervals` 数组进行排序。排序的依据是每个区间的左边界 `intervals[i][0]`。
2.  **初始化**:
    *   创建一个结果向量 `res` 用于存放合并后的区间。
    *   如果输入为空，直接返回 `res`。
    *   将第一个区间作为初始的合并区间，即 `l = intervals[0][0]`, `r = intervals[0][1]`。
3.  **遍历与合并**: 从第二个区间开始遍历排序后的 `intervals` 数组。
    *   对于当前遍历到的区间 `it`，其左边界为 `it[0]`，右边界为 `it[1]`。
    *   **判断是否重叠**: 检查 `it[0]` 是否小于等于当前合并区间的右边界 `r`。
        *   **如果重叠** (`it[0] <= r`)，说明可以将 `it` 与当前区间合并。更新当前合并区间的右边界为 `r = max(r, it[1])`，取两者中更远的右边界。
        *   **如果不重叠** (`it[0] > r`)，说明遇到了一个新的、无交集的区间。此时，将之前合并好的区间 `{l, r}` 存入结果 `res` 中。然后，更新 `l` 和 `r` 为当前区间 `it` 的左右边界，开启一个新的合并过程。
4.  **处理最后一个区间**: 遍历结束后，最后一个正在合并的区间 `{l, r}` 尚未存入 `res`，需要手动将其加入。
5.  **返回**: 返回结果 `res`。

### 复杂度分析
- **时间复杂度**: O(N log N)
  *其中 N 是区间的数量。主要的时间开销在于对区间的排序。*
- **空间复杂度**: O(log N) 或 O(N)
  *取决于排序算法所使用的额外空间。如果原地排序，空间复杂度为 O(log N)。结果数组 `res` 的空间不计入额外空间复杂度。*

---

## 代码实现

```cpp
#include <vector>
#include <algorithm>

class Solution {
public:
    std::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) {
        if (intervals.empty()) {
            return {};
        }

        // 1. 按区间的左边界进行排序
        sort(intervals.begin(), intervals.end());

        std::vector<std::vector<int>> res;
        // 初始化第一个合并区间
        int l = intervals, r = intervals;

        // 2. 从第二个区间开始遍历
        for (size_t i = 1; i < intervals.size(); ++i) {
            auto& it = intervals[i];
            
            // 3. 判断是否可以合并
            // 如果当前区间的左边界小于等于上一个合并区间的右边界
            if (it <= r) {
                // 合并区间，更新右边界为两者中的最大值
                r = std::max(r, it);
            } else {
                // 出现间隙，无法合并
                // 将上一个合并好的区间存入结果
                res.push_back({l, r});
                // 开启一个新的合并区间
                l = it;
                r = it;
            }
        }

        // 4. 将最后一个正在合并的区间加入结果
        res.push_back({l, r});
        
        return res;
    }
};
```