# 缺失的第一个正数

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/first-missing-positive/)

---

## 题目描述

> 给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。
>
> 请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。
>
> **示例:**
> ```
> 输入: nums = [1,2,0]
> 输出: 3
> 解释：范围 [1,2] 中的数字都在数组中。
> ```

---

## 解题思路

### 核心思想
采用**原地哈希**（或称“萝卜坑”/“座位交换”）的策略。题目的关键在于，对于一个长度为 `n` 的数组，它所缺失的第一个正整数必然在 `[1, n+1]` 的范围内。

我们可以利用数组本身作为哈希表，尝试将数字 `x` 放到它“应该在”的位置，即索引 `x-1` 上。例如，数字 `1` 应该放在索引 `0`，数字 `2` 应该放在索引 `1`，以此类推。

### 算法步骤
1.  **原地交换**:
    *   遍历数组，索引为 `i` 从 `0` 到 `n-1`。
    *   对于当前位置的数字 `nums[i]`，进入一个 `while` 循环，循环条件是：
        1.  `nums[i]` 是一个在 `[1, n]` 范围内的正整数（其他数字如负数、0、或大于n的数都是“无用的”，我们不关心它们的位置）。
        2.  `nums[i]` **没有**在它正确的位置上（即 `nums[i] != i + 1`）。
    *   在 `while` 循环中，我们尝试将 `nums[i]` 换到它的目标位置 `pos = nums[i] - 1`。
        *   **去重判断**：在交换前，必须检查目标位置 `pos` 上的数 `nums[pos]` 是否已经等于 `nums[i]`。如果相等，说明遇到了重复数字，必须 `break` 循环，否则会陷入无限交换。
        *   执行交换 `swap(nums[i], nums[pos])`。交换后，新的 `nums[i]` 还需要继续进行 `while` 循环的判断，直到当前位置 `i` 的数不再满足循环条件为止。

2.  **查找答案**:
    *   完成原地交换后，再次遍历数组，从 `i = 0` 到 `n-1`。
    *   找到第一个 `nums[i] != i + 1` 的位置，那么 `i + 1` 就是缺失的第一个正整数，直接返回。

3.  **处理特殊情况**:
    *   如果遍历完整个数组，发现 `[1, n]` 都各就各位了（即 `nums[i] == i + 1` 对所有 `i` 都成立），那么缺失的第一个正整数就是 `n + 1`。

### 复杂度分析
- **时间复杂度**: O(N)
  *虽然代码中有 `while` 循环嵌套在 `for` 循环中，但每个数字最多被交换一次就会被放到它正确的位置上。因此，总的交换次数不会超过 N 次，总时间复杂度是线性的。*
- **空间复杂度**: O(1)
  *所有操作都在原数组上进行，没有使用额外的数组空间。*

---

## 代码实现

```cpp
#include <vector>
#include <algorithm> // for std::swap

class Solution {
public:
    int firstMissingPositive(std::vector<int>& nums) {
        int n = nums.size();

        // 1. 原地哈希：将数字放到它对应的索引位置上
        for(int i = 0; i < n; i++) {
            // 当 nums[i] 在 [1, n] 范围内，且没有在正确的位置上时，进行交换
            while(nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]) {
                // 将 nums[i] 换到它应该在的位置 nums[i] - 1
                std::swap(nums[i], nums[nums[i] - 1]);
            }
        }

        // 2. 查找答案：找到第一个不满足 nums[i] == i + 1 的位置
        for(int i = 0; i < n; i++) {
            if(nums[i] != i + 1) {
                // i + 1 就是缺失的第一个正整数
                return i + 1;
            }
        }

        // 3. 如果 [1, n] 都存在，那么缺失的就是 n + 1
        return n + 1;
    }
};
```