# 轮转数组

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/rotate-array/)

---

## 题目描述

> 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。
>
> **示例:**
> ```
> 输入: nums = [1,2,3,4,5,6,7], k = 3
> 输出: [5,6,7,1,2,3,4]
> 解释:
> 向右轮转 1 步: [7,1,2,3,4,5,6]
> 向右轮转 2 步: [6,7,1,2,3,4,5]
> 向右轮转 3 步: [5,6,7,1,2,3,4]
> ```

---

## 解题思路

### 解法一：开辟新数组

#### 核心思想
这是最直观的解法。创建一个与原数组等大的新数组 `res`。然后遍历原数组 `nums`，将每个元素 `nums[i]` 直接放到它轮转 `k` 步后应该在的新位置上。新位置的计算公式为 `(i + k) % n`，其中 `n` 是数组长度，取模是为了处理超出数组边界的情况。

#### 算法步骤
1.  **初始化**: 创建一个与 `nums` 等大的新数组 `res`。
2.  **遍历计算**: 遍历 `nums` 数组，从索引 `i = 0` 到 `n - 1`。
3.  **放置元素**: 将 `nums[i]` 放入新数组 `res` 的 `(i + k) % n` 位置上。
4.  **复制回原数组**: 遍历结束后，将新数组 `res` 的内容复制回原数组 `nums`。
5.  **返回**。

#### 复杂度分析
- **时间复杂度**: O(N)
  *需要遍历数组一次来填充新数组，再遍历一次将新数组复制回来。*
- **空间复杂度**: O(N)
  *需要一个额外的新数组来存储结果。*

---

### 解法二：原地变换（三次翻转）

#### 核心思想
这是一种空间复杂度为 O(1) 的巧妙解法。通过三次翻转操作来达到轮转的效果。
例如，对于 `nums = [1,2,3,4,5,6,7], k = 3`：
1.  **整体翻转**: 数组变为 `[7,6,5,4,3,2,1]`。
2.  **翻转前 k 个元素**: 数组变为 `[5,6,7,4,3,2,1]`。
3.  **翻转后 n-k 个元素**: 数组变为 `[5,6,7,1,2,3,4]`。
最终得到正确结果。

#### 算法步骤
1.  **处理 k**: `k` 可能大于数组长度 `n`，因此先对 `k` 取模，`k = k % n`，得到实际需要移动的步数。
2.  **第一次翻转**: 翻转整个 `nums` 数组。
3.  **第二次翻转**: 翻转数组的前 `k` 个元素，即 `[0, k-1]` 区间。
4.  **第三次翻转**: 翻转数组的后 `n-k` 个元素，即 `[k, n-1]` 区间。
5.  **返回**。

#### 复杂度分析
- **时间复杂度**: O(N)
  *每次翻转操作都需要遍历相应区间的元素，总共遍历了两次数组长度的元素，所以是线性时间复杂度。*
- **空间复杂度**: O(1)
  *所有操作都在原数组上进行，没有使用额外的数组空间。*

---

## 代码实现

### 解法一：开辟新数组

```cpp
#include <vector>

class Solution {
public:
    void rotate(std::vector<int>& nums, int k) {
        int n = nums.size();
        // 如果数组为空或 k=0，则无需操作
        if (n == 0 || k == 0) return;
        
        std::vector<int> res(n);
        
        // 遍历原数组
        for(int i = 0; i < n; i++) {
            // 计算每个元素轮转 k 步后的新位置
            // (i + k) % n 确保了索引不会越界
            res[(i + k) % n] = nums[i];
        }
        
        // 将新数组的结果复制回原数组
        nums = res;
    }
};
```

### 解法二：原地变换（三次翻转）

```C++
#include <vector>
#include <algorithm> // for std::reverse

class Solution {
public:
    void rotate(std::vector<int>& nums, int k) {
        int n = nums.size();
        if (n == 0 || k == 0) return;

        // 1. k 可能大于 n，取模得到实际的移动步数
        k %= n;

        // 2. 第一次翻转：整体翻转
        // [7,6,5,4,3,2,1]
        std::reverse(nums.begin(), nums.end());

        // 3. 第二次翻转：翻转前 k 个元素
        // [5,6,7,4,3,2,1]
        std::reverse(nums.begin(), nums.begin() + k);

        // 4. 第三次翻转：翻转后 n-k 个元素
        // [5,6,7,1,2,3,4]
        std::reverse(nums.begin() + k, nums.end());
    }
};
```