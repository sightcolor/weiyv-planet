# 全排列

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/permutations/)

---

## 题目描述

> 给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。
>
> **示例:**
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> ```
> 输入：nums = [0,1]
> 输出：[[0,1],[1,0]]
> ```

---

## 解题思路

### 核心思想
**回溯算法 (Backtracking) + 深度优先搜索 (DFS)**

全排列问题可以看作是一个在“决策树”上进行搜索的过程。假设我们有数组 `[1, 2, 3]`：
- 第一个位置，我们可以选择 `1`、`2` 或 `3`。
- 如果第一个位置选择了 `1`，那么第二个位置就只能从剩下的 `2` 和 `3` 中选择。
- ...以此类推，直到所有数字都被选择完毕。

这个过程天然地形成了一棵树形结构，每一条从根节点到叶子节点的路径都代表一个完整的排列。我们的任务就是遍历这棵决策树，收集所有叶子节点的值。

**回溯算法**正是解决这类问题的经典范式。它的核心在于：
- **路径 (Path)**: 用一个列表（如 `temp`）来记录当前已经做出的选择。
- **选择列表 (Choice List)**: 在当前状态下，可以做的所有选择（即 `nums` 中尚未被使用的数字）。
- **结束条件 (Base Case)**: 当路径的长度等于原数组的长度时，说明一个完整的排列已经形成，将其加入结果集。

为了高效地判断哪些数字是“尚未被使用”的，我们使用一个 `visited` 布尔数组来标记每个数字的使用状态。

### "前序选择，后序撤销"
回溯算法的精髓可以概括为 **"前序遍历做选择，后序遍历撤销选择"**，这与对决策树的深度优先遍历（DFS）过程完全对应：
- **做选择 (前序)**: 在深入下一层递归之前，将一个可行的选择（一个未被访问的数字）加入到当前路径 `temp` 中，并更新 `visited` 状态。
- **撤销选择 (后序)**: 当从一个递归调用返回后，需要将之前做出的选择撤销（从 `temp` 中移除，并重置 `visited` 状态），以便在当前层级尝试其他的选择分支。这个“恢复现场”的步骤就是“回溯”。

### 算法步骤
1.  **初始化**:
    *   创建结果列表 `res` 用于存储所有排列。
    *   创建临时路径 `temp` 用于存储当前排列。
    *   创建 `visited` 数组，大小与 `nums` 相同，初始值均为 `false`。
2.  **定义回溯函数 `backTrack()`**:
    *   **设置 Base Case**: 如果 `temp` 的大小等于 `nums` 的大小，说明找到了一个完整排列。将 `temp` 的一个拷贝存入 `res`，然后返回。
    *   **遍历选择列表**: 使用 `for` 循环遍历整个 `nums` 数组（从索引 `0` 到 `n-1`）。
        *   **剪枝**: 如果 `nums[i]` 已经被访问过（`visited[i] == true`），则跳过，不进行选择。
        *   **做选择**:
            *   将 `nums[i]` 添加到 `temp` 的末尾。
            *   标记 `visited[i] = true`。
        *   **进入下一层递归**: 调用 `backTrack()`，让下一层在当前选择的基础上继续构建排列。
        *   **撤销选择 (回溯)**:
            *   将 `nums[i]` 从 `temp` 的末尾移除。
            *   重置 `visited[i] = false`。
3.  **主函数调用**:
    *   在主函数中，初始化好所有变量后，调用一次 `backTrack()` 启动整个搜索过程。
    *   返回 `res`。

### 复杂度分析
- **时间复杂度**: O(N * N!)
  *(其中 N 是数组 `nums` 的长度。生成 N! 个排列是无法避免的，对于每个排列，我们需要 O(N) 的时间来将其拷贝到结果列表中。)*
- **空间复杂度**: O(N)
  *(不考虑存储最终结果的 `res` 列表。空间主要由递归栈的深度（最多为 N）和 `temp`、`visited` 数组（大小为 N）决定。)*

---

## 代码实现

### C++ (您的实现)
*(该实现是回溯算法解决全排列问题的标准范式，逻辑清晰且正确。)*
```cpp
#include <vector>

class Solution {
private:
    std::vector<std::vector<int>> res;
    std::vector<int> nums;
    std::vector<bool> visited;
    std::vector<int> temp;
    int n;

    void backTrack() {
        // Base Case: 当路径长度等于数组长度，说明找到一个完整排列
        if(temp.size() == n) {
            res.push_back(temp);
            return;
        }

        // 遍历所有可能的选择
        for(int i = 0; i < n; i++) {
            // 剪枝：如果数字已被使用，则跳过
            if(visited[i]) {
                continue;
            }

            // --- 做出选择 (前序位置) ---
            visited[i] = true;
            temp.push_back(nums[i]);

            // --- 进入下一层决策 ---
            backTrack();

            // --- 撤销选择 (后序位置/回溯) ---
            visited[i] = false;
            temp.pop_back();
        }
    }

public:
    std::vector<std::vector<int>> permute(std::vector<int>& nums) {
        this->nums = nums;
        this->n = nums.size();
        visited.resize(n, false);
        
        // 启动回溯
        backTrack();
        
        return res;
    }
};
```