# 分割回文串

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/palindrome-partitioning/)

---

## 题目描述

> 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 的所有可能的分割方案。
>
> **回文串** 是正着读和反着读都一样的字符串。
>
> **示例:**
> ```
> 输入：s = "aab"
> 输出：[["a","a","b"],["aa","b"]]
> ```
>
> ```
> 输入：s = "a"
> 输出：[["a"]]
> ```

---

## 解题思路

### 核心思想
**回溯算法 + 枚举分割点**

这个问题要求我们找出所有可能的分割方案，这是一个典型的需要通过搜索来穷举所有可能性的问题，因此**回溯算法**是解决此题的理想方法。

我们可以将问题想象成在字符串中“切分”，每次切下来的一段都必须是回文串。
- 我们站在字符串的某个起始位置 `start_index`。
- 我们尝试从这个位置开始，切下不同长度的子串。例如，先尝试切下长度为 1 的子串 `s[start_index]`，再尝试切下长度为 2 的子串 `s[start_index...start_index+1]`，以此类推，直到字符串末尾。
- 对于每一个切下来的子串，我们 **判断它是否是回文串**。
  - 如果是，那么这是一个有效的“选择”。我们将这个子串加入当前路径 `temp`，然后从这个子串的末尾之后的位置，即 `new_start_index`，继续进行递归分割。
  - 如果不是，那么这是一个无效的选择，我们直接放弃这个分支（剪枝）。
- 当我们的起始位置 `start_index` 越过字符串末尾时，说明我们已经成功地将整个字符串分割完毕，此时 `temp` 中就存放着一个有效的分割方案。

### 算法步骤
1.  **初始化**:
    *   创建结果列表 `res` 和临时路径 `temp`。
2.  **定义回溯函数 `backTrack(int start_index)`**:
    *   `start_index` 表示当前需要开始分割的子字符串的起始索引。
    *   **Base Case (终止条件)**: 如果 `start_index` 等于或超过字符串 `s` 的长度，说明整个字符串已经被成功分割，我们将 `temp` 加入结果集 `res`，然后返回。
    *   **遍历所有可能的分割点**:
        *   使用 `for` 循环，枚举从 `start_index` 开始的所有可能的子串。我们可以通过枚举子串的长度 `len` 来实现。
        *   在循环中，截取子串 `sub = s.substr(start_index, len)`。
        *   **剪枝**: 调用一个辅助函数 `isValid(sub)` 判断该子串是否为回文串。如果不是，就跳过，尝试下一个长度。
        *   **做选择**:
            *   如果 `sub` 是回文串，将其加入 `temp`。
        *   **进入下一层递归**:
            *   调用 `backTrack(start_index + len)`，从当前子串的结束位置之后继续寻找下一个回文串。
        *   **撤销选择 (回溯)**:
            *   将 `sub` 从 `temp` 的末尾移除。
3.  **定义辅助函数 `isValid(string str)`**:
    *   使用双指针法，从字符串两端向中间比较，判断其是否为回文串。
4.  **主函数调用**:
    *   在主函数中，调用 `backTrack(0)` 启动搜索，表示从字符串的开头（索引0）开始分割。
    *   返回 `res`。

### 复杂度分析
- **时间复杂度**: O(N * 2^N)
  *(在最坏情况下（例如 "aaaa"），大约有 2^(N-1) 种分割方法。对于每种分割，我们可能需要 O(N) 的时间来检查子串是否是回文串以及拷贝路径。)*
- **空间复杂度**: O(N)
  *(不考虑存储结果 `res` 的空间。空间主要由递归栈的深度（最多为 N）和 `temp` 路径（最多包含 N 个长度为 1 的字符串）决定。)*

---

## 代码实现

### C++ 
*(该实现通过枚举下一个回文子串的长度来驱动回溯，逻辑清晰，是解决此问题的标准范式。)*
```cpp
#include <vector>
#include <string>

class Solution {
private:
    std::vector<std::vector<std::string>> res;
    std::vector<std::string> temp;
    std::string s;

    // 辅助函数：判断字符串是否为回文串
    bool isPalindrome(const std::string& str) {
        int left = 0, right = str.length() - 1;
        while (left < right) {
            if (str[left] != str[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    // start_index: 当前开始分割的位置
    void backTrack(int start_index) {
        // Base Case: 如果起始位置越过字符串末尾，说明找到了一个完整的分割方案
        if (start_index >= s.length()) {
            res.push_back(temp);
            return;
        }

        // 遍历所有可能的分割点（通过枚举子串长度）
        for (int len = 1; start_index + len <= s.length(); ++len) {
            std::string sub = s.substr(start_index, len);

            // 剪枝：如果截取的子串不是回文串，则跳过
            if (isPalindrome(sub)) {
                // --- 做出选择 ---
                temp.push_back(sub);
                
                // --- 进入下一层决策 ---
                // 从当前子串的末尾之后继续分割
                backTrack(start_index + len);
                
                // --- 撤销选择 (回溯) ---
                temp.pop_back();
            }
        }
    }

public:
    std::vector<std::vector<std::string>> partition(std::string s) {
        this->s = s;
        backTrack(0);
        return res;
    }
};
```