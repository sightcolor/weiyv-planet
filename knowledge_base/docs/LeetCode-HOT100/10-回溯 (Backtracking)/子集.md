# 子集

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/subsets/)

---

## 题目描述

> 给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
>
> **示例:**
> ```
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> ```
>
> ```
> 输入：nums = [0]
> 输出：[[],[0]]
> ```

---

## 解题思路

### 核心思想
**回溯算法 + 剪枝避免重复**

子集问题与全排列问题非常相似，都可以通过回溯法构建决策树来解决。但它们有一个本质区别：
- **全排列 (Permutation)**: 关心元素的 **顺序**，`[1, 2]` 和 `[2, 1]` 是两种不同的排列。
- **子集/组合 (Combination)**: 不关心元素的 **顺序**，`{1, 2}` 和 `{2, 1}` 是同一个子集。

为了在生成子集时不产生重复（例如 `[1, 2]` 和 `[2, 1]`），我们必须施加一个约束来“剪枝”。

> **关键剪枝策略：保证组合内元素的索引是单调递增的。**

如果我们规定，对于任意一个组合，里面的元素在原数组 `nums` 中的索引必须是严格递增的，那么我们就永远不会选到 `[2, 1]` 这样的组合（因为 2 的索引大于 1 的索引）。这样，每一个唯一的元素组合就只会以一种顺序（索引升序）被生成一次。

### 算法步骤
1.  **初始化**:
    *   创建结果列表 `res` 和临时路径 `temp`。
2.  **定义回溯函数 `backTrack(int start_index)`**:
    *   这个函数的作用是，从 `nums` 的 `start_index` 位置开始，向后探索所有可能的元素，并将它们加入到当前路径 `temp` 中。
    *   **收集结果**: 与排列问题不同，子集问题的决策树上 **从根节点到任意一个节点的路径，都构成一个合法的子集**（包括空集 `[]`）。因此，我们应该在 `backTrack` 函数一被调用时，就立刻将当前的 `temp` 加入结果集 `res`。
    *   **遍历选择列表 (并剪枝)**:
        *   使用 `for` 循环从 `start_index` 开始，而不是从 `0` 开始。这就是实现“索引递增”的关键。`for (int i = start_index; i < n; i++)`
        *   **做选择**:
            *   将 `nums[i]` 添加到 `temp`。
        *   **进入下一层递归**:
            *   调用 `backTrack(i + 1)`。**注意**：这里传入 `i + 1` 而不是 `start_index + 1`。这保证了下一层的选择起点，永远在当前层选择的元素的 **后面**，从而强制了索引的单调递增。
        *   **撤销选择 (回溯)**:
            *   将 `nums[i]` 从 `temp` 的末尾移除。
3.  **主函数调用**:
    *   在主函数中，调用 `backTrack(0)` 启动整个搜索过程，表示第一次可以从索引 `0` 开始选择。
    *   返回 `res`。

### 复杂度分析
- **时间复杂度**: O(N * 2^N)
  *(一个大小为 N 的集合，其子集共有 2^N 个。对于每个子集，我们都需要 O(N) 的时间（最坏情况）来将其拷贝到结果列表中。)*
- **空间复杂度**: O(N)
  *(不考虑存储最终结果的 `res` 列表。空间主要由递归栈的深度（最多为 N）和 `temp` 数组（大小最多为 N）决定。)*

---

## 代码实现

### C++
*(该实现通过 `start_index` 参数巧妙地实现了剪枝，是解决子集/组合类问题的标准回溯模板。)*
```cpp
#include <vector>

class Solution {
private:
    std::vector<int> nums;
    std::vector<std::vector<int>> res;
    std::vector<int> temp;
    
    // start_index: 本轮选择的起始索引，确保组合中元素的索引单调递增
    void backTrack(int start_index) {
        // 决策树上的每个节点都是一个合法的子集
        res.push_back(temp);
        
        int n = nums.size();
        // Base Case是隐式的: 当 start_index >= n 时，循环不执行，函数返回

        // 遍历所有可做的选择
        for(int i = start_index; i < n; i++) {
            // --- 做出选择 ---
            temp.push_back(nums[i]);
            
            // --- 进入下一层决策 ---
            // 传入 i + 1，确保下一轮选择从当前元素的下一个开始
            backTrack(i + 1);
            
            // --- 撤销选择 (回溯) ---
            temp.pop_back();
        } 
    }

public:
    std::vector<std::vector<int>> subsets(std::vector<int>& nums) {
        this->nums = nums;
        // 初始调用，从索引 0 开始选择
        backTrack(0);
        return res;
    }
};
```