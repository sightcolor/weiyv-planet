# 组合总和

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/combination-sum/)

---

## 题目描述

> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** 。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。
>
> **示例:**
> ```
> 输入：candidates = [2,3,6,7], target = 7
> 输出：[[2,2,3],[7]]
> 解释：
> 2 和 3 可以形成一组组合 [2,2,3] ，数字 2 被使用了两次。
> 7 C本身就是一个组合 [7] 。
> ```
>
> ```
> 输入: candidates = [2,3,5], target = 8
> 输出: [[2,2,2,2],[2,3,3],[3,5]]
> ```

---

## 解题思路

### 核心思想
**回溯算法 + 剪枝 (通过起始索引避免重复组合)**

这个问题是经典的组合问题变体。我们需要找到所有和为 `target` 的组合，其中每个元素可以被无限次使用。这仍然可以用回溯法来构建决策树并进行搜索。

与“子集”和“排列”问题相比，这个问题有两个核心特点：
1.  **元素可重复使用**: 在选择了一个元素 `candidates[i]` 之后，下一轮的选择中仍然可以包含 `candidates[i]`。
2.  **结果是组合**: 元素的顺序不重要，`[2, 2, 3]` 和 `[2, 3, 2]` 是同一个组合。

为了解决 **组合重复** 的问题（例如同时生成 `[2, 3]` 和 `[3, 2]`），我们必须采用和“子集”问题类似的剪枝策略：
> **规定组合内元素的索引是单调不降的。**

这意味着，在某一层递归中，如果我们选择了 `candidates[i]`，那么在更深的递归中，我们只能从 `candidates[i]`、`candidates[i+1]`、... 中进行选择，而不能回头去选择 `candidates[i-1]`。这通过在回溯函数中传递一个 `start_index` 来实现。

### 算法步骤
1.  **初始化**:
    *   准备好 `res` (结果列表) 和 `temp` (当前路径)。
2.  **定义回溯函数 `backTrack(int start_index, int totalSum)`**:
    *   `start_index`: 控制本轮选择的起始位置，用于避免重复组合。
    *   `totalSum`: 记录当前路径 `temp` 中元素的和。
    *   **设置终止条件 (Base Cases)**:
        *   **成功找到解**: 如果 `totalSum == target`，说明当前 `temp` 是一个有效的组合，将其加入 `res` 并返回。
        *   **无效路径 (剪枝)**: 如果 `totalSum > target`，说明当前路径不可能得到解，直接返回，不再深入。
    *   **遍历选择列表**:
        *   使用 `for` 循环从 `start_index` 开始遍历 `candidates`。 `for (int i = start_index; ...)`
        *   **做选择**:
            *   将 `candidates[i]` 添加到 `temp`。
        *   **进入下一层递归**:
            *   调用 `backTrack(i, totalSum + candidates[i])`。
            *   **关键点**: 这里递归传入的还是 `i`，而不是 `i + 1`。这表示下一轮依然可以从 `candidates[i]` 开始选择，从而实现了“元素可被重复使用”的题意。
        *   **撤销选择 (回溯)**:
            *   将 `candidates[i]` 从 `temp` 的末尾移除。
3.  **主函数调用**:
    *   在主函数中，调用 `backTrack(0, 0)` 启动搜索，表示初始和为 `0`，并从索引 `0` 开始选择。
    *   返回 `res`。

### 复杂度分析
- **时间复杂度**: 难以精确计算，但大致为 **O(N * 2^N)** 或更高，其中 N 是 `candidates` 的数量。因为它取决于 `target` 和 `candidates` 中的数值。每个位置都有 N 种选择，深度可以很深。这是一个粗略的上界。
- **空间复杂度**: O(target)
  *(不考虑存储结果 `res` 的空间。空间主要由递归栈的深度决定。在最坏情况下，如果 `candidates` 中有 `1`，递归深度可能达到 `target`。)*

---

## 代码实现

### C++ 
*(该实现通过 `start_index` 参数控制搜索起点，并巧妙地在递归时传入 `i` 本身，同时解决了组合重复和元素复用的问题。)*
```cpp
#include <vector>

class Solution {
private:
    std::vector<int> candidates;
    std::vector<std::vector<int>> res;
    std::vector<int> temp;
    int target;

public:
    // start_index: 控制搜索的起点，避免产生重复组合
    // totalSum: 当前路径的和
    void backTrack(int start_index, int totalSum) {
        // Base Case 1: 路径和超过 target，此路不通 (剪枝)
        if(totalSum > target) {
            return;
        }
        // Base Case 2: 找到一个有效的组合
        if(totalSum == target) {
            res.push_back(temp);
            return;
        }
        
        // 遍历所有可做的选择
        // 为了避免重复，我们只从 start_index 开始向后选择
        for(int i = start_index; i < candidates.size(); i++) {
            // --- 做出选择 ---
            temp.push_back(candidates[i]);
            
            // --- 进入下一层决策 ---
            // 关键点: 递归时传入 i，表示元素可以被重复使用
            backTrack(i, totalSum + candidates[i]);
            
            // --- 撤销选择 (回溯) ---
            temp.pop_back();
        }
    }

    std::vector<std::vector<int>> combinationSum(std::vector<int>& candidates, int target) {
        this->target = target;
        this->candidates = candidates;
        // 初始调用，和为 0，从索引 0 开始
        backTrack(0, 0);
        return res;
    }
};
```