# 括号生成

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/generate-parentheses/)

---

## 题目描述

> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
> **示例:**
> ```
> 输入：n = 3
> 输出：["((()))","(()())","(())()","()(())","()()()"]
> ```
>
> ```
> 输入：n = 1
> 输出：["()"]
> ```

---

## 解题思路

### 核心思想
**回溯算法 + 约束剪枝**

这个问题要求我们生成所有 *有效* 的括号组合。如果我们盲目地生成所有长度为 `2n` 的 `(` 和 `)` 的组合，然后再去判断其有效性，效率会非常低下。

更优的方法是在构建字符串的过程中，就**实时进行剪枝**，确保每一步添加的括号都满足有效性的约束。这就是回溯算法的用武之地。

一个有效的括号组合需要满足两个基本约束：
1.  任意时刻，已经放置的左括号数量 **不能少于** 右括号数量。
2.  最终，左括号和右括号的数量都必须等于 `n`。

我们可以将这个问题建模为一个状态 `(left, right)`，其中 `left` 代表剩余可用的左括号数量，`right` 代表剩余可用的右括号数量。

**剪枝的两个关键条件**:
1.  **添加左括号 `(`**: 只要我们还有剩余的左括号可用 (`left > 0`)，我们就可以选择添加一个左括号。
2.  **添加右括号 `)`**: 只有当剩余的右括号数量 **多于** 剩余的左括号数量时 (`left < right`)，我们才能选择添加一个右括号。这个条件隐含了“已放置的左括号数量 > 已放置的右括号数量”，从而保证了字符串的有效性。

### 算法步骤
1.  **初始化**:
    *   创建结果列表 `res` 和临时字符串 `temp`。
2.  **定义回溯函数 `backTrack(int left, int right)`**:
    *   `left`: 剩余可用的左括号数量。
    *   `right`: 剩余可用的右括号数量。
    *   **设置 Base Case (终止条件)**: 当 `left` 和 `right` 都为 `0` 时，说明我们已经用完了所有括号，形成了一个有效的组合。将 `temp` 加入 `res` 并返回。
    *   **遍历选择列表 (并剪枝)**: 在每个状态下，我们只有两种选择：放 `(` 或者放 `)`。
        *   **选择1：放左括号**
            *   **条件**: 如果 `left > 0`。
            *   **操作**: `temp` 追加 `'('`，然后递归调用 `backTrack(left - 1, right)`。
            *   **回溯**: 撤销选择，`temp.pop_back()`。
        *   **选择2：放右括号**
            *   **条件**: 如果 `left < right`。
            *   **操作**: `temp` 追加 `')'`，然后递归调用 `backTrack(left, right - 1)`。
            *   **回溯**: 撤销选择，`temp.pop_back()`。
3.  **主函数调用**:
    *   在主函数中，调用 `backTrack(n, n)` 启动搜索，表示初始时我们有 `n` 个左括号和 `n` 个右括号可用。
    *   返回 `res`。

### 复杂度分析
- **时间复杂度**: O( (4^n) / (n * sqrt(n)) )
  *(结果的数量符合第 n 个卡特兰数 C_n，其增长速度大致如此。对于每个有效序列，我们花费 O(n) 的时间来构建它。)*
- **空间复杂度**: O(n)
  *(不考虑存储结果 `res` 的空间。空间主要由递归栈的深度（最多为 2n）和 `temp` 字符串（长度最多为 2n）决定，因此是 O(n)。)*

---

## 代码实现

### C++ 
*(该实现通过 `left` 和 `right` 计数器作为状态，优雅地实现了约束剪枝，是解决此问题的标准范式。)*
```cpp
#include <vector>
#include <string>

class Solution {
private:
    std::vector<std::string> res;
    std::string temp;

    // left: 剩余可用的左括号数
    // right: 剩余可用的右括号数
    void backTrack(int left, int right) {
        // Base Case: 左右括号都用完，找到一个合法解
        if(left == 0 && right == 0) {
            res.push_back(temp);
            return;
        }

        // --- 剪枝与选择 ---

        // 选择1: 添加左括号
        // 条件: 只要还有左括号可用
        if(left > 0) {
            temp.push_back('(');
            backTrack(left - 1, right);
            temp.pop_back(); // 回溯
        }
        
        // 选择2: 添加右括号
        // 条件: 剩余的右括号比左括号多，才能保证合法性
        if(left < right) {
            temp.push_back(')');
            backTrack(left, right - 1);
            temp.pop_back(); // 回溯
        }
    }

public:
    std::vector<std::string> generateParenthesis(int n) {
        // 初始状态：n个左括号，n个右括号可用
        backTrack(n, n);
        return res;
    }
};
```