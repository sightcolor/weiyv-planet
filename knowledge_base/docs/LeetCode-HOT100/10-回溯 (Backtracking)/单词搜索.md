# 单词搜索

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/word-search/)

---

## 题目描述

> 给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>
> **示例:**
> ```
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
> 输出：true
> ```
>
> ```
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
> 输出：true
> ```
>
> ```
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
> 输出：false
> ```

---

## 解题思路

### 核心思想
**回溯算法 (Backtracking) on a Grid**

这个问题本质上是在一个图中寻找一条特定的路径，其中图的节点是网格中的单元格，边连接着相邻的单元格。**深度优先搜索 (DFS)** 是解决此类路径查找问题的天然选择，而 **回溯** 则是 DFS 在探索过程中处理“死胡同”的关键机制。

我们的策略是：
1.  **遍历所有起点**: 网格中的任何一个单元格都有可能是单词的起始点。因此，我们需要一个外层循环来遍历 `board` 上的每一个单元格 `(i, j)`。
2.  **深度优先搜索**: 从一个潜在的起始点开始，我们进行深度优先搜索，尝试匹配 `word` 中的字符。
3.  **约束与剪枝**: 在搜索过程中，必须满足以下条件：
    *   不能越出网格边界。
    *   当前单元格的字符必须与 `word` 中对应位置的字符匹配。
    *   **不能重复访问** 同一个搜索路径中的单元格。

为了防止重复访问，我们可以在进入一个单元格时对其进行“标记”，在从该单元格的所有分支探索完毕（回溯）后，再“取消标记”。一个巧妙的方法是直接修改 `board` 上的字符（例如，改成一个特殊字符如 `'#'`），回溯时再改回来。

### 算法步骤
1.  **主函数 `exist`**:
    *   遍历整个 `board` 网格，使用 `i` 和 `j` 作为行列索引。
    *   **起点优化**: 只有当 `board[i][j]` 与 `word` 的第一个字符 `word[0]` 相同时，才有可能找到匹配。因此，我们只对满足这个条件的单元格启动 DFS。
    *   调用 `dfs(i, j, 1)` 开始搜索。注意，我们从 `word` 的第 `1` 个索引开始匹配，因为第 `0` 个已经匹配上了。
    *   如果任何一次 `dfs` 调用返回 `true`，说明找到了单词，立即返回 `true`。
    *   如果遍历完所有单元格都没有找到，返回 `false`。
2.  **回溯函数 `dfs(row, col, index)`**:
    *   `row`, `col`: 当前在网格中的位置（这个位置的字符已匹配 `word[index-1]`）。
    *   `index`: 当前需要为 `word` 中的 `word[index]` 字符寻找匹配。
    *   **Base Case (成功)**: 如果 `index` 等于或超过 `word` 的长度，说明 `word` 的所有字符都已成功匹配，返回 `true`。
    *   **标记当前位置**: 暂存当前单元格的原始字符 `src = board[row][col]`，然后将其修改为一个特殊字符，如 `board[row][col] = '#'`，表示“正在访问”。
    *   **探索相邻单元格**: 遍历上、下、左、右四个方向。
        *   对于每个方向的新坐标 `(nrow, ncol)`，进行一系列**剪枝判断**：
            *   是否越界？
            *   是否已经被访问过 (`board[nrow][ncol] == '#'`)？
            *   **字符是否与下一个目标字符匹配** (`board[nrow][ncol] != word[index]`)？
        *   如果通过所有检查，说明这是一个有效的下一步。递归调用 `dfs(nrow, ncol, index + 1)`。
        *   如果递归调用返回 `true`，说明找到了完整路径，立即**将 `true` 向上层传递**。
    *   **回溯 (撤销选择)**: 如果四个方向都探索完毕，且没有一个能成功匹配整个单词，说明从当前 `(row, col)` 出发的路径是死胡同。在函数返回 `false` 之前，必须将单元格恢复原样：`board[row][col] = src`。这是回溯的关键，确保该单元格可以被其他搜索路径使用。
    *   **返回失败**: 如果所有分支都失败，返回 `false`。

### 复杂度分析
- **时间复杂度**: O(M * N * 3^L)
  *(其中 M, N 是网格的行数和列数，L 是单词 `word` 的长度。我们需要遍历 M*N 个单元格作为起点。对于每个起点，DFS 的搜索空间大致是 3^L，因为除了来的方向，我们最多有3个方向可以选择。)*
- **空间复杂度**: O(L)
  *(不考虑输入占用的空间。空间主要由递归栈的深度决定，最深为单词的长度 L。)*

---

## 代码实现

### C++ 
*(该实现逻辑严谨，通过在原 `board` 上进行标记和恢复，高效地实现了回溯过程。)*
```cpp
#include <vector>
#include <string>

class Solution {
private:
    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
    std::string word;
    std::vector<std::vector<char>> board;

public:
    // row, col: 当前已匹配的单元格坐标
    // index:   下一个需要匹配的 word 字符的索引
    bool dfs(int row, int col, int index) {
        // Base Case: 所有字符都已匹配
        if (index >= word.size()) {
            return true;
        }
        
        // --- 做出选择 & 标记 ---
        char originalChar = board[row][col];
        board[row][col] = '#'; // 标记为已访问

        // --- 探索相邻节点 ---
        for(auto& dir : dirs) {
            int nrow = row + dir[0];
            int ncol = col + dir[1];

            // 剪枝
            if (nrow < 0 || ncol < 0 || nrow >= board.size() || ncol >= board[0].size() || board[nrow][ncol] != word[index]) {
                continue;
            }
            
            // 深入下一层
            if (dfs(nrow, ncol, index + 1)) {
                return true;
            }
        }

        // --- 撤销选择 (回溯) ---
        board[row][col] = originalChar;

        return false;
    }

    bool exist(std::vector<std::vector<char>>& board, std::string word) {
        this->board = board;
        this->word = word;
        int m = board.size(), n = board[0].size();
        
        // 遍历所有可能的起点
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // 找到第一个字母的匹配
                if (board[i][j] == word[0]) {
                    // 开始搜索剩下的部分 (从 word[1] 开始)
                    if (dfs(i, j, 1)) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
};
```