# 电话号码的字母组合

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

---

## 题目描述

> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 `1` 不对应任何字母。
>
> ![Phone Keyboard](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2.svg.png)
>
> **示例:**
> ```
> 输入：digits = "23"
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```
>
> ```
> 输入：digits = ""
> 输出：[]
> ```

---

## 解题思路

### 核心思想
**回溯算法 (Backtracking) — 探索所有组合路径**

这个问题可以被看作是遍历一个隐式的决策树。树的深度由输入数字字符串 `digits` 的长度决定。树的每一层代表 `digits` 字符串中的一个位置，而该层的分支则由该位置的数字所对应的字母决定。

例如，对于 `digits = "23"`:
- **第0层 (根节点)**: 对应数字 `2`，有 `a`, `b`, `c` 三个分支。
- **第1层**:
  - 如果上一层选择了 `a`，这一层对应数字 `3`，有 `d`, `e`, `f` 三个分支，形成 "ad", "ae", "af"。
  - 如果上一层选择了 `b`，这一层同样有 `d`, `e`, `f` 三个分支，形成 "bd", "be", "bf"。
  - ...以此类推。

我们的目标是找到从根节点到所有叶子节点的所有路径。**回溯算法**正是解决这类问题的完美工具，它通过深度优先搜索（DFS）的方式系统地探索这棵决策树。

### 算法步骤
1.  **初始化**:
    *   创建一个 `map` 或 `vector<string>` `table`，用于存储数字到字母的映射。
    *   创建结果列表 `res` 和一个临时字符串 `temp` (或 `StringBuilder`) 用于构建路径。
2.  **处理边界情况**: 如果输入的 `digits` 字符串为空，直接返回空的结果列表。
3.  **定义回溯函数 `backTrack(int index)`**:
    *   `index` 参数表示当前正在处理 `digits` 字符串中的第几个数字。
    *   **设置 Base Case (终止条件)**: 如果 `index` 等于 `digits` 的长度，说明我们已经为每个数字都选择了一个字母，形成了一个完整的组合。将当前 `temp` 中的字符串加入结果集 `res`，然后返回。
    *   **遍历选择列表**:
        *   获取当前数字 `digits[index]`。
        *   根据 `table` 找到该数字对应的所有字母（例如 "abc"）。
        *   使用 `for` 循环遍历这些字母。
        *   **做选择**: 将当前遍历到的字母 `ch` 追加到 `temp` 的末尾。
        *   **进入下一层递归**: 调用 `backTrack(index + 1)`，去处理下一个数字。
        *   **撤销选择 (回溯)**: 将 `temp` 末尾的字母 `ch` 移除，以便 `for` 循环可以尝试当前层的下一个字母选择。
4.  **主函数调用**:
    *   在主函数中，初始化好所有变量后，调用 `backTrack(0)` 启动搜索过程。
    *   返回 `res`。

### 复杂度分析
- **时间复杂度**: O(N * 4^N)
  *(其中 N 是 `digits` 的长度。在最坏情况下（输入全是 '7' 或 '9'），决策树的每个节点都有 4 个分支，树的深度为 N。因此组合的总数约为 4^N。对于每种组合，我们需要 O(N) 的时间来构建字符串。)*
- **空间复杂度**: O(N)
  *(不考虑存储最终结果的 `res` 列表。空间主要由递归栈的深度（最多为 N）和 `temp` 字符串（长度最多为 N）决定。)*

---

## 代码实现

### C++
*(该实现是解决此问题的标准回溯模板，通过索引 `curr` 来控制递归的深度。)*
```cpp
#include <vector>
#include <string>

class Solution {
private:
    std::string digits;
    std::vector<std::string> res;
    std::vector<std::string> table;
    std::string temp;

    // index: 当前正在处理 digits 字符串的索引（递归的深度）
    void backTrack(int index) {
        // Base Case: 当索引越界，说明已为所有数字选择完字母
        if(index >= digits.size()) {
            // 只有当 temp 不为空时才加入结果 (处理 digits 为空字符串的边缘情况)
            if(!temp.empty()) {
                res.push_back(temp);
            }
            return;
        }

        // 获取当前数字对应的字母选项，例如 "abc"
        std::string letters = table[digits[index] - '0'];
        
        // 遍历所有可能的选择
        for(char ch : letters) {
            // --- 做出选择 ---
            temp.push_back(ch);
            
            // --- 进入下一层决策 ---
            backTrack(index + 1);
            
            // --- 撤销选择 (回溯) ---
            temp.pop_back();
        }
    }

public:
    std::vector<std::string> letterCombinations(std::string digits) {
        this->digits = digits;
        if (digits.empty()) {
            return {};
        }
        
        table = {
            "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
        };
        
        backTrack(0);
        return res;
    }
};
```