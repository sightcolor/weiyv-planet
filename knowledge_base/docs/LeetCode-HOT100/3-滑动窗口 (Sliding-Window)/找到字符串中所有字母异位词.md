# 找到字符串中所有字母异位词

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

---

## 题目描述

> 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
>
> **异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。
>
> **示例:**
> ```
> 输入: s = "cbaebabacd", p = "abc"
> 输出:
> 解释:
> 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
> 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
> ```

---

## 解题思路

### 核心思想
采用**滑动窗口**和**哈希表**的策略。我们用一个哈希表 `mp` 来记录目标字符串 `p` 中所需要的字符及其数量。然后我们维护一个 `[l, r]` 的滑动窗口在 `s` 上移动。

这个解法的巧妙之处在于哈希表的用法：
-   当一个字符进入窗口（`r` 指针右移），我们就在哈希表中将对应字符的**需求量减一**。
-   如果一个字符的需求量变为负数（`mp[char] < 0`），说明这个字符在窗口中**过量**了。
-   为了使窗口恢复有效状态，我们必须收缩左边界 `l`，将 `s[l]` 移出窗口（将其在哈希表中的需求量加一），直到那个**过量**的字符不再过量为止。

### 算法步骤
1.  **初始化**: 创建一个哈希表 `mp`，遍历 `p` 字符串，统计其中每个字符的出现次数。初始化左指针 `l = 0` 和结果向量 `res`。
2.  **扩大窗口**: 使用右指针 `r` 遍历字符串 `s`。
3.  **更新需求**: 当字符 `s[r]` 进入窗口时，将其在 `mp` 中的需求量减一 (`mp[s[r]]--`)。
4.  **收缩窗口**: 检查 `mp[s[r]]` 是否小于 `0`。
    *   如果小于 `0`，说明窗口中 `s[r]` 字符的数量已经超出了 `p` 的需求。
    *   此时，进入 `while` 循环，不断将左指针 `l` 指向的字符 `s[l]` 移出窗口（即 `mp[s[l]]++`），并右移 `l`，直到 `mp[s[r]]` 的值恢复到 `0` 为止。
5.  **记录结果**: 在每次窗口移动后，检查当前窗口的长度 `r - l + 1` 是否等于 `p` 的长度 `m`。如果相等，说明这个窗口内的字符不多不少，恰好构成了 `p` 的一个异位词。此时，将左指针 `l` 作为起始索引存入 `res`。
6.  **返回**: 遍历结束后，返回 `res`。

### 复杂度分析
- **时间复杂度**: O(N + M)
  *其中 N 是字符串 `s` 的长度，M 是字符串 `p` 的长度。构建哈希表需要 O(M)，滑动窗口的两个指针 `l` 和 `r` 都只会遍历 `s` 一次，所以是 O(N)。总时间复杂度为 O(N + M)。*
- **空间复杂度**: O(K)
  *其中 K 是字符集的大小（这里是小写字母，K=26）。哈希表 `mp` 需要存储 `p` 中的字符，空间开销为 O(K)。*

---

## 代码实现

```cpp
#include <vector>
#include <string>
#include <unordered_map>

class Solution {
public:
    std::vector<int> findAnagrams(std::string s, std::string p) {
        std::vector<int> res;
        int n = s.size(), m = p.size();

        // 优化：如果 s 比 p 短，不可能找到异位词
        if (n < m) {
            return res;
        }

        // 使用哈希表记录 p 中需要的字符数量
        std::unordered_map<char, int> mp;
        for(char c : p) {
            mp[c]++;
        }

        int l = 0;
        // r 指针作为窗口的右边界
        for(int r = 0; r < n; r++) {
            // 当前字符进入窗口，其需求量减一
            char r_char = s[r];
            mp[r_char]--;

            // 如果 r_char 的需求量变为负数，说明窗口中该字符过多
            // 需要移动左边界 l 来收缩窗口
            while(mp[r_char] < 0) {
                char l_char = s[l];
                // 左边界的字符移出窗口，其需求量加一
                mp[l_char]++;
                l++;
            }

            // 当窗口大小恰好等于 p 的长度时，说明找到了一个异位词
            if(r - l + 1 == m) {
                res.push_back(l);
            }
        }

        return res;
    }
};
```