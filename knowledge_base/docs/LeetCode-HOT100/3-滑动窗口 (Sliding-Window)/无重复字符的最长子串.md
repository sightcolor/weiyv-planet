# 无重复字符的最长子串

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

---

## 题目描述

> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。
>
> **示例:**
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> 

---

## 解题思路

### 核心思想
采用**滑动窗口**和**哈希表**来解决问题。我们维护一个 `[l, r]` 的闭区间（窗口），这个窗口内的字符始终保持不重复。通过移动右指针 `r` 来扩大窗口，当遇到重复字符时，再移动左指针 `l` 来缩小窗口，直到窗口内不再有重复字符。在这个过程中，不断更新并记录窗口的最大长度。

### 算法步骤
1.  **初始化**: 创建一个哈希表 `mp` 用于记录窗口内每个字符的出现次数。初始化左指针 `l = 0` 和最大长度结果 `res = 0`。
2.  **扩大窗口**: 使用右指针 `r` 遍历整个字符串 `s`。
3.  **更新字符计数**: 将右指针指向的字符 `s[r]` 放入窗口，并在哈希表中将其计数加一。
4.  **处理重复，缩小窗口**: 检查 `s[r]` 在哈希表中的计数是否大于 1。
    *   如果大于 1，说明窗口内出现了重复字符。
    *   此时，进入一个 `while` 循环，不断将左指针 `l` 指向的字符 `s[l]` 移出窗口（在哈希表中将其计数减一），并向右移动 `l` (`l++`)。
    *   这个过程持续到 `s[r]` 的计数不再大于 1 为止，此时窗口恢复到无重复字符的状态。
5.  **更新最大长度**: 在每次 `r` 指针移动后（并完成了可能的窗口收缩），窗口 `[l, r]` 都是一个无重复字符的子串。计算当前窗口的长度 `r - l + 1`，并更新 `res = max(res, r - l + 1)`。
6.  **返回**: 遍历结束后，`res` 就是所求的最长无重复字符子串的长度。

### 复杂度分析
- **时间复杂度**: O(N)
  *其中 N 是字符串 `s` 的长度。虽然代码中有两层循环，但左指针 `l` 和右指针 `r` 都只会从头到尾遍历字符串一次，每个字符最多被访问两次（一次被 `r` 访问，一次被 `l` 访问）。因此，总的时间复杂度是线性的。*
- **空间复杂度**: O(Σ)
  *其中 Σ 是字符集的大小（例如 ASCII 字符集为 128）。哈希表 `mp` 在最坏情况下需要存储字符集中的所有字符，这是一个常数级别的空间。*

---

## 代码实现

```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <algorithm>

class Solution {
public:
    int lengthOfLongestSubstring(std::string s) {
        int n = s.size();
        // 哈希表，用于存储当前窗口中每个字符的出现次数
        std::unordered_map<char, int> mp;
        
        int res = 0;
        // 定义滑动窗口的左边界
        int l = 0;
        
        // r 是滑动窗口的右边界，不断向右扩展
        for(int r = 0; r < n; r++) {
            // 将右边界的字符加入窗口，并更新其计数
            mp[s[r]]++;
            
            // 检查新加入的字符是否导致窗口内出现重复
            // 如果 s[r] 的计数大于 1，则需要收缩左边界
            while(mp[s[r]] > 1) {
                // 将左边界的字符移出窗口，更新其计数
                mp[s[l]]--;
                // 左边界向右收缩
                l++;
            }
            
            // 此时，[l, r] 窗口内保证没有重复字符
            // 更新最大长度
            res = std::max(res, r - l + 1);
        }
        
        return res;
    }
};
```