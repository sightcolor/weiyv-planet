# 数据流的中位数

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/find-median-from-data-stream/)

---

## 题目描述

> **中位数** 是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。
>
> 例如, `[2,3,4]` 的中位数是 `3`。
> `[2,3]` 的中位数是 `(2 + 3) / 2 = 2.5`。
>
> 实现 `MedianFinder` 类:
> *   `MedianFinder()` 初始化 `MedianFinder` 对象。
> *   `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
> *   `double findMedian()` 返回到目前为止所有元素的中位数。
>
> **示例:**
> ```
> MedianFinder medianFinder = new MedianFinder();
> medianFinder.addNum(1);
> medianFinder.addNum(2);
> medianFinder.findMedian(); // 返回 1.5
> medianFinder.addNum(3);
> medianFinder.findMedian(); // 返回 2.0
> ```

---

## 解题思路

### 核心思想
**对偶堆 (Dual Heaps) — 一个最大堆 + 一个最小堆**

这个问题要求我们动态地、高效地从一个不断增长的数据流中找到中位数。如果每次都对所有数据进行排序，时间复杂度会非常高。我们需要一种数据结构，能够将数据“一分为二”，并快速访问中间的元素。

**对偶堆**正是为此而生。我们使用两个堆来维护整个数据流：
1.  **最大堆 `max_heap` (左半部分)**: 存储数据流中较小的一半元素。堆顶是这半部分中**最大**的元素。
2.  **最小堆 `min_heap` (右半部分)**: 存储数据流中较大的一半元素。堆顶是这半部分中**最小**的元素。

通过这种设计，**中位数**就恰好由两个堆的堆顶元素决定。

### 维持平衡的两个关键约束
为了让这套机制有效，我们必须在每次 `addNum` 操作后，始终维持两个关键的约束：
1.  **大小平衡**: 两个堆的大小要么相等，要么 `max_heap` 的大小比 `min_heap` 多 1。
    *   **总数为偶数时**: `max_heap.size() == min_heap.size()`。
    *   **总数为奇数时**: `max_heap.size() == min_heap.size() + 1`。
2.  **数值关系**: `max_heap` 中的所有元素都**小于或等于** `min_heap` 中的所有元素。这意味着 `max_heap.top() <= min_heap.top()`。

### 算法步骤

#### `addNum(num)` (精妙的平衡技巧)
为了在插入新元素 `num` 的同时维持上述两个约束，我们可以采用一种“交叉插入”的技巧，而不是复杂的 `if-else` 判断 `num` 应该去哪个堆。

-   **当两个堆大小相等时 (总数为偶数，下一个是奇数)**:
    -   我们希望将新元素加入，并最终让 `max_heap` 的大小加 1。
    -   为了保证数值关系，我们不能直接把 `num` 放入 `max_heap`。
    -   **操作**: 先将 `num` 放入 `min_heap`，然后将 `min_heap` 中最小的元素（即 `min_heap.top()`）弹出，再放入 `max_heap`。
    -   **效果**: 这相当于让 `num` 和右半部分的所有元素“竞争”一下，选出最小的那个放入左半部分，完美地维持了数值关系和大小平衡。
-   **当 `max_heap` 比 `min_heap` 大 1 时 (总数为奇数，下一个是偶数)**:
    -   我们希望将新元素加入，并最终让两个堆的大小相等。
    -   **操作**: 逻辑相反。先将 `num` 放入 `max_heap`，然后将 `max_heap` 中最大的元素（`max_heap.top()`）弹出，放入 `min_heap`。
    -   **效果**: 同样，`num` 和左半部分的元素“竞争”，选出最大的放入右半部分。

#### `findMedian()`
-   **总数为偶数 (`max_heap.size() == min_heap.size()`)**: 中位数是两个堆顶的平均值，即 `(max_heap.top() + min_heap.top()) / 2.0`。
-   **总数为奇数**: 中位数就是左半部分的最大值，即 `max_heap.top()`。

### 复杂度分析
- **`addNum` 时间复杂度**: O(log N)
  *(每次操作涉及一到两次堆的插入和删除，堆的高度为 O(log N)。)*
- **`findMedian` 时间复杂度**: O(1)
  *(只需要访问两个堆的堆顶。)*
- **空间复杂度**: O(N)
  *(我们需要存储所有的数据流元素。)*

---

## 代码实现

### C++ (对偶堆)
*(该实现通过巧妙的交叉插入，优雅地维持了两个堆的平衡，是此问题的最优解。)*
```cpp
#include <queue>
#include <vector>

class MedianFinder {
private:
    // 左半部分: 存储较小的一半数，堆顶是最大值
    std::priority_queue<int> max_heap;
    
    // 右半部分: 存储较大的一半数，堆顶是最小值
    std::priority_queue<int, std::vector<int>, std::greater<int>> min_heap;

public:
    MedianFinder() {}
    
    void addNum(int num) {
        // 当总数为偶数时，下一个数加入后应为奇数，max_heap 需多一个
        if (max_heap.size() == min_heap.size()) {
            min_heap.push(num);          // num 先去右边竞争
            max_heap.push(min_heap.top()); // 右边最小的出来，去左边
            min_heap.pop();
        } 
        // 当总数为奇数时，下一个数加入后应为偶数，两堆大小应相等
        else {
            max_heap.push(num);          // num 先去左边竞争
            min_heap.push(max_heap.top()); // 左边最大的出来，去右边
            max_heap.pop();
        }
    }
    
    double findMedian() {
        if (max_heap.size() == min_heap.size()) {
            return (max_heap.top() + min_heap.top()) / 2.0;
        }
        // 当总数为奇数时，中位数在 max_heap 的堆顶
        return max_heap.top();
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
 ```