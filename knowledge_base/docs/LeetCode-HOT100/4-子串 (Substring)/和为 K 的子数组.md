# 和为 K 的子数组

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/subarray-sum-equals-k/)

---

## 题目描述

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 该数组中和为 `k` 的子数组的个数 。
>
> **示例:**
> ```
> 输入: nums = , k = 2
> 输出: 2
> ```

---

## 解题思路

### 核心思想
采用**前缀和 + 哈希表**的策略。问题的核心在于，如果子数组 `[i..j]` 的和为 `k`，那么必然有 `prefix_sum[j] - prefix_sum[i-1] = k`。变形一下这个公式，我们得到 `prefix_sum[i-1] = prefix_sum[j] - k`。

这个公式告诉我们：当我们遍历到位置 `j` 时，如果能找到一个之前出现过的前缀和 `prefix_sum[i-1]`，它等于 `prefix_sum[j] - k`，那么我们就找到了一个和为 `k` 的子数组。

因此，我们可以用一个哈希表来存储**之前所有前缀和出现的次数**。边遍历数组计算当前的前缀和，边在哈希表中查找是否存在满足条件的“旧”前缀和。

### 算法步骤
1.  **初始化**: 创建一个哈希表 `mp`，用于存储 `{前缀和: 出现次数}`。初始化当前前缀和 `sum = 0` 和结果计数器 `res = 0`。
2.  **遍历**: 遍历 `nums` 数组中的每一个元素 `it`。
3.  **处理前缀和**: 在循环的每一步中，执行以下三个关键操作：
    *   **更新哈希表**: 将当前的前缀和 `sum` 存入哈希表，并将其出现次数加一 (`mp[sum]++`)。这一步必须在更新 `sum` **之前**完成。这样做非常巧妙，它相当于在循环开始前隐式地执行了 `mp[0] = 1`，从而可以正确处理那些从数组开头就满足条件的子数组。
    *   **更新当前和**: 将当前元素 `it` 加到 `sum` 上，得到新的前缀和 (`sum += it`)。
    *   **查找并累加结果**: 在哈希表中查找键为 `sum - k` 的值。这个值代表了在当前位置之前，有多少个子数组的起点可以与当前位置 `j` 构成和为 `k` 的子数组。将这个计数值累加到 `res` 中。
4.  **返回**: 遍历结束后，`res` 就是所有和为 `k` 的子数组的总数。

### 复杂度分析
- **时间复杂度**: O(N)
  *其中 N 是 `nums` 数组的长度。我们只需要对数组进行一次线性遍历。*
- **空间复杂度**: O(N)
  *在最坏的情况下，数组中所有元素的前缀和都不同，哈希表需要存储 N 个键值对。*

---

## 代码实现

```cpp
#include <vector>
#include <unordered_map>

class Solution {
public:
    int subarraySum(std::vector<int>& nums, int k) {
        int n = nums.size();
        // 哈希表，键: 前缀和, 值: 该前缀和出现的次数
        std::unordered_map<int, int> mp;
        
        // 初始化当前的前缀和为 0，结果计数器为 0
        int sum = 0, res = 0;
        
        // 遍历数组中的每一个元素
        for(auto& it : nums) {
            // 关键步骤1: 将当前的前缀和计入哈希表
            // 在第一次循环时，这里会执行 mp++，这相当于初始化哈希表
            // mp=1，用于处理从数组开头起和为 k 的子数组
            mp[sum]++;
            
            // 关键步骤2: 更新前缀和
            sum += it;
            
            // 关键步骤3: 查找是否存在 prefix_sum[j] - k 的值
            // 如果存在，说明找到了一个或多个满足条件的子数组起点
            // mp[sum - k] 的值就是满足条件的子数组的数量
            res += mp[sum - k];
        }
        
        return res;
    }
};
```