# 最小覆盖子串

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/minimum-window-substring/)

---

## 题目描述

> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。
>
> **注意：**
> *   对于 `t` 中重复字符，我们寻找的子串中该字符数量必须不少于 `t` 中该字符数量。
> *   如果 `s` 中存在这样的子串，我们保证它是唯一的答案。
>
> **示例:**
> ```
> 输入: s = "ADOBECODEBANC", t = "ABC"
> 输出: "BANC"
> 解释: 最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。
> ```

---

## 解题思路

### 核心思想
采用**滑动窗口**和**哈希表**。我们用一个哈希表 `mp` 来记录目标字符串 `t` 中需要的字符及其数量。`op` 变量作为一个计数器，记录当前窗口已经满足了 `t` 中多少个字符的需求。

1.  **扩展窗口**：右指针 `r` 向右移动，将新字符纳入窗口。如果这个字符是 `t` 中需要的，我们就更新 `op` 计数器。
2.  **收缩窗口**：一旦 `op` 的值等于 `t` 的长度 `m`，说明当前窗口已经是一个有效的覆盖子串。此时，我们尝试从左边收缩窗口（移动 `l` 指针），在保持窗口有效的前提下，找到尽可能小的窗口，并更新结果。

### 算法步骤
1.  **初始化**:
    *   创建一个哈希表 `mp`，遍历 `t` 字符串，统计其中每个字符的出现次数。
    *   初始化左指针 `l = 0`，有效字符计数器 `op = 0`。
    *   初始化一个变量 `min_len` 存储最小长度，一个 `start` 变量存储最小子串的起始索引。
2.  **遍历 `s` (扩大窗口)**: 使用右指针 `r` 遍历字符串 `s`。
3.  **更新窗口状态**:
    *   检查 `s[r]` 是否是 `t` 中需要的字符（即在 `mp` 中）。
    *   如果是，将其在 `mp` 中的需求量减一。
    *   如果减一之前的需求量 `mp[s[r]]` 大于 `0`，说明这次纳入的字符是一个**有效需求**，将 `op` 加一。
4.  **检查并收缩窗口**: 当 `op == m` 时，说明当前窗口 `[l, r]` 已经是一个有效的覆盖子串。
    *   进入 `while` 循环，尝试收缩左边界 `l`。
    *   首先，更新最小子串记录：如果当前窗口长度 `r - l + 1` 比已记录的 `min_len` 更小，则更新 `min_len` 和 `start`。
    *   检查 `s[l]` 是否是 `t` 中需要的字符。
    *   如果是，将其在 `mp` 中的需求量加一。
    *   如果加一后，`mp[s[l]]` 的值从 `0` 变为 `1`，说明这个字符从“满足”状态变为了“不满足”，窗口不再是有效的覆盖子串，将 `op` 减一。
    *   将 `l` 指针右移一位。`while` 循环直到 `op < m` 终止。
5.  **返回结果**: 遍历结束后，如果 `min_len` 未被更新（仍为初始极大值），说明未找到有效子串，返回 `""`。否则，使用 `start` 和 `min_len` 从 `s` 中截取最小覆盖子串并返回。

### 复杂度分析
- **时间复杂度**: O(N + M)
  *其中 N 和 M 分别是字符串 `s` 和 `t` 的长度。预处理哈希表需要 O(M)。滑动窗口的两个指针 `l` 和 `r` 都只会遍历 `s` 一次，所以总时间复杂度是线性的。*
- **空间复杂度**: O(K)
  *其中 K 是字符集的大小。哈希表 `mp` 需要存储 `t` 中的字符信息。*

---

## 代码实现

```cpp
#include <string>
#include <vector>
#include <unordered_map>
#include <limits> // for std::numeric_limits

class Solution {
public:
    std::string minWindow(std::string s, std::string t) {
        // mp 用来记录 t 中每个字符需要的数量
        std::unordered_map<char, int> mp;
        for(char c : t) {
            mp[c]++;
        }

        int n = s.size(), m = t.size();
        int l = 0;
        // op 记录当前窗口已经满足 t 中字符的数量
        int op = 0;
        
        // 用于记录最小子串的起始位置和长度
        int start = 0;
        int min_len = std::numeric_limits<int>::max();

        for(int r = 0; r < n; r++) {
            char r_char = s[r];
            // 如果 r 指向的字符是 t 中需要的
            if(mp.count(r_char)) {
                // 如果该字符的需求量 > 0，说明这次匹配是有效的
                if(mp[r_char] > 0) {
                    op++;
                }
                // 将该字符的需求量减一
                mp[r_char]--;
            }

            // 当窗口已经满足所有 t 中字符时，尝试收缩左边界
            while(op == m) {
                // 更新最小覆盖子串的记录
                if (r - l + 1 < min_len) {
                    start = l;
                    min_len = r - l + 1;
                }
                
                char l_char = s[l];
                // 如果 l 指向的字符是 t 中需要的
                if(mp.count(l_char)) {
                    // 将该字符的需求量加一，因为它要离开窗口了
                    mp[l_char]++;
                    // 如果加一后，需求量从 0 变为 1，说明窗口不再满足条件
                    if(mp[l_char] > 0) {
                        op--;
                    }
                }
                // 收缩左边界
                l++;
            }
        }
        
        // 如果 min_len 没有被更新过，说明没有找到覆盖子串
        return min_len == std::numeric_limits<int>::max() ? "" : s.substr(start, min_len);
    }
};    
```