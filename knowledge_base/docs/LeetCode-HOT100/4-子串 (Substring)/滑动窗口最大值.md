# 滑动窗口最大值

> **题目链接:** [LeetCode Link](https://leetcode.cn/problems/sliding-window-maximum/)

---

## 题目描述

> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。
>
> 返回 *滑动窗口中的最大值* 。
>
> **示例:**
> ```
> 输入: nums = [1,3,-1,-3,5,3,6,7], k = 3
> 输出: [3,3,5,5,6,7]
> ```

---

## 解题思路

### 核心思想
这个问题的核心是在一个移动的窗口内高效地找到最大值。暴力法（对每个窗口都遍历一次找最大值）的时间复杂度为 O(N*K)，效率太低。我们需要一种数据结构，它能够：
1.  高效地添加新元素。
2.  高效地移除旧元素。
3.  高效地查询当前窗口内的最大值。

**单调队列**和**优先队列（堆**就是满足这些需求的两种常用数据结构。

---

### 解法一：单调队列 (使用 `deque`)

这是解决此类问题的**最优解**。我们维护一个双端队列 `deque`，其中存储的是**数组的索引**，并且这些索引对应的 `nums` 值是**严格单调递减**的。

#### 算法步骤
1.  **初始化**: 创建一个双端队列 `deque<int> mq` 用于存储索引，以及一个结果向量 `res`。
2.  **遍历数组**: 遍历 `nums` 数组，索引为 `i`。
3.  **维护队列的单调性 (队尾操作)**:
    *   在将新元素 `i` 加入队列之前，从**队尾**开始检查。
    *   `while` 循环，如果队列不为空且新元素 `nums[i]` 大于等于队尾索引对应的元素 `nums[mq.back()]`，则将队尾元素弹出。
    *   这个过程确保了队列的单调递减性，因为一个更晚出现且值更大的元素会让所有在它之前且比它小的元素“永无出头之日”。
4.  **入队**: 将当前元素的索引 `i` 加入队尾。
5.  **处理队首过期元素 (队首操作)**:
    *   检查队首元素的索引 `mq.front()` 是否已经**滑出**了当前窗口的左边界（即 `mq.front() <= i - k`）。
    *   如果是，则从**队首**弹出该元素。
6.  **记录结果**: 当窗口形成后（即 `i >= k - 1`），当前窗口的最大值就是队首索引对应的元素 `nums[mq.front()]`，将其加入 `res`。
7.  **返回**: 遍历结束后返回 `res`。

#### 复杂度分析
- **时间复杂度**: O(N)
  *每个元素最多入队一次，出队一次，因此总的时间复杂度是线性的。*
- **空间复杂度**: O(K)
  *双端队列 `deque` 在最坏情况下会存储 `k` 个元素的索引。*

---

### 解法二：优先队列 (大顶堆)

这种方法更直观，但效率略低于单调队列。我们用一个大顶堆来维护窗口内的元素。

#### 算法步骤
1.  **初始化**: 创建一个优先队列 `priority_queue<pair<int, int>> pq`，用于存储 `{数值, 索引}` 对，并按数值从大到小排序。
2.  **遍历数组**: 遍历 `nums` 数组，索引为 `i`。
3.  **入队**: 将当前元素 `{nums[i], i}` 加入优先队列。
4.  **形成窗口并记录结果**: 当窗口形成后（即 `i >= k - 1`）：
    *   **处理堆顶过期元素**: 检查堆顶元素 `pq.top()` 的索引是否已经滑出窗口左边界（即 `pq.top().second <= i - k`）。
    *   如果是，则持续 `pop` 堆顶元素，直到堆顶是一个在窗口内的有效元素为止。这个过程称为“惰性删除”。
    *   此时，堆顶元素 `pq.top().first` 就是当前窗口的最大值，将其加入 `res`。
5.  **返回**: 遍历结束后返回 `res`。

#### 复杂度分析
- **时间复杂度**: O(N log K)
  *遍历数组需要 O(N)，每次向优先队列中插入或删除元素的时间复杂度为 O(log K)，其中 K 是堆的大小（最多为 k）。*
- **空间复杂度**: O(K)
  *优先队列最多存储 `k` 个元素。*

---

## 代码实现

### 解法一：单调队列

```cpp
#include <vector>
#include <deque>
#include <algorithm>

class Solution {
public:
    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {
        int n = nums.size();
        std::vector<int> res;
        // 使用双端队列存储数组索引
        std::deque<int> mq;

        for(int i = 0; i < n; i++) {
            // 1. 维护队列单调性：从队尾移除所有小于等于当前值的元素
            while(!mq.empty() && nums[i] >= nums[mq.back()]) {
                mq.pop_back();
            }
            
            // 2. 将当前元素索引入队
            mq.push_back(i);

            // 3. 移除过期的队首元素
            // 窗口的左边界是 i - k + 1，所以 i - k 是窗口外的第一个位置
            if(mq.front() <= i - k) {
                mq.pop_front();
            }
            
            // 4. 当窗口形成后，记录当前窗口的最大值（即队首元素）
            if(i >= k - 1) {
                res.push_back(nums[mq.front()]);
            }
        }
        return res;
    }
};
```
### 解法二：优先队列 (大顶堆)

```C++
#include <vector>
#include <queue>
#include <utility> // for std::pair

class Solution {
public:
    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {
        std::vector<int> res;
        int n = nums.size();
        // 创建大顶堆，存储 {数值, 索引}
        std::priority_queue<std::pair<int, int>> pq;

        for(int i = 0; i < n; i++) {
            // 1. 将当前元素和索引加入优先队列
            pq.push({nums[i], i});

            // 2. 当窗口形成后开始记录
            if(i >= k - 1) {
                // 3. 惰性删除：移除堆顶所有已滑出窗口的元素
                while(pq.top().second <= i - k) {
                    pq.pop();
                }
                // 此时的堆顶元素就是当前窗口的最大值
                res.push_back(pq.top().first);
            }
        }
        return res;
    }
};
```