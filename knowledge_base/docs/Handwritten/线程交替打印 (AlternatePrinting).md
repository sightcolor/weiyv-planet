# 多线程按序打印 1-100

> **问题类型:** 多线程同步与协调 (Multithreading Synchronization & Coordination)

---

## 问题描述

使用多个线程（例如3个或5个），严格按照 `1, 2, 3, ..., 100` 的顺序打印数字。

### 核心挑战
这个问题的本质是在 **并发、无序** 的多线程环境下，强制实现 **串行、有序** 的逻辑。线程的执行顺序由操作系统调度，本身是不可预测的。因此，我们必须引入一个强大的**线程协调机制**，让所有线程都遵守同一个“游戏规则”，确保在任何时刻只有一个“正确”的线程在工作。

---

## 解题思路与核心工具

要实现这个协调机制，我们需要一个“黄金铁三角”组合：

1.  **共享状态 (`int curr`)**: 这是一个所有线程都能看到的“信号灯”或“指挥官”，用来指示“现在应该打印哪个数字了？”。

2.  **互斥锁 (`std::mutex`)**: 这是一个“会议室的门卫”。当任何线程需要检查或修改共享状态 `curr` 时，必须先获取这把锁。这保证了对 `curr` 的访问是互斥的，防止了数据竞争。

3.  **条件变量 (`std::condition_variable`)**: 这是一个“智能的会议主持人”。它的核心作用是解决**高效等待**的问题。当一个线程获取锁后，发现“会议议程”（业务逻辑）还没轮到自己，它不能在会议室里“忙等”（消耗CPU），而是应该去“等候室”**休眠 (`wait`)**，并交出会议室的钥匙（自动释放锁）。当其他线程更新了共享状态后，会**通知 (`notify`)** 等候室里的线程，把它们唤醒来重新检查条件。

### 线程的任务分配
为了让多个线程协同工作，我们采用“取余分配”的策略，将打印任务均匀地分配给每个线程：
*   我们有 `N` 个线程，其ID我们自己定义为 `0, 1, ..., N-1`。
*   **线程 `i`** 的工作职责是：**当且仅当 `curr % N == i` 时，由我负责打印。** 
    *(注：这是一个简化的分工，更严谨的无偏差分工是 `(curr - 1) % N == i`，但核心思想一致)*

---

## 代码编写思考流程

每个线程都会在一个 `while(true)` 循环中不断尝试执行任务，其内部逻辑如下：

1.  **获取锁**: 进入循环后，立刻使用 `std::unique_lock` 获取互斥锁，准备进入临界区。

2.  **检查条件并等待**: 调用 `cv.wait()`，并将“游戏规则”作为 Lambda 表达式传入。
    *   **等待条件是**：“任务已完成 (`curr > 100`)，**或者** 现在轮到我了 (`curr % N == my_id`)”。
    *   如果这个复合条件不满足，`wait` 函数会自动释放锁，并让当前线程进入休眠状态。这是整个机制高效运行的关键。

3.  **检查并退出**: 当线程从 `wait` 被唤醒后（说明条件可能满足了），第一件事就是检查 `curr > 100` 是否成立。
    *   如果成立，说明所有数字都打印完毕，线程应该退出。
    *   **关键点**: 在 `break` 退出前，必须**再次调用 `cv.notify_all()`**。这是为了确保所有其他可能还在休眠的线程也能被唤醒，从而检查到 `curr > 100` 并正常退出，防止死锁。

4.  **执行任务**: 如果没有退出，说明现在轮到自己了。执行打印操作。

5.  **更新状态**: 将共享变量 `curr` 加一。

6.  **发出通知**: 因为共享状态 `curr` 已经改变，可能轮到下一个线程了。必须调用 `cv.notify_all()` 来唤醒所有在等候室休眠的线程，让它们来重新检查条件。

---

## 最终代码实现

```cpp
#include <iostream>
#include <thread>
#include <condition_variable>
#include <mutex>
#include <vector>

// 使用宏定义或常量来管理线程数，避免硬编码
#define THREAD_NUM 5

// --- 全局共享的协调组件 ---
std::mutex mtx;
std::condition_variable cv;
int curr = 1; // 从1开始打印

/**
 * @brief 每个线程执行的任务函数 (Process)
 * @param id  当前线程的唯一标识 (0, 1, 2...)
 */
void process(int id) {
    while(true) {
        // 1. 获取锁，准备访问共享资源
        std::unique_lock<std::mutex> lock(mtx);

        // 2. 等待轮到自己，或任务结束
        cv.wait(lock, [=]() -> bool {
            // 只有在任务完成，或者轮到我时，才会被唤醒并继续执行
            return curr > 100 || curr % THREAD_NUM == id;
        });

        // 3. 检查是否应退出
        if(curr > 100) {
            // 我要退出了，必须叫醒其他还在睡的兄弟，让他们也能退出
            cv.notify_all();
            break;
        }

        // 4. 执行任务
        std::cout << "Thread " << id << ": processing " << curr << std::endl;

        // 5. 更新共享状态
        curr++;
        
        // 6. 状态已更新，唤醒所有其他线程来检查新状态
        cv.notify_all();
    }
}

int main() {
    std::vector<std::thread> threads;

    // 创建并启动所有线程
    for(int i = 0; i < THREAD_NUM; i++) {
        threads.emplace_back(process, i);
    }

    // 主线程必须等待所有子线程执行完毕
    for(auto& it : threads) {
        if(it.joinable()) {
            it.join();
        }
    }

    std::cout << "Done!" << std::endl;
    return 0;
}
```